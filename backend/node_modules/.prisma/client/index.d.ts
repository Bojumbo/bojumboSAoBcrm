
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Counterparty
 * 
 */
export type Counterparty = $Result.DefaultSelection<Prisma.$CounterpartyPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductStock
 * 
 */
export type ProductStock = $Result.DefaultSelection<Prisma.$ProductStockPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model SaleStatusType
 * 
 */
export type SaleStatusType = $Result.DefaultSelection<Prisma.$SaleStatusTypePayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleProduct
 * 
 */
export type SaleProduct = $Result.DefaultSelection<Prisma.$SaleProductPayload>
/**
 * Model SaleService
 * 
 */
export type SaleService = $Result.DefaultSelection<Prisma.$SaleServicePayload>
/**
 * Model Funnel
 * 
 */
export type Funnel = $Result.DefaultSelection<Prisma.$FunnelPayload>
/**
 * Model FunnelStage
 * 
 */
export type FunnelStage = $Result.DefaultSelection<Prisma.$FunnelStagePayload>
/**
 * Model SubProjectStatusType
 * 
 */
export type SubProjectStatusType = $Result.DefaultSelection<Prisma.$SubProjectStatusTypePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectManager
 * 
 */
export type ProjectManager = $Result.DefaultSelection<Prisma.$ProjectManagerPayload>
/**
 * Model SubProject
 * 
 */
export type SubProject = $Result.DefaultSelection<Prisma.$SubProjectPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model ProjectProduct
 * 
 */
export type ProjectProduct = $Result.DefaultSelection<Prisma.$ProjectProductPayload>
/**
 * Model ProjectService
 * 
 */
export type ProjectService = $Result.DefaultSelection<Prisma.$ProjectServicePayload>
/**
 * Model SubProjectProduct
 * 
 */
export type SubProjectProduct = $Result.DefaultSelection<Prisma.$SubProjectProductPayload>
/**
 * Model SubProjectService
 * 
 */
export type SubProjectService = $Result.DefaultSelection<Prisma.$SubProjectServicePayload>
/**
 * Model ProjectComment
 * 
 */
export type ProjectComment = $Result.DefaultSelection<Prisma.$ProjectCommentPayload>
/**
 * Model SubProjectComment
 * 
 */
export type SubProjectComment = $Result.DefaultSelection<Prisma.$SubProjectCommentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ManagerRole: {
  admin: 'admin',
  head: 'head',
  manager: 'manager'
};

export type ManagerRole = (typeof ManagerRole)[keyof typeof ManagerRole]


export const CounterpartyType: {
  INDIVIDUAL: 'INDIVIDUAL',
  LEGAL_ENTITY: 'LEGAL_ENTITY'
};

export type CounterpartyType = (typeof CounterpartyType)[keyof typeof CounterpartyType]


export const TaskStatus: {
  new: 'new',
  in_progress: 'in_progress',
  blocked: 'blocked',
  done: 'done',
  cancelled: 'cancelled'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]

}

export type ManagerRole = $Enums.ManagerRole

export const ManagerRole: typeof $Enums.ManagerRole

export type CounterpartyType = $Enums.CounterpartyType

export const CounterpartyType: typeof $Enums.CounterpartyType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Managers
 * const managers = await prisma.manager.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Managers
   * const managers = await prisma.manager.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs>;

  /**
   * `prisma.counterparty`: Exposes CRUD operations for the **Counterparty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counterparties
    * const counterparties = await prisma.counterparty.findMany()
    * ```
    */
  get counterparty(): Prisma.CounterpartyDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productStock`: Exposes CRUD operations for the **ProductStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStocks
    * const productStocks = await prisma.productStock.findMany()
    * ```
    */
  get productStock(): Prisma.ProductStockDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.saleStatusType`: Exposes CRUD operations for the **SaleStatusType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleStatusTypes
    * const saleStatusTypes = await prisma.saleStatusType.findMany()
    * ```
    */
  get saleStatusType(): Prisma.SaleStatusTypeDelegate<ExtArgs>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs>;

  /**
   * `prisma.saleProduct`: Exposes CRUD operations for the **SaleProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleProducts
    * const saleProducts = await prisma.saleProduct.findMany()
    * ```
    */
  get saleProduct(): Prisma.SaleProductDelegate<ExtArgs>;

  /**
   * `prisma.saleService`: Exposes CRUD operations for the **SaleService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleServices
    * const saleServices = await prisma.saleService.findMany()
    * ```
    */
  get saleService(): Prisma.SaleServiceDelegate<ExtArgs>;

  /**
   * `prisma.funnel`: Exposes CRUD operations for the **Funnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funnels
    * const funnels = await prisma.funnel.findMany()
    * ```
    */
  get funnel(): Prisma.FunnelDelegate<ExtArgs>;

  /**
   * `prisma.funnelStage`: Exposes CRUD operations for the **FunnelStage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunnelStages
    * const funnelStages = await prisma.funnelStage.findMany()
    * ```
    */
  get funnelStage(): Prisma.FunnelStageDelegate<ExtArgs>;

  /**
   * `prisma.subProjectStatusType`: Exposes CRUD operations for the **SubProjectStatusType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubProjectStatusTypes
    * const subProjectStatusTypes = await prisma.subProjectStatusType.findMany()
    * ```
    */
  get subProjectStatusType(): Prisma.SubProjectStatusTypeDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectManager`: Exposes CRUD operations for the **ProjectManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectManagers
    * const projectManagers = await prisma.projectManager.findMany()
    * ```
    */
  get projectManager(): Prisma.ProjectManagerDelegate<ExtArgs>;

  /**
   * `prisma.subProject`: Exposes CRUD operations for the **SubProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubProjects
    * const subProjects = await prisma.subProject.findMany()
    * ```
    */
  get subProject(): Prisma.SubProjectDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.projectProduct`: Exposes CRUD operations for the **ProjectProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectProducts
    * const projectProducts = await prisma.projectProduct.findMany()
    * ```
    */
  get projectProduct(): Prisma.ProjectProductDelegate<ExtArgs>;

  /**
   * `prisma.projectService`: Exposes CRUD operations for the **ProjectService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectServices
    * const projectServices = await prisma.projectService.findMany()
    * ```
    */
  get projectService(): Prisma.ProjectServiceDelegate<ExtArgs>;

  /**
   * `prisma.subProjectProduct`: Exposes CRUD operations for the **SubProjectProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubProjectProducts
    * const subProjectProducts = await prisma.subProjectProduct.findMany()
    * ```
    */
  get subProjectProduct(): Prisma.SubProjectProductDelegate<ExtArgs>;

  /**
   * `prisma.subProjectService`: Exposes CRUD operations for the **SubProjectService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubProjectServices
    * const subProjectServices = await prisma.subProjectService.findMany()
    * ```
    */
  get subProjectService(): Prisma.SubProjectServiceDelegate<ExtArgs>;

  /**
   * `prisma.projectComment`: Exposes CRUD operations for the **ProjectComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectComments
    * const projectComments = await prisma.projectComment.findMany()
    * ```
    */
  get projectComment(): Prisma.ProjectCommentDelegate<ExtArgs>;

  /**
   * `prisma.subProjectComment`: Exposes CRUD operations for the **SubProjectComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubProjectComments
    * const subProjectComments = await prisma.subProjectComment.findMany()
    * ```
    */
  get subProjectComment(): Prisma.SubProjectCommentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Manager: 'Manager',
    Counterparty: 'Counterparty',
    Unit: 'Unit',
    Warehouse: 'Warehouse',
    Product: 'Product',
    ProductStock: 'ProductStock',
    Service: 'Service',
    SaleStatusType: 'SaleStatusType',
    Sale: 'Sale',
    SaleProduct: 'SaleProduct',
    SaleService: 'SaleService',
    Funnel: 'Funnel',
    FunnelStage: 'FunnelStage',
    SubProjectStatusType: 'SubProjectStatusType',
    Project: 'Project',
    ProjectManager: 'ProjectManager',
    SubProject: 'SubProject',
    Task: 'Task',
    ProjectProduct: 'ProjectProduct',
    ProjectService: 'ProjectService',
    SubProjectProduct: 'SubProjectProduct',
    SubProjectService: 'SubProjectService',
    ProjectComment: 'ProjectComment',
    SubProjectComment: 'SubProjectComment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "manager" | "counterparty" | "unit" | "warehouse" | "product" | "productStock" | "service" | "saleStatusType" | "sale" | "saleProduct" | "saleService" | "funnel" | "funnelStage" | "subProjectStatusType" | "project" | "projectManager" | "subProject" | "task" | "projectProduct" | "projectService" | "subProjectProduct" | "subProjectService" | "projectComment" | "subProjectComment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Counterparty: {
        payload: Prisma.$CounterpartyPayload<ExtArgs>
        fields: Prisma.CounterpartyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CounterpartyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CounterpartyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          findFirst: {
            args: Prisma.CounterpartyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CounterpartyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          findMany: {
            args: Prisma.CounterpartyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>[]
          }
          create: {
            args: Prisma.CounterpartyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          createMany: {
            args: Prisma.CounterpartyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CounterpartyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>[]
          }
          delete: {
            args: Prisma.CounterpartyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          update: {
            args: Prisma.CounterpartyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          deleteMany: {
            args: Prisma.CounterpartyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CounterpartyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CounterpartyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CounterpartyPayload>
          }
          aggregate: {
            args: Prisma.CounterpartyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounterparty>
          }
          groupBy: {
            args: Prisma.CounterpartyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounterpartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CounterpartyCountArgs<ExtArgs>
            result: $Utils.Optional<CounterpartyCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductStock: {
        payload: Prisma.$ProductStockPayload<ExtArgs>
        fields: Prisma.ProductStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findFirst: {
            args: Prisma.ProductStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          findMany: {
            args: Prisma.ProductStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          create: {
            args: Prisma.ProductStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          createMany: {
            args: Prisma.ProductStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>[]
          }
          delete: {
            args: Prisma.ProductStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          update: {
            args: Prisma.ProductStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          deleteMany: {
            args: Prisma.ProductStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStockPayload>
          }
          aggregate: {
            args: Prisma.ProductStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStock>
          }
          groupBy: {
            args: Prisma.ProductStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStockCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStockCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      SaleStatusType: {
        payload: Prisma.$SaleStatusTypePayload<ExtArgs>
        fields: Prisma.SaleStatusTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleStatusTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleStatusTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          findFirst: {
            args: Prisma.SaleStatusTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleStatusTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          findMany: {
            args: Prisma.SaleStatusTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>[]
          }
          create: {
            args: Prisma.SaleStatusTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          createMany: {
            args: Prisma.SaleStatusTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleStatusTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>[]
          }
          delete: {
            args: Prisma.SaleStatusTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          update: {
            args: Prisma.SaleStatusTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          deleteMany: {
            args: Prisma.SaleStatusTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleStatusTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleStatusTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleStatusTypePayload>
          }
          aggregate: {
            args: Prisma.SaleStatusTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleStatusType>
          }
          groupBy: {
            args: Prisma.SaleStatusTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleStatusTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleStatusTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SaleStatusTypeCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleProduct: {
        payload: Prisma.$SaleProductPayload<ExtArgs>
        fields: Prisma.SaleProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findFirst: {
            args: Prisma.SaleProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findMany: {
            args: Prisma.SaleProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          create: {
            args: Prisma.SaleProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          createMany: {
            args: Prisma.SaleProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          delete: {
            args: Prisma.SaleProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          update: {
            args: Prisma.SaleProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          deleteMany: {
            args: Prisma.SaleProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          aggregate: {
            args: Prisma.SaleProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleProduct>
          }
          groupBy: {
            args: Prisma.SaleProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleProductCountArgs<ExtArgs>
            result: $Utils.Optional<SaleProductCountAggregateOutputType> | number
          }
        }
      }
      SaleService: {
        payload: Prisma.$SaleServicePayload<ExtArgs>
        fields: Prisma.SaleServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          findFirst: {
            args: Prisma.SaleServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          findMany: {
            args: Prisma.SaleServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>[]
          }
          create: {
            args: Prisma.SaleServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          createMany: {
            args: Prisma.SaleServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>[]
          }
          delete: {
            args: Prisma.SaleServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          update: {
            args: Prisma.SaleServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          deleteMany: {
            args: Prisma.SaleServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleServicePayload>
          }
          aggregate: {
            args: Prisma.SaleServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleService>
          }
          groupBy: {
            args: Prisma.SaleServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleServiceCountArgs<ExtArgs>
            result: $Utils.Optional<SaleServiceCountAggregateOutputType> | number
          }
        }
      }
      Funnel: {
        payload: Prisma.$FunnelPayload<ExtArgs>
        fields: Prisma.FunnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          findFirst: {
            args: Prisma.FunnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          findMany: {
            args: Prisma.FunnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>[]
          }
          create: {
            args: Prisma.FunnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          createMany: {
            args: Prisma.FunnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>[]
          }
          delete: {
            args: Prisma.FunnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          update: {
            args: Prisma.FunnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          deleteMany: {
            args: Prisma.FunnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelPayload>
          }
          aggregate: {
            args: Prisma.FunnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnel>
          }
          groupBy: {
            args: Prisma.FunnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelCountAggregateOutputType> | number
          }
        }
      }
      FunnelStage: {
        payload: Prisma.$FunnelStagePayload<ExtArgs>
        fields: Prisma.FunnelStageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelStageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelStageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          findFirst: {
            args: Prisma.FunnelStageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelStageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          findMany: {
            args: Prisma.FunnelStageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>[]
          }
          create: {
            args: Prisma.FunnelStageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          createMany: {
            args: Prisma.FunnelStageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelStageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>[]
          }
          delete: {
            args: Prisma.FunnelStageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          update: {
            args: Prisma.FunnelStageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          deleteMany: {
            args: Prisma.FunnelStageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelStageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunnelStageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelStagePayload>
          }
          aggregate: {
            args: Prisma.FunnelStageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnelStage>
          }
          groupBy: {
            args: Prisma.FunnelStageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelStageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelStageCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelStageCountAggregateOutputType> | number
          }
        }
      }
      SubProjectStatusType: {
        payload: Prisma.$SubProjectStatusTypePayload<ExtArgs>
        fields: Prisma.SubProjectStatusTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubProjectStatusTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubProjectStatusTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          findFirst: {
            args: Prisma.SubProjectStatusTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubProjectStatusTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          findMany: {
            args: Prisma.SubProjectStatusTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>[]
          }
          create: {
            args: Prisma.SubProjectStatusTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          createMany: {
            args: Prisma.SubProjectStatusTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubProjectStatusTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>[]
          }
          delete: {
            args: Prisma.SubProjectStatusTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          update: {
            args: Prisma.SubProjectStatusTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          deleteMany: {
            args: Prisma.SubProjectStatusTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubProjectStatusTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubProjectStatusTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectStatusTypePayload>
          }
          aggregate: {
            args: Prisma.SubProjectStatusTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubProjectStatusType>
          }
          groupBy: {
            args: Prisma.SubProjectStatusTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubProjectStatusTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubProjectStatusTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SubProjectStatusTypeCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectManager: {
        payload: Prisma.$ProjectManagerPayload<ExtArgs>
        fields: Prisma.ProjectManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          findFirst: {
            args: Prisma.ProjectManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          findMany: {
            args: Prisma.ProjectManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>[]
          }
          create: {
            args: Prisma.ProjectManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          createMany: {
            args: Prisma.ProjectManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>[]
          }
          delete: {
            args: Prisma.ProjectManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          update: {
            args: Prisma.ProjectManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          deleteMany: {
            args: Prisma.ProjectManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectManagerPayload>
          }
          aggregate: {
            args: Prisma.ProjectManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectManager>
          }
          groupBy: {
            args: Prisma.ProjectManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectManagerCountAggregateOutputType> | number
          }
        }
      }
      SubProject: {
        payload: Prisma.$SubProjectPayload<ExtArgs>
        fields: Prisma.SubProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          findFirst: {
            args: Prisma.SubProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          findMany: {
            args: Prisma.SubProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>[]
          }
          create: {
            args: Prisma.SubProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          createMany: {
            args: Prisma.SubProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>[]
          }
          delete: {
            args: Prisma.SubProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          update: {
            args: Prisma.SubProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          deleteMany: {
            args: Prisma.SubProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectPayload>
          }
          aggregate: {
            args: Prisma.SubProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubProject>
          }
          groupBy: {
            args: Prisma.SubProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubProjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      ProjectProduct: {
        payload: Prisma.$ProjectProductPayload<ExtArgs>
        fields: Prisma.ProjectProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          findFirst: {
            args: Prisma.ProjectProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          findMany: {
            args: Prisma.ProjectProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>[]
          }
          create: {
            args: Prisma.ProjectProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          createMany: {
            args: Prisma.ProjectProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>[]
          }
          delete: {
            args: Prisma.ProjectProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          update: {
            args: Prisma.ProjectProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          deleteMany: {
            args: Prisma.ProjectProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectProductPayload>
          }
          aggregate: {
            args: Prisma.ProjectProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectProduct>
          }
          groupBy: {
            args: Prisma.ProjectProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectProductCountAggregateOutputType> | number
          }
        }
      }
      ProjectService: {
        payload: Prisma.$ProjectServicePayload<ExtArgs>
        fields: Prisma.ProjectServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          findFirst: {
            args: Prisma.ProjectServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          findMany: {
            args: Prisma.ProjectServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>[]
          }
          create: {
            args: Prisma.ProjectServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          createMany: {
            args: Prisma.ProjectServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>[]
          }
          delete: {
            args: Prisma.ProjectServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          update: {
            args: Prisma.ProjectServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          deleteMany: {
            args: Prisma.ProjectServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectServicePayload>
          }
          aggregate: {
            args: Prisma.ProjectServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectService>
          }
          groupBy: {
            args: Prisma.ProjectServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectServiceCountAggregateOutputType> | number
          }
        }
      }
      SubProjectProduct: {
        payload: Prisma.$SubProjectProductPayload<ExtArgs>
        fields: Prisma.SubProjectProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubProjectProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubProjectProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          findFirst: {
            args: Prisma.SubProjectProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubProjectProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          findMany: {
            args: Prisma.SubProjectProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>[]
          }
          create: {
            args: Prisma.SubProjectProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          createMany: {
            args: Prisma.SubProjectProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubProjectProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>[]
          }
          delete: {
            args: Prisma.SubProjectProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          update: {
            args: Prisma.SubProjectProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          deleteMany: {
            args: Prisma.SubProjectProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubProjectProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubProjectProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectProductPayload>
          }
          aggregate: {
            args: Prisma.SubProjectProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubProjectProduct>
          }
          groupBy: {
            args: Prisma.SubProjectProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubProjectProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubProjectProductCountArgs<ExtArgs>
            result: $Utils.Optional<SubProjectProductCountAggregateOutputType> | number
          }
        }
      }
      SubProjectService: {
        payload: Prisma.$SubProjectServicePayload<ExtArgs>
        fields: Prisma.SubProjectServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubProjectServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubProjectServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          findFirst: {
            args: Prisma.SubProjectServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubProjectServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          findMany: {
            args: Prisma.SubProjectServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>[]
          }
          create: {
            args: Prisma.SubProjectServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          createMany: {
            args: Prisma.SubProjectServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubProjectServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>[]
          }
          delete: {
            args: Prisma.SubProjectServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          update: {
            args: Prisma.SubProjectServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          deleteMany: {
            args: Prisma.SubProjectServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubProjectServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubProjectServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectServicePayload>
          }
          aggregate: {
            args: Prisma.SubProjectServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubProjectService>
          }
          groupBy: {
            args: Prisma.SubProjectServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubProjectServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubProjectServiceCountArgs<ExtArgs>
            result: $Utils.Optional<SubProjectServiceCountAggregateOutputType> | number
          }
        }
      }
      ProjectComment: {
        payload: Prisma.$ProjectCommentPayload<ExtArgs>
        fields: Prisma.ProjectCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          findFirst: {
            args: Prisma.ProjectCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          findMany: {
            args: Prisma.ProjectCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>[]
          }
          create: {
            args: Prisma.ProjectCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          createMany: {
            args: Prisma.ProjectCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>[]
          }
          delete: {
            args: Prisma.ProjectCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          update: {
            args: Prisma.ProjectCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectCommentPayload>
          }
          aggregate: {
            args: Prisma.ProjectCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectComment>
          }
          groupBy: {
            args: Prisma.ProjectCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCommentCountAggregateOutputType> | number
          }
        }
      }
      SubProjectComment: {
        payload: Prisma.$SubProjectCommentPayload<ExtArgs>
        fields: Prisma.SubProjectCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubProjectCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubProjectCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          findFirst: {
            args: Prisma.SubProjectCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubProjectCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          findMany: {
            args: Prisma.SubProjectCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>[]
          }
          create: {
            args: Prisma.SubProjectCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          createMany: {
            args: Prisma.SubProjectCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubProjectCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>[]
          }
          delete: {
            args: Prisma.SubProjectCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          update: {
            args: Prisma.SubProjectCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          deleteMany: {
            args: Prisma.SubProjectCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubProjectCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubProjectCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubProjectCommentPayload>
          }
          aggregate: {
            args: Prisma.SubProjectCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubProjectComment>
          }
          groupBy: {
            args: Prisma.SubProjectCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubProjectCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubProjectCommentCountArgs<ExtArgs>
            result: $Utils.Optional<SubProjectCommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    supervisors: number
    subordinates: number
    counterparties: number
    sales: number
    projects_as_main: number
    projects_as_secondary: number
    tasks_as_responsible: number
    tasks_as_creator: number
    project_comments: number
    subproject_comments: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supervisors?: boolean | ManagerCountOutputTypeCountSupervisorsArgs
    subordinates?: boolean | ManagerCountOutputTypeCountSubordinatesArgs
    counterparties?: boolean | ManagerCountOutputTypeCountCounterpartiesArgs
    sales?: boolean | ManagerCountOutputTypeCountSalesArgs
    projects_as_main?: boolean | ManagerCountOutputTypeCountProjects_as_mainArgs
    projects_as_secondary?: boolean | ManagerCountOutputTypeCountProjects_as_secondaryArgs
    tasks_as_responsible?: boolean | ManagerCountOutputTypeCountTasks_as_responsibleArgs
    tasks_as_creator?: boolean | ManagerCountOutputTypeCountTasks_as_creatorArgs
    project_comments?: boolean | ManagerCountOutputTypeCountProject_commentsArgs
    subproject_comments?: boolean | ManagerCountOutputTypeCountSubproject_commentsArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountSupervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountCounterpartiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterpartyWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountProjects_as_mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountProjects_as_secondaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectManagerWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountTasks_as_responsibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountTasks_as_creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountProject_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCommentWhereInput
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountSubproject_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectCommentWhereInput
  }


  /**
   * Count Type CounterpartyCountOutputType
   */

  export type CounterpartyCountOutputType = {
    sales: number
    projects: number
  }

  export type CounterpartyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CounterpartyCountOutputTypeCountSalesArgs
    projects?: boolean | CounterpartyCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * CounterpartyCountOutputType without action
   */
  export type CounterpartyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterpartyCountOutputType
     */
    select?: CounterpartyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CounterpartyCountOutputType without action
   */
  export type CounterpartyCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * CounterpartyCountOutputType without action
   */
  export type CounterpartyCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    products: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | UnitCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    product_stocks: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_stocks?: boolean | WarehouseCountOutputTypeCountProduct_stocksArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountProduct_stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    stocks: number
    sales: number
    project_products: number
    subproject_products: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | ProductCountOutputTypeCountStocksArgs
    sales?: boolean | ProductCountOutputTypeCountSalesArgs
    project_products?: boolean | ProductCountOutputTypeCountProject_productsArgs
    subproject_products?: boolean | ProductCountOutputTypeCountSubproject_productsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProject_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSubproject_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectProductWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    sales: number
    project_services: number
    subproject_services: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | ServiceCountOutputTypeCountSalesArgs
    project_services?: boolean | ServiceCountOutputTypeCountProject_servicesArgs
    subproject_services?: boolean | ServiceCountOutputTypeCountSubproject_servicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProject_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountSubproject_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectServiceWhereInput
  }


  /**
   * Count Type SaleStatusTypeCountOutputType
   */

  export type SaleStatusTypeCountOutputType = {
    sales: number
  }

  export type SaleStatusTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | SaleStatusTypeCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * SaleStatusTypeCountOutputType without action
   */
  export type SaleStatusTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusTypeCountOutputType
     */
    select?: SaleStatusTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleStatusTypeCountOutputType without action
   */
  export type SaleStatusTypeCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    products: number
    services: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SaleCountOutputTypeCountProductsArgs
    services?: boolean | SaleCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
  }


  /**
   * Count Type FunnelCountOutputType
   */

  export type FunnelCountOutputType = {
    stages: number
    projects: number
  }

  export type FunnelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | FunnelCountOutputTypeCountStagesArgs
    projects?: boolean | FunnelCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelCountOutputType
     */
    select?: FunnelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelStageWhereInput
  }

  /**
   * FunnelCountOutputType without action
   */
  export type FunnelCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type FunnelStageCountOutputType
   */

  export type FunnelStageCountOutputType = {
    projects: number
  }

  export type FunnelStageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | FunnelStageCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * FunnelStageCountOutputType without action
   */
  export type FunnelStageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStageCountOutputType
     */
    select?: FunnelStageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunnelStageCountOutputType without action
   */
  export type FunnelStageCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    secondary_responsible_managers: number
    subprojects: number
    tasks: number
    sales: number
    products: number
    services: number
    comments: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    secondary_responsible_managers?: boolean | ProjectCountOutputTypeCountSecondary_responsible_managersArgs
    subprojects?: boolean | ProjectCountOutputTypeCountSubprojectsArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    sales?: boolean | ProjectCountOutputTypeCountSalesArgs
    products?: boolean | ProjectCountOutputTypeCountProductsArgs
    services?: boolean | ProjectCountOutputTypeCountServicesArgs
    comments?: boolean | ProjectCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSecondary_responsible_managersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectManagerWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSubprojectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectProductWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectServiceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCommentWhereInput
  }


  /**
   * Count Type SubProjectCountOutputType
   */

  export type SubProjectCountOutputType = {
    tasks: number
    comments: number
    products: number
    services: number
  }

  export type SubProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | SubProjectCountOutputTypeCountTasksArgs
    comments?: boolean | SubProjectCountOutputTypeCountCommentsArgs
    products?: boolean | SubProjectCountOutputTypeCountProductsArgs
    services?: boolean | SubProjectCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * SubProjectCountOutputType without action
   */
  export type SubProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectCountOutputType
     */
    select?: SubProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubProjectCountOutputType without action
   */
  export type SubProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * SubProjectCountOutputType without action
   */
  export type SubProjectCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectCommentWhereInput
  }

  /**
   * SubProjectCountOutputType without action
   */
  export type SubProjectCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectProductWhereInput
  }

  /**
   * SubProjectCountOutputType without action
   */
  export type SubProjectCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectServiceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    manager_id: number | null
  }

  export type ManagerSumAggregateOutputType = {
    manager_id: number | null
  }

  export type ManagerMinAggregateOutputType = {
    manager_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    role: $Enums.ManagerRole | null
    password_hash: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ManagerMaxAggregateOutputType = {
    manager_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    role: $Enums.ManagerRole | null
    password_hash: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ManagerCountAggregateOutputType = {
    manager_id: number
    first_name: number
    last_name: number
    email: number
    phone_number: number
    role: number
    password_hash: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    manager_id?: true
  }

  export type ManagerSumAggregateInputType = {
    manager_id?: true
  }

  export type ManagerMinAggregateInputType = {
    manager_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
  }

  export type ManagerMaxAggregateInputType = {
    manager_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
  }

  export type ManagerCountAggregateInputType = {
    manager_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    role?: true
    password_hash?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _avg?: ManagerAvgAggregateInputType
    _sum?: ManagerSumAggregateInputType
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    manager_id: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at: Date
    updated_at: Date
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    manager_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
    supervisors?: boolean | Manager$supervisorsArgs<ExtArgs>
    subordinates?: boolean | Manager$subordinatesArgs<ExtArgs>
    counterparties?: boolean | Manager$counterpartiesArgs<ExtArgs>
    sales?: boolean | Manager$salesArgs<ExtArgs>
    projects_as_main?: boolean | Manager$projects_as_mainArgs<ExtArgs>
    projects_as_secondary?: boolean | Manager$projects_as_secondaryArgs<ExtArgs>
    tasks_as_responsible?: boolean | Manager$tasks_as_responsibleArgs<ExtArgs>
    tasks_as_creator?: boolean | Manager$tasks_as_creatorArgs<ExtArgs>
    project_comments?: boolean | Manager$project_commentsArgs<ExtArgs>
    subproject_comments?: boolean | Manager$subproject_commentsArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    manager_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    manager_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    role?: boolean
    password_hash?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supervisors?: boolean | Manager$supervisorsArgs<ExtArgs>
    subordinates?: boolean | Manager$subordinatesArgs<ExtArgs>
    counterparties?: boolean | Manager$counterpartiesArgs<ExtArgs>
    sales?: boolean | Manager$salesArgs<ExtArgs>
    projects_as_main?: boolean | Manager$projects_as_mainArgs<ExtArgs>
    projects_as_secondary?: boolean | Manager$projects_as_secondaryArgs<ExtArgs>
    tasks_as_responsible?: boolean | Manager$tasks_as_responsibleArgs<ExtArgs>
    tasks_as_creator?: boolean | Manager$tasks_as_creatorArgs<ExtArgs>
    project_comments?: boolean | Manager$project_commentsArgs<ExtArgs>
    subproject_comments?: boolean | Manager$subproject_commentsArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      supervisors: Prisma.$ManagerPayload<ExtArgs>[]
      subordinates: Prisma.$ManagerPayload<ExtArgs>[]
      counterparties: Prisma.$CounterpartyPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      projects_as_main: Prisma.$ProjectPayload<ExtArgs>[]
      projects_as_secondary: Prisma.$ProjectManagerPayload<ExtArgs>[]
      tasks_as_responsible: Prisma.$TaskPayload<ExtArgs>[]
      tasks_as_creator: Prisma.$TaskPayload<ExtArgs>[]
      project_comments: Prisma.$ProjectCommentPayload<ExtArgs>[]
      subproject_comments: Prisma.$SubProjectCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      manager_id: number
      first_name: string
      last_name: string
      email: string
      phone_number: string
      role: $Enums.ManagerRole
      password_hash: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `manager_id`
     * const managerWithManager_idOnly = await prisma.manager.findMany({ select: { manager_id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Managers and returns the data saved in the database.
     * @param {ManagerCreateManyAndReturnArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Managers and only return the `manager_id`
     * const managerWithManager_idOnly = await prisma.manager.createManyAndReturn({ 
     *   select: { manager_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supervisors<T extends Manager$supervisorsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$supervisorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany"> | Null>
    subordinates<T extends Manager$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, Manager$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany"> | Null>
    counterparties<T extends Manager$counterpartiesArgs<ExtArgs> = {}>(args?: Subset<T, Manager$counterpartiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Manager$salesArgs<ExtArgs> = {}>(args?: Subset<T, Manager$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    projects_as_main<T extends Manager$projects_as_mainArgs<ExtArgs> = {}>(args?: Subset<T, Manager$projects_as_mainArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    projects_as_secondary<T extends Manager$projects_as_secondaryArgs<ExtArgs> = {}>(args?: Subset<T, Manager$projects_as_secondaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findMany"> | Null>
    tasks_as_responsible<T extends Manager$tasks_as_responsibleArgs<ExtArgs> = {}>(args?: Subset<T, Manager$tasks_as_responsibleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    tasks_as_creator<T extends Manager$tasks_as_creatorArgs<ExtArgs> = {}>(args?: Subset<T, Manager$tasks_as_creatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    project_comments<T extends Manager$project_commentsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$project_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findMany"> | Null>
    subproject_comments<T extends Manager$subproject_commentsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$subproject_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */ 
  interface ManagerFieldRefs {
    readonly manager_id: FieldRef<"Manager", 'Int'>
    readonly first_name: FieldRef<"Manager", 'String'>
    readonly last_name: FieldRef<"Manager", 'String'>
    readonly email: FieldRef<"Manager", 'String'>
    readonly phone_number: FieldRef<"Manager", 'String'>
    readonly role: FieldRef<"Manager", 'ManagerRole'>
    readonly password_hash: FieldRef<"Manager", 'String'>
    readonly created_at: FieldRef<"Manager", 'DateTime'>
    readonly updated_at: FieldRef<"Manager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager createManyAndReturn
   */
  export type ManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
  }

  /**
   * Manager.supervisors
   */
  export type Manager$supervisorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    cursor?: ManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager.subordinates
   */
  export type Manager$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    cursor?: ManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager.counterparties
   */
  export type Manager$counterpartiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    where?: CounterpartyWhereInput
    orderBy?: CounterpartyOrderByWithRelationInput | CounterpartyOrderByWithRelationInput[]
    cursor?: CounterpartyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounterpartyScalarFieldEnum | CounterpartyScalarFieldEnum[]
  }

  /**
   * Manager.sales
   */
  export type Manager$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Manager.projects_as_main
   */
  export type Manager$projects_as_mainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Manager.projects_as_secondary
   */
  export type Manager$projects_as_secondaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    where?: ProjectManagerWhereInput
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    cursor?: ProjectManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectManagerScalarFieldEnum | ProjectManagerScalarFieldEnum[]
  }

  /**
   * Manager.tasks_as_responsible
   */
  export type Manager$tasks_as_responsibleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Manager.tasks_as_creator
   */
  export type Manager$tasks_as_creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Manager.project_comments
   */
  export type Manager$project_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    where?: ProjectCommentWhereInput
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    cursor?: ProjectCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCommentScalarFieldEnum | ProjectCommentScalarFieldEnum[]
  }

  /**
   * Manager.subproject_comments
   */
  export type Manager$subproject_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    where?: SubProjectCommentWhereInput
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    cursor?: SubProjectCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectCommentScalarFieldEnum | SubProjectCommentScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Counterparty
   */

  export type AggregateCounterparty = {
    _count: CounterpartyCountAggregateOutputType | null
    _avg: CounterpartyAvgAggregateOutputType | null
    _sum: CounterpartySumAggregateOutputType | null
    _min: CounterpartyMinAggregateOutputType | null
    _max: CounterpartyMaxAggregateOutputType | null
  }

  export type CounterpartyAvgAggregateOutputType = {
    counterparty_id: number | null
    responsible_manager_id: number | null
  }

  export type CounterpartySumAggregateOutputType = {
    counterparty_id: number | null
    responsible_manager_id: number | null
  }

  export type CounterpartyMinAggregateOutputType = {
    counterparty_id: number | null
    name: string | null
    counterparty_type: $Enums.CounterpartyType | null
    responsible_manager_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CounterpartyMaxAggregateOutputType = {
    counterparty_id: number | null
    name: string | null
    counterparty_type: $Enums.CounterpartyType | null
    responsible_manager_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CounterpartyCountAggregateOutputType = {
    counterparty_id: number
    name: number
    counterparty_type: number
    responsible_manager_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CounterpartyAvgAggregateInputType = {
    counterparty_id?: true
    responsible_manager_id?: true
  }

  export type CounterpartySumAggregateInputType = {
    counterparty_id?: true
    responsible_manager_id?: true
  }

  export type CounterpartyMinAggregateInputType = {
    counterparty_id?: true
    name?: true
    counterparty_type?: true
    responsible_manager_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CounterpartyMaxAggregateInputType = {
    counterparty_id?: true
    name?: true
    counterparty_type?: true
    responsible_manager_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CounterpartyCountAggregateInputType = {
    counterparty_id?: true
    name?: true
    counterparty_type?: true
    responsible_manager_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CounterpartyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counterparty to aggregate.
     */
    where?: CounterpartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counterparties to fetch.
     */
    orderBy?: CounterpartyOrderByWithRelationInput | CounterpartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CounterpartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counterparties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counterparties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Counterparties
    **/
    _count?: true | CounterpartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounterpartyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounterpartySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounterpartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounterpartyMaxAggregateInputType
  }

  export type GetCounterpartyAggregateType<T extends CounterpartyAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterparty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterparty[P]>
      : GetScalarType<T[P], AggregateCounterparty[P]>
  }




  export type CounterpartyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterpartyWhereInput
    orderBy?: CounterpartyOrderByWithAggregationInput | CounterpartyOrderByWithAggregationInput[]
    by: CounterpartyScalarFieldEnum[] | CounterpartyScalarFieldEnum
    having?: CounterpartyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounterpartyCountAggregateInputType | true
    _avg?: CounterpartyAvgAggregateInputType
    _sum?: CounterpartySumAggregateInputType
    _min?: CounterpartyMinAggregateInputType
    _max?: CounterpartyMaxAggregateInputType
  }

  export type CounterpartyGroupByOutputType = {
    counterparty_id: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    responsible_manager_id: number | null
    created_at: Date
    updated_at: Date
    _count: CounterpartyCountAggregateOutputType | null
    _avg: CounterpartyAvgAggregateOutputType | null
    _sum: CounterpartySumAggregateOutputType | null
    _min: CounterpartyMinAggregateOutputType | null
    _max: CounterpartyMaxAggregateOutputType | null
  }

  type GetCounterpartyGroupByPayload<T extends CounterpartyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounterpartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounterpartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounterpartyGroupByOutputType[P]>
            : GetScalarType<T[P], CounterpartyGroupByOutputType[P]>
        }
      >
    >


  export type CounterpartySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    counterparty_id?: boolean
    name?: boolean
    counterparty_type?: boolean
    responsible_manager_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_manager?: boolean | Counterparty$responsible_managerArgs<ExtArgs>
    sales?: boolean | Counterparty$salesArgs<ExtArgs>
    projects?: boolean | Counterparty$projectsArgs<ExtArgs>
    _count?: boolean | CounterpartyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counterparty"]>

  export type CounterpartySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    counterparty_id?: boolean
    name?: boolean
    counterparty_type?: boolean
    responsible_manager_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_manager?: boolean | Counterparty$responsible_managerArgs<ExtArgs>
  }, ExtArgs["result"]["counterparty"]>

  export type CounterpartySelectScalar = {
    counterparty_id?: boolean
    name?: boolean
    counterparty_type?: boolean
    responsible_manager_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CounterpartyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible_manager?: boolean | Counterparty$responsible_managerArgs<ExtArgs>
    sales?: boolean | Counterparty$salesArgs<ExtArgs>
    projects?: boolean | Counterparty$projectsArgs<ExtArgs>
    _count?: boolean | CounterpartyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CounterpartyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible_manager?: boolean | Counterparty$responsible_managerArgs<ExtArgs>
  }

  export type $CounterpartyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Counterparty"
    objects: {
      responsible_manager: Prisma.$ManagerPayload<ExtArgs> | null
      sales: Prisma.$SalePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      counterparty_id: number
      name: string
      counterparty_type: $Enums.CounterpartyType
      responsible_manager_id: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["counterparty"]>
    composites: {}
  }

  type CounterpartyGetPayload<S extends boolean | null | undefined | CounterpartyDefaultArgs> = $Result.GetResult<Prisma.$CounterpartyPayload, S>

  type CounterpartyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CounterpartyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CounterpartyCountAggregateInputType | true
    }

  export interface CounterpartyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Counterparty'], meta: { name: 'Counterparty' } }
    /**
     * Find zero or one Counterparty that matches the filter.
     * @param {CounterpartyFindUniqueArgs} args - Arguments to find a Counterparty
     * @example
     * // Get one Counterparty
     * const counterparty = await prisma.counterparty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CounterpartyFindUniqueArgs>(args: SelectSubset<T, CounterpartyFindUniqueArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Counterparty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CounterpartyFindUniqueOrThrowArgs} args - Arguments to find a Counterparty
     * @example
     * // Get one Counterparty
     * const counterparty = await prisma.counterparty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CounterpartyFindUniqueOrThrowArgs>(args: SelectSubset<T, CounterpartyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Counterparty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyFindFirstArgs} args - Arguments to find a Counterparty
     * @example
     * // Get one Counterparty
     * const counterparty = await prisma.counterparty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CounterpartyFindFirstArgs>(args?: SelectSubset<T, CounterpartyFindFirstArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Counterparty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyFindFirstOrThrowArgs} args - Arguments to find a Counterparty
     * @example
     * // Get one Counterparty
     * const counterparty = await prisma.counterparty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CounterpartyFindFirstOrThrowArgs>(args?: SelectSubset<T, CounterpartyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Counterparties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counterparties
     * const counterparties = await prisma.counterparty.findMany()
     * 
     * // Get first 10 Counterparties
     * const counterparties = await prisma.counterparty.findMany({ take: 10 })
     * 
     * // Only select the `counterparty_id`
     * const counterpartyWithCounterparty_idOnly = await prisma.counterparty.findMany({ select: { counterparty_id: true } })
     * 
     */
    findMany<T extends CounterpartyFindManyArgs>(args?: SelectSubset<T, CounterpartyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Counterparty.
     * @param {CounterpartyCreateArgs} args - Arguments to create a Counterparty.
     * @example
     * // Create one Counterparty
     * const Counterparty = await prisma.counterparty.create({
     *   data: {
     *     // ... data to create a Counterparty
     *   }
     * })
     * 
     */
    create<T extends CounterpartyCreateArgs>(args: SelectSubset<T, CounterpartyCreateArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Counterparties.
     * @param {CounterpartyCreateManyArgs} args - Arguments to create many Counterparties.
     * @example
     * // Create many Counterparties
     * const counterparty = await prisma.counterparty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CounterpartyCreateManyArgs>(args?: SelectSubset<T, CounterpartyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Counterparties and returns the data saved in the database.
     * @param {CounterpartyCreateManyAndReturnArgs} args - Arguments to create many Counterparties.
     * @example
     * // Create many Counterparties
     * const counterparty = await prisma.counterparty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Counterparties and only return the `counterparty_id`
     * const counterpartyWithCounterparty_idOnly = await prisma.counterparty.createManyAndReturn({ 
     *   select: { counterparty_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CounterpartyCreateManyAndReturnArgs>(args?: SelectSubset<T, CounterpartyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Counterparty.
     * @param {CounterpartyDeleteArgs} args - Arguments to delete one Counterparty.
     * @example
     * // Delete one Counterparty
     * const Counterparty = await prisma.counterparty.delete({
     *   where: {
     *     // ... filter to delete one Counterparty
     *   }
     * })
     * 
     */
    delete<T extends CounterpartyDeleteArgs>(args: SelectSubset<T, CounterpartyDeleteArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Counterparty.
     * @param {CounterpartyUpdateArgs} args - Arguments to update one Counterparty.
     * @example
     * // Update one Counterparty
     * const counterparty = await prisma.counterparty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CounterpartyUpdateArgs>(args: SelectSubset<T, CounterpartyUpdateArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Counterparties.
     * @param {CounterpartyDeleteManyArgs} args - Arguments to filter Counterparties to delete.
     * @example
     * // Delete a few Counterparties
     * const { count } = await prisma.counterparty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CounterpartyDeleteManyArgs>(args?: SelectSubset<T, CounterpartyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counterparties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counterparties
     * const counterparty = await prisma.counterparty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CounterpartyUpdateManyArgs>(args: SelectSubset<T, CounterpartyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counterparty.
     * @param {CounterpartyUpsertArgs} args - Arguments to update or create a Counterparty.
     * @example
     * // Update or create a Counterparty
     * const counterparty = await prisma.counterparty.upsert({
     *   create: {
     *     // ... data to create a Counterparty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counterparty we want to update
     *   }
     * })
     */
    upsert<T extends CounterpartyUpsertArgs>(args: SelectSubset<T, CounterpartyUpsertArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Counterparties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyCountArgs} args - Arguments to filter Counterparties to count.
     * @example
     * // Count the number of Counterparties
     * const count = await prisma.counterparty.count({
     *   where: {
     *     // ... the filter for the Counterparties we want to count
     *   }
     * })
    **/
    count<T extends CounterpartyCountArgs>(
      args?: Subset<T, CounterpartyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounterpartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counterparty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounterpartyAggregateArgs>(args: Subset<T, CounterpartyAggregateArgs>): Prisma.PrismaPromise<GetCounterpartyAggregateType<T>>

    /**
     * Group by Counterparty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterpartyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CounterpartyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CounterpartyGroupByArgs['orderBy'] }
        : { orderBy?: CounterpartyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CounterpartyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterpartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Counterparty model
   */
  readonly fields: CounterpartyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Counterparty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CounterpartyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsible_manager<T extends Counterparty$responsible_managerArgs<ExtArgs> = {}>(args?: Subset<T, Counterparty$responsible_managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sales<T extends Counterparty$salesArgs<ExtArgs> = {}>(args?: Subset<T, Counterparty$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Counterparty$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Counterparty$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Counterparty model
   */ 
  interface CounterpartyFieldRefs {
    readonly counterparty_id: FieldRef<"Counterparty", 'Int'>
    readonly name: FieldRef<"Counterparty", 'String'>
    readonly counterparty_type: FieldRef<"Counterparty", 'CounterpartyType'>
    readonly responsible_manager_id: FieldRef<"Counterparty", 'Int'>
    readonly created_at: FieldRef<"Counterparty", 'DateTime'>
    readonly updated_at: FieldRef<"Counterparty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Counterparty findUnique
   */
  export type CounterpartyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter, which Counterparty to fetch.
     */
    where: CounterpartyWhereUniqueInput
  }

  /**
   * Counterparty findUniqueOrThrow
   */
  export type CounterpartyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter, which Counterparty to fetch.
     */
    where: CounterpartyWhereUniqueInput
  }

  /**
   * Counterparty findFirst
   */
  export type CounterpartyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter, which Counterparty to fetch.
     */
    where?: CounterpartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counterparties to fetch.
     */
    orderBy?: CounterpartyOrderByWithRelationInput | CounterpartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counterparties.
     */
    cursor?: CounterpartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counterparties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counterparties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counterparties.
     */
    distinct?: CounterpartyScalarFieldEnum | CounterpartyScalarFieldEnum[]
  }

  /**
   * Counterparty findFirstOrThrow
   */
  export type CounterpartyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter, which Counterparty to fetch.
     */
    where?: CounterpartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counterparties to fetch.
     */
    orderBy?: CounterpartyOrderByWithRelationInput | CounterpartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Counterparties.
     */
    cursor?: CounterpartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counterparties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counterparties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Counterparties.
     */
    distinct?: CounterpartyScalarFieldEnum | CounterpartyScalarFieldEnum[]
  }

  /**
   * Counterparty findMany
   */
  export type CounterpartyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter, which Counterparties to fetch.
     */
    where?: CounterpartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Counterparties to fetch.
     */
    orderBy?: CounterpartyOrderByWithRelationInput | CounterpartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Counterparties.
     */
    cursor?: CounterpartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Counterparties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Counterparties.
     */
    skip?: number
    distinct?: CounterpartyScalarFieldEnum | CounterpartyScalarFieldEnum[]
  }

  /**
   * Counterparty create
   */
  export type CounterpartyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * The data needed to create a Counterparty.
     */
    data: XOR<CounterpartyCreateInput, CounterpartyUncheckedCreateInput>
  }

  /**
   * Counterparty createMany
   */
  export type CounterpartyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Counterparties.
     */
    data: CounterpartyCreateManyInput | CounterpartyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Counterparty createManyAndReturn
   */
  export type CounterpartyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Counterparties.
     */
    data: CounterpartyCreateManyInput | CounterpartyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Counterparty update
   */
  export type CounterpartyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * The data needed to update a Counterparty.
     */
    data: XOR<CounterpartyUpdateInput, CounterpartyUncheckedUpdateInput>
    /**
     * Choose, which Counterparty to update.
     */
    where: CounterpartyWhereUniqueInput
  }

  /**
   * Counterparty updateMany
   */
  export type CounterpartyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Counterparties.
     */
    data: XOR<CounterpartyUpdateManyMutationInput, CounterpartyUncheckedUpdateManyInput>
    /**
     * Filter which Counterparties to update
     */
    where?: CounterpartyWhereInput
  }

  /**
   * Counterparty upsert
   */
  export type CounterpartyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * The filter to search for the Counterparty to update in case it exists.
     */
    where: CounterpartyWhereUniqueInput
    /**
     * In case the Counterparty found by the `where` argument doesn't exist, create a new Counterparty with this data.
     */
    create: XOR<CounterpartyCreateInput, CounterpartyUncheckedCreateInput>
    /**
     * In case the Counterparty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CounterpartyUpdateInput, CounterpartyUncheckedUpdateInput>
  }

  /**
   * Counterparty delete
   */
  export type CounterpartyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    /**
     * Filter which Counterparty to delete.
     */
    where: CounterpartyWhereUniqueInput
  }

  /**
   * Counterparty deleteMany
   */
  export type CounterpartyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Counterparties to delete
     */
    where?: CounterpartyWhereInput
  }

  /**
   * Counterparty.responsible_manager
   */
  export type Counterparty$responsible_managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Counterparty.sales
   */
  export type Counterparty$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Counterparty.projects
   */
  export type Counterparty$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Counterparty without action
   */
  export type CounterpartyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    unit_id: number | null
  }

  export type UnitSumAggregateOutputType = {
    unit_id: number | null
  }

  export type UnitMinAggregateOutputType = {
    unit_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    unit_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type UnitCountAggregateOutputType = {
    unit_id: number
    name: number
    created_at: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    unit_id?: true
  }

  export type UnitSumAggregateInputType = {
    unit_id?: true
  }

  export type UnitMinAggregateInputType = {
    unit_id?: true
    name?: true
    created_at?: true
  }

  export type UnitMaxAggregateInputType = {
    unit_id?: true
    name?: true
    created_at?: true
  }

  export type UnitCountAggregateInputType = {
    unit_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    unit_id: number
    name: string
    created_at: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    unit_id?: boolean
    name?: boolean
    created_at?: boolean
    products?: boolean | Unit$productsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    unit_id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    unit_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Unit$productsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      unit_id: number
      name: string
      created_at: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `unit_id`
     * const unitWithUnit_idOnly = await prisma.unit.findMany({ select: { unit_id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `unit_id`
     * const unitWithUnit_idOnly = await prisma.unit.createManyAndReturn({ 
     *   select: { unit_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Unit$productsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly unit_id: FieldRef<"Unit", 'Int'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly created_at: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }

  /**
   * Unit.products
   */
  export type Unit$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    warehouse_id: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    warehouse_id: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    warehouse_id: number | null
    name: string | null
    location: string | null
    created_at: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    warehouse_id: number | null
    name: string | null
    location: string | null
    created_at: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    warehouse_id: number
    name: number
    location: number
    created_at: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    warehouse_id?: true
  }

  export type WarehouseSumAggregateInputType = {
    warehouse_id?: true
  }

  export type WarehouseMinAggregateInputType = {
    warehouse_id?: true
    name?: true
    location?: true
    created_at?: true
  }

  export type WarehouseMaxAggregateInputType = {
    warehouse_id?: true
    name?: true
    location?: true
    created_at?: true
  }

  export type WarehouseCountAggregateInputType = {
    warehouse_id?: true
    name?: true
    location?: true
    created_at?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    warehouse_id: number
    name: string
    location: string
    created_at: Date
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    warehouse_id?: boolean
    name?: boolean
    location?: boolean
    created_at?: boolean
    product_stocks?: boolean | Warehouse$product_stocksArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    warehouse_id?: boolean
    name?: boolean
    location?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    warehouse_id?: boolean
    name?: boolean
    location?: boolean
    created_at?: boolean
  }

  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_stocks?: boolean | Warehouse$product_stocksArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      product_stocks: Prisma.$ProductStockPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      warehouse_id: number
      name: string
      location: string
      created_at: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `warehouse_id`
     * const warehouseWithWarehouse_idOnly = await prisma.warehouse.findMany({ select: { warehouse_id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `warehouse_id`
     * const warehouseWithWarehouse_idOnly = await prisma.warehouse.createManyAndReturn({ 
     *   select: { warehouse_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product_stocks<T extends Warehouse$product_stocksArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$product_stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */ 
  interface WarehouseFieldRefs {
    readonly warehouse_id: FieldRef<"Warehouse", 'Int'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly location: FieldRef<"Warehouse", 'String'>
    readonly created_at: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse.product_stocks
   */
  export type Warehouse$product_stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    cursor?: ProductStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    product_id: number | null
    price: Decimal | null
    unit_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    product_id: number | null
    price: Decimal | null
    unit_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    product_id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    unit_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    product_id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    unit_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    product_id: number
    name: number
    description: number
    price: number
    unit_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    product_id?: true
    price?: true
    unit_id?: true
  }

  export type ProductSumAggregateInputType = {
    product_id?: true
    price?: true
    unit_id?: true
  }

  export type ProductMinAggregateInputType = {
    product_id?: true
    name?: true
    description?: true
    price?: true
    unit_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductMaxAggregateInputType = {
    product_id?: true
    name?: true
    description?: true
    price?: true
    unit_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCountAggregateInputType = {
    product_id?: true
    name?: true
    description?: true
    price?: true
    unit_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    product_id: number
    name: string
    description: string | null
    price: Decimal
    unit_id: number | null
    created_at: Date
    updated_at: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    unit_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | Product$unitArgs<ExtArgs>
    stocks?: boolean | Product$stocksArgs<ExtArgs>
    sales?: boolean | Product$salesArgs<ExtArgs>
    project_products?: boolean | Product$project_productsArgs<ExtArgs>
    subproject_products?: boolean | Product$subproject_productsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    unit_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | Product$unitArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    product_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    unit_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Product$unitArgs<ExtArgs>
    stocks?: boolean | Product$stocksArgs<ExtArgs>
    sales?: boolean | Product$salesArgs<ExtArgs>
    project_products?: boolean | Product$project_productsArgs<ExtArgs>
    subproject_products?: boolean | Product$subproject_productsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | Product$unitArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs> | null
      stocks: Prisma.$ProductStockPayload<ExtArgs>[]
      sales: Prisma.$SaleProductPayload<ExtArgs>[]
      project_products: Prisma.$ProjectProductPayload<ExtArgs>[]
      subproject_products: Prisma.$SubProjectProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      product_id: number
      name: string
      description: string | null
      price: Prisma.Decimal
      unit_id: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `product_id`
     * const productWithProduct_idOnly = await prisma.product.findMany({ select: { product_id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `product_id`
     * const productWithProduct_idOnly = await prisma.product.createManyAndReturn({ 
     *   select: { product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends Product$unitArgs<ExtArgs> = {}>(args?: Subset<T, Product$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stocks<T extends Product$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Product$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Product$salesArgs<ExtArgs> = {}>(args?: Subset<T, Product$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany"> | Null>
    project_products<T extends Product$project_productsArgs<ExtArgs> = {}>(args?: Subset<T, Product$project_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findMany"> | Null>
    subproject_products<T extends Product$subproject_productsArgs<ExtArgs> = {}>(args?: Subset<T, Product$subproject_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly product_id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly unit_id: FieldRef<"Product", 'Int'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly updated_at: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.unit
   */
  export type Product$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Product.stocks
   */
  export type Product$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    cursor?: ProductStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * Product.sales
   */
  export type Product$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Product.project_products
   */
  export type Product$project_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    where?: ProjectProductWhereInput
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    cursor?: ProjectProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectProductScalarFieldEnum | ProjectProductScalarFieldEnum[]
  }

  /**
   * Product.subproject_products
   */
  export type Product$subproject_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    where?: SubProjectProductWhereInput
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    cursor?: SubProjectProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectProductScalarFieldEnum | SubProjectProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductStock
   */

  export type AggregateProductStock = {
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  export type ProductStockAvgAggregateOutputType = {
    product_stock_id: number | null
    product_id: number | null
    warehouse_id: number | null
    quantity: number | null
  }

  export type ProductStockSumAggregateOutputType = {
    product_stock_id: number | null
    product_id: number | null
    warehouse_id: number | null
    quantity: number | null
  }

  export type ProductStockMinAggregateOutputType = {
    product_stock_id: number | null
    product_id: number | null
    warehouse_id: number | null
    quantity: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductStockMaxAggregateOutputType = {
    product_stock_id: number | null
    product_id: number | null
    warehouse_id: number | null
    quantity: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductStockCountAggregateOutputType = {
    product_stock_id: number
    product_id: number
    warehouse_id: number
    quantity: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductStockAvgAggregateInputType = {
    product_stock_id?: true
    product_id?: true
    warehouse_id?: true
    quantity?: true
  }

  export type ProductStockSumAggregateInputType = {
    product_stock_id?: true
    product_id?: true
    warehouse_id?: true
    quantity?: true
  }

  export type ProductStockMinAggregateInputType = {
    product_stock_id?: true
    product_id?: true
    warehouse_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductStockMaxAggregateInputType = {
    product_stock_id?: true
    product_id?: true
    warehouse_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductStockCountAggregateInputType = {
    product_stock_id?: true
    product_id?: true
    warehouse_id?: true
    quantity?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStock to aggregate.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStocks
    **/
    _count?: true | ProductStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStockMaxAggregateInputType
  }

  export type GetProductStockAggregateType<T extends ProductStockAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStock[P]>
      : GetScalarType<T[P], AggregateProductStock[P]>
  }




  export type ProductStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStockWhereInput
    orderBy?: ProductStockOrderByWithAggregationInput | ProductStockOrderByWithAggregationInput[]
    by: ProductStockScalarFieldEnum[] | ProductStockScalarFieldEnum
    having?: ProductStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStockCountAggregateInputType | true
    _avg?: ProductStockAvgAggregateInputType
    _sum?: ProductStockSumAggregateInputType
    _min?: ProductStockMinAggregateInputType
    _max?: ProductStockMaxAggregateInputType
  }

  export type ProductStockGroupByOutputType = {
    product_stock_id: number
    product_id: number
    warehouse_id: number
    quantity: number
    created_at: Date
    updated_at: Date
    _count: ProductStockCountAggregateOutputType | null
    _avg: ProductStockAvgAggregateOutputType | null
    _sum: ProductStockSumAggregateOutputType | null
    _min: ProductStockMinAggregateOutputType | null
    _max: ProductStockMaxAggregateOutputType | null
  }

  type GetProductStockGroupByPayload<T extends ProductStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStockGroupByOutputType[P]>
        }
      >
    >


  export type ProductStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_stock_id?: boolean
    product_id?: boolean
    warehouse_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_stock_id?: boolean
    product_id?: boolean
    warehouse_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStock"]>

  export type ProductStockSelectScalar = {
    product_stock_id?: boolean
    product_id?: boolean
    warehouse_id?: boolean
    quantity?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type ProductStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $ProductStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStock"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      product_stock_id: number
      product_id: number
      warehouse_id: number
      quantity: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productStock"]>
    composites: {}
  }

  type ProductStockGetPayload<S extends boolean | null | undefined | ProductStockDefaultArgs> = $Result.GetResult<Prisma.$ProductStockPayload, S>

  type ProductStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductStockFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductStockCountAggregateInputType | true
    }

  export interface ProductStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStock'], meta: { name: 'ProductStock' } }
    /**
     * Find zero or one ProductStock that matches the filter.
     * @param {ProductStockFindUniqueArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStockFindUniqueArgs>(args: SelectSubset<T, ProductStockFindUniqueArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductStock that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductStockFindUniqueOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStockFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStockFindFirstArgs>(args?: SelectSubset<T, ProductStockFindFirstArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindFirstOrThrowArgs} args - Arguments to find a ProductStock
     * @example
     * // Get one ProductStock
     * const productStock = await prisma.productStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStockFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStocks
     * const productStocks = await prisma.productStock.findMany()
     * 
     * // Get first 10 ProductStocks
     * const productStocks = await prisma.productStock.findMany({ take: 10 })
     * 
     * // Only select the `product_stock_id`
     * const productStockWithProduct_stock_idOnly = await prisma.productStock.findMany({ select: { product_stock_id: true } })
     * 
     */
    findMany<T extends ProductStockFindManyArgs>(args?: SelectSubset<T, ProductStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductStock.
     * @param {ProductStockCreateArgs} args - Arguments to create a ProductStock.
     * @example
     * // Create one ProductStock
     * const ProductStock = await prisma.productStock.create({
     *   data: {
     *     // ... data to create a ProductStock
     *   }
     * })
     * 
     */
    create<T extends ProductStockCreateArgs>(args: SelectSubset<T, ProductStockCreateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductStocks.
     * @param {ProductStockCreateManyArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStockCreateManyArgs>(args?: SelectSubset<T, ProductStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductStocks and returns the data saved in the database.
     * @param {ProductStockCreateManyAndReturnArgs} args - Arguments to create many ProductStocks.
     * @example
     * // Create many ProductStocks
     * const productStock = await prisma.productStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductStocks and only return the `product_stock_id`
     * const productStockWithProduct_stock_idOnly = await prisma.productStock.createManyAndReturn({ 
     *   select: { product_stock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductStockCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductStock.
     * @param {ProductStockDeleteArgs} args - Arguments to delete one ProductStock.
     * @example
     * // Delete one ProductStock
     * const ProductStock = await prisma.productStock.delete({
     *   where: {
     *     // ... filter to delete one ProductStock
     *   }
     * })
     * 
     */
    delete<T extends ProductStockDeleteArgs>(args: SelectSubset<T, ProductStockDeleteArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductStock.
     * @param {ProductStockUpdateArgs} args - Arguments to update one ProductStock.
     * @example
     * // Update one ProductStock
     * const productStock = await prisma.productStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStockUpdateArgs>(args: SelectSubset<T, ProductStockUpdateArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductStocks.
     * @param {ProductStockDeleteManyArgs} args - Arguments to filter ProductStocks to delete.
     * @example
     * // Delete a few ProductStocks
     * const { count } = await prisma.productStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStockDeleteManyArgs>(args?: SelectSubset<T, ProductStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStocks
     * const productStock = await prisma.productStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStockUpdateManyArgs>(args: SelectSubset<T, ProductStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductStock.
     * @param {ProductStockUpsertArgs} args - Arguments to update or create a ProductStock.
     * @example
     * // Update or create a ProductStock
     * const productStock = await prisma.productStock.upsert({
     *   create: {
     *     // ... data to create a ProductStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStock we want to update
     *   }
     * })
     */
    upsert<T extends ProductStockUpsertArgs>(args: SelectSubset<T, ProductStockUpsertArgs<ExtArgs>>): Prisma__ProductStockClient<$Result.GetResult<Prisma.$ProductStockPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockCountArgs} args - Arguments to filter ProductStocks to count.
     * @example
     * // Count the number of ProductStocks
     * const count = await prisma.productStock.count({
     *   where: {
     *     // ... the filter for the ProductStocks we want to count
     *   }
     * })
    **/
    count<T extends ProductStockCountArgs>(
      args?: Subset<T, ProductStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStockAggregateArgs>(args: Subset<T, ProductStockAggregateArgs>): Prisma.PrismaPromise<GetProductStockAggregateType<T>>

    /**
     * Group by ProductStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStockGroupByArgs['orderBy'] }
        : { orderBy?: ProductStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStock model
   */
  readonly fields: ProductStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStock model
   */ 
  interface ProductStockFieldRefs {
    readonly product_stock_id: FieldRef<"ProductStock", 'Int'>
    readonly product_id: FieldRef<"ProductStock", 'Int'>
    readonly warehouse_id: FieldRef<"ProductStock", 'Int'>
    readonly quantity: FieldRef<"ProductStock", 'Int'>
    readonly created_at: FieldRef<"ProductStock", 'DateTime'>
    readonly updated_at: FieldRef<"ProductStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductStock findUnique
   */
  export type ProductStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findUniqueOrThrow
   */
  export type ProductStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock findFirst
   */
  export type ProductStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findFirstOrThrow
   */
  export type ProductStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStock to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStocks.
     */
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock findMany
   */
  export type ProductStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter, which ProductStocks to fetch.
     */
    where?: ProductStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStocks to fetch.
     */
    orderBy?: ProductStockOrderByWithRelationInput | ProductStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStocks.
     */
    cursor?: ProductStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStocks.
     */
    skip?: number
    distinct?: ProductStockScalarFieldEnum | ProductStockScalarFieldEnum[]
  }

  /**
   * ProductStock create
   */
  export type ProductStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStock.
     */
    data: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
  }

  /**
   * ProductStock createMany
   */
  export type ProductStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStock createManyAndReturn
   */
  export type ProductStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductStocks.
     */
    data: ProductStockCreateManyInput | ProductStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductStock update
   */
  export type ProductStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStock.
     */
    data: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
    /**
     * Choose, which ProductStock to update.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock updateMany
   */
  export type ProductStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStocks.
     */
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyInput>
    /**
     * Filter which ProductStocks to update
     */
    where?: ProductStockWhereInput
  }

  /**
   * ProductStock upsert
   */
  export type ProductStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStock to update in case it exists.
     */
    where: ProductStockWhereUniqueInput
    /**
     * In case the ProductStock found by the `where` argument doesn't exist, create a new ProductStock with this data.
     */
    create: XOR<ProductStockCreateInput, ProductStockUncheckedCreateInput>
    /**
     * In case the ProductStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStockUpdateInput, ProductStockUncheckedUpdateInput>
  }

  /**
   * ProductStock delete
   */
  export type ProductStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
    /**
     * Filter which ProductStock to delete.
     */
    where: ProductStockWhereUniqueInput
  }

  /**
   * ProductStock deleteMany
   */
  export type ProductStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStocks to delete
     */
    where?: ProductStockWhereInput
  }

  /**
   * ProductStock without action
   */
  export type ProductStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStock
     */
    select?: ProductStockSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStockInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    service_id: number | null
    price: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    service_id: number | null
    price: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    service_id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    service_id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    service_id: number
    name: number
    description: number
    price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    service_id?: true
    price?: true
  }

  export type ServiceSumAggregateInputType = {
    service_id?: true
    price?: true
  }

  export type ServiceMinAggregateInputType = {
    service_id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceMaxAggregateInputType = {
    service_id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceCountAggregateInputType = {
    service_id?: true
    name?: true
    description?: true
    price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    service_id: number
    name: string
    description: string | null
    price: Decimal
    created_at: Date
    updated_at: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    service_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    sales?: boolean | Service$salesArgs<ExtArgs>
    project_services?: boolean | Service$project_servicesArgs<ExtArgs>
    subproject_services?: boolean | Service$subproject_servicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    service_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    service_id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | Service$salesArgs<ExtArgs>
    project_services?: boolean | Service$project_servicesArgs<ExtArgs>
    subproject_services?: boolean | Service$subproject_servicesArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      sales: Prisma.$SaleServicePayload<ExtArgs>[]
      project_services: Prisma.$ProjectServicePayload<ExtArgs>[]
      subproject_services: Prisma.$SubProjectServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      service_id: number
      name: string
      description: string | null
      price: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `service_id`
     * const serviceWithService_idOnly = await prisma.service.findMany({ select: { service_id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `service_id`
     * const serviceWithService_idOnly = await prisma.service.createManyAndReturn({ 
     *   select: { service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales<T extends Service$salesArgs<ExtArgs> = {}>(args?: Subset<T, Service$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany"> | Null>
    project_services<T extends Service$project_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$project_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findMany"> | Null>
    subproject_services<T extends Service$subproject_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$subproject_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly service_id: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Decimal'>
    readonly created_at: FieldRef<"Service", 'DateTime'>
    readonly updated_at: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }

  /**
   * Service.sales
   */
  export type Service$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    cursor?: SaleServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * Service.project_services
   */
  export type Service$project_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    where?: ProjectServiceWhereInput
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    cursor?: ProjectServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectServiceScalarFieldEnum | ProjectServiceScalarFieldEnum[]
  }

  /**
   * Service.subproject_services
   */
  export type Service$subproject_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    where?: SubProjectServiceWhereInput
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    cursor?: SubProjectServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectServiceScalarFieldEnum | SubProjectServiceScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model SaleStatusType
   */

  export type AggregateSaleStatusType = {
    _count: SaleStatusTypeCountAggregateOutputType | null
    _avg: SaleStatusTypeAvgAggregateOutputType | null
    _sum: SaleStatusTypeSumAggregateOutputType | null
    _min: SaleStatusTypeMinAggregateOutputType | null
    _max: SaleStatusTypeMaxAggregateOutputType | null
  }

  export type SaleStatusTypeAvgAggregateOutputType = {
    sale_status_id: number | null
  }

  export type SaleStatusTypeSumAggregateOutputType = {
    sale_status_id: number | null
  }

  export type SaleStatusTypeMinAggregateOutputType = {
    sale_status_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SaleStatusTypeMaxAggregateOutputType = {
    sale_status_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SaleStatusTypeCountAggregateOutputType = {
    sale_status_id: number
    name: number
    created_at: number
    _all: number
  }


  export type SaleStatusTypeAvgAggregateInputType = {
    sale_status_id?: true
  }

  export type SaleStatusTypeSumAggregateInputType = {
    sale_status_id?: true
  }

  export type SaleStatusTypeMinAggregateInputType = {
    sale_status_id?: true
    name?: true
    created_at?: true
  }

  export type SaleStatusTypeMaxAggregateInputType = {
    sale_status_id?: true
    name?: true
    created_at?: true
  }

  export type SaleStatusTypeCountAggregateInputType = {
    sale_status_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type SaleStatusTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleStatusType to aggregate.
     */
    where?: SaleStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStatusTypes to fetch.
     */
    orderBy?: SaleStatusTypeOrderByWithRelationInput | SaleStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleStatusTypes
    **/
    _count?: true | SaleStatusTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleStatusTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleStatusTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleStatusTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleStatusTypeMaxAggregateInputType
  }

  export type GetSaleStatusTypeAggregateType<T extends SaleStatusTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleStatusType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleStatusType[P]>
      : GetScalarType<T[P], AggregateSaleStatusType[P]>
  }




  export type SaleStatusTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleStatusTypeWhereInput
    orderBy?: SaleStatusTypeOrderByWithAggregationInput | SaleStatusTypeOrderByWithAggregationInput[]
    by: SaleStatusTypeScalarFieldEnum[] | SaleStatusTypeScalarFieldEnum
    having?: SaleStatusTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleStatusTypeCountAggregateInputType | true
    _avg?: SaleStatusTypeAvgAggregateInputType
    _sum?: SaleStatusTypeSumAggregateInputType
    _min?: SaleStatusTypeMinAggregateInputType
    _max?: SaleStatusTypeMaxAggregateInputType
  }

  export type SaleStatusTypeGroupByOutputType = {
    sale_status_id: number
    name: string
    created_at: Date
    _count: SaleStatusTypeCountAggregateOutputType | null
    _avg: SaleStatusTypeAvgAggregateOutputType | null
    _sum: SaleStatusTypeSumAggregateOutputType | null
    _min: SaleStatusTypeMinAggregateOutputType | null
    _max: SaleStatusTypeMaxAggregateOutputType | null
  }

  type GetSaleStatusTypeGroupByPayload<T extends SaleStatusTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleStatusTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleStatusTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleStatusTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SaleStatusTypeGroupByOutputType[P]>
        }
      >
    >


  export type SaleStatusTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_status_id?: boolean
    name?: boolean
    created_at?: boolean
    sales?: boolean | SaleStatusType$salesArgs<ExtArgs>
    _count?: boolean | SaleStatusTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleStatusType"]>

  export type SaleStatusTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_status_id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["saleStatusType"]>

  export type SaleStatusTypeSelectScalar = {
    sale_status_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type SaleStatusTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | SaleStatusType$salesArgs<ExtArgs>
    _count?: boolean | SaleStatusTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleStatusTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SaleStatusTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleStatusType"
    objects: {
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      sale_status_id: number
      name: string
      created_at: Date
    }, ExtArgs["result"]["saleStatusType"]>
    composites: {}
  }

  type SaleStatusTypeGetPayload<S extends boolean | null | undefined | SaleStatusTypeDefaultArgs> = $Result.GetResult<Prisma.$SaleStatusTypePayload, S>

  type SaleStatusTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleStatusTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleStatusTypeCountAggregateInputType | true
    }

  export interface SaleStatusTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleStatusType'], meta: { name: 'SaleStatusType' } }
    /**
     * Find zero or one SaleStatusType that matches the filter.
     * @param {SaleStatusTypeFindUniqueArgs} args - Arguments to find a SaleStatusType
     * @example
     * // Get one SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleStatusTypeFindUniqueArgs>(args: SelectSubset<T, SaleStatusTypeFindUniqueArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleStatusType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleStatusTypeFindUniqueOrThrowArgs} args - Arguments to find a SaleStatusType
     * @example
     * // Get one SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleStatusTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleStatusTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleStatusType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeFindFirstArgs} args - Arguments to find a SaleStatusType
     * @example
     * // Get one SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleStatusTypeFindFirstArgs>(args?: SelectSubset<T, SaleStatusTypeFindFirstArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleStatusType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeFindFirstOrThrowArgs} args - Arguments to find a SaleStatusType
     * @example
     * // Get one SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleStatusTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleStatusTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleStatusTypes
     * const saleStatusTypes = await prisma.saleStatusType.findMany()
     * 
     * // Get first 10 SaleStatusTypes
     * const saleStatusTypes = await prisma.saleStatusType.findMany({ take: 10 })
     * 
     * // Only select the `sale_status_id`
     * const saleStatusTypeWithSale_status_idOnly = await prisma.saleStatusType.findMany({ select: { sale_status_id: true } })
     * 
     */
    findMany<T extends SaleStatusTypeFindManyArgs>(args?: SelectSubset<T, SaleStatusTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleStatusType.
     * @param {SaleStatusTypeCreateArgs} args - Arguments to create a SaleStatusType.
     * @example
     * // Create one SaleStatusType
     * const SaleStatusType = await prisma.saleStatusType.create({
     *   data: {
     *     // ... data to create a SaleStatusType
     *   }
     * })
     * 
     */
    create<T extends SaleStatusTypeCreateArgs>(args: SelectSubset<T, SaleStatusTypeCreateArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleStatusTypes.
     * @param {SaleStatusTypeCreateManyArgs} args - Arguments to create many SaleStatusTypes.
     * @example
     * // Create many SaleStatusTypes
     * const saleStatusType = await prisma.saleStatusType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleStatusTypeCreateManyArgs>(args?: SelectSubset<T, SaleStatusTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleStatusTypes and returns the data saved in the database.
     * @param {SaleStatusTypeCreateManyAndReturnArgs} args - Arguments to create many SaleStatusTypes.
     * @example
     * // Create many SaleStatusTypes
     * const saleStatusType = await prisma.saleStatusType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleStatusTypes and only return the `sale_status_id`
     * const saleStatusTypeWithSale_status_idOnly = await prisma.saleStatusType.createManyAndReturn({ 
     *   select: { sale_status_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleStatusTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleStatusTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleStatusType.
     * @param {SaleStatusTypeDeleteArgs} args - Arguments to delete one SaleStatusType.
     * @example
     * // Delete one SaleStatusType
     * const SaleStatusType = await prisma.saleStatusType.delete({
     *   where: {
     *     // ... filter to delete one SaleStatusType
     *   }
     * })
     * 
     */
    delete<T extends SaleStatusTypeDeleteArgs>(args: SelectSubset<T, SaleStatusTypeDeleteArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleStatusType.
     * @param {SaleStatusTypeUpdateArgs} args - Arguments to update one SaleStatusType.
     * @example
     * // Update one SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleStatusTypeUpdateArgs>(args: SelectSubset<T, SaleStatusTypeUpdateArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleStatusTypes.
     * @param {SaleStatusTypeDeleteManyArgs} args - Arguments to filter SaleStatusTypes to delete.
     * @example
     * // Delete a few SaleStatusTypes
     * const { count } = await prisma.saleStatusType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleStatusTypeDeleteManyArgs>(args?: SelectSubset<T, SaleStatusTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleStatusTypes
     * const saleStatusType = await prisma.saleStatusType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleStatusTypeUpdateManyArgs>(args: SelectSubset<T, SaleStatusTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleStatusType.
     * @param {SaleStatusTypeUpsertArgs} args - Arguments to update or create a SaleStatusType.
     * @example
     * // Update or create a SaleStatusType
     * const saleStatusType = await prisma.saleStatusType.upsert({
     *   create: {
     *     // ... data to create a SaleStatusType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleStatusType we want to update
     *   }
     * })
     */
    upsert<T extends SaleStatusTypeUpsertArgs>(args: SelectSubset<T, SaleStatusTypeUpsertArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeCountArgs} args - Arguments to filter SaleStatusTypes to count.
     * @example
     * // Count the number of SaleStatusTypes
     * const count = await prisma.saleStatusType.count({
     *   where: {
     *     // ... the filter for the SaleStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends SaleStatusTypeCountArgs>(
      args?: Subset<T, SaleStatusTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleStatusTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleStatusTypeAggregateArgs>(args: Subset<T, SaleStatusTypeAggregateArgs>): Prisma.PrismaPromise<GetSaleStatusTypeAggregateType<T>>

    /**
     * Group by SaleStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleStatusTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleStatusTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleStatusTypeGroupByArgs['orderBy'] }
        : { orderBy?: SaleStatusTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleStatusTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleStatusTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleStatusType model
   */
  readonly fields: SaleStatusTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleStatusType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleStatusTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales<T extends SaleStatusType$salesArgs<ExtArgs> = {}>(args?: Subset<T, SaleStatusType$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleStatusType model
   */ 
  interface SaleStatusTypeFieldRefs {
    readonly sale_status_id: FieldRef<"SaleStatusType", 'Int'>
    readonly name: FieldRef<"SaleStatusType", 'String'>
    readonly created_at: FieldRef<"SaleStatusType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleStatusType findUnique
   */
  export type SaleStatusTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter, which SaleStatusType to fetch.
     */
    where: SaleStatusTypeWhereUniqueInput
  }

  /**
   * SaleStatusType findUniqueOrThrow
   */
  export type SaleStatusTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter, which SaleStatusType to fetch.
     */
    where: SaleStatusTypeWhereUniqueInput
  }

  /**
   * SaleStatusType findFirst
   */
  export type SaleStatusTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter, which SaleStatusType to fetch.
     */
    where?: SaleStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStatusTypes to fetch.
     */
    orderBy?: SaleStatusTypeOrderByWithRelationInput | SaleStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleStatusTypes.
     */
    cursor?: SaleStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleStatusTypes.
     */
    distinct?: SaleStatusTypeScalarFieldEnum | SaleStatusTypeScalarFieldEnum[]
  }

  /**
   * SaleStatusType findFirstOrThrow
   */
  export type SaleStatusTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter, which SaleStatusType to fetch.
     */
    where?: SaleStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStatusTypes to fetch.
     */
    orderBy?: SaleStatusTypeOrderByWithRelationInput | SaleStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleStatusTypes.
     */
    cursor?: SaleStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleStatusTypes.
     */
    distinct?: SaleStatusTypeScalarFieldEnum | SaleStatusTypeScalarFieldEnum[]
  }

  /**
   * SaleStatusType findMany
   */
  export type SaleStatusTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter, which SaleStatusTypes to fetch.
     */
    where?: SaleStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleStatusTypes to fetch.
     */
    orderBy?: SaleStatusTypeOrderByWithRelationInput | SaleStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleStatusTypes.
     */
    cursor?: SaleStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleStatusTypes.
     */
    skip?: number
    distinct?: SaleStatusTypeScalarFieldEnum | SaleStatusTypeScalarFieldEnum[]
  }

  /**
   * SaleStatusType create
   */
  export type SaleStatusTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleStatusType.
     */
    data: XOR<SaleStatusTypeCreateInput, SaleStatusTypeUncheckedCreateInput>
  }

  /**
   * SaleStatusType createMany
   */
  export type SaleStatusTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleStatusTypes.
     */
    data: SaleStatusTypeCreateManyInput | SaleStatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleStatusType createManyAndReturn
   */
  export type SaleStatusTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleStatusTypes.
     */
    data: SaleStatusTypeCreateManyInput | SaleStatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleStatusType update
   */
  export type SaleStatusTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleStatusType.
     */
    data: XOR<SaleStatusTypeUpdateInput, SaleStatusTypeUncheckedUpdateInput>
    /**
     * Choose, which SaleStatusType to update.
     */
    where: SaleStatusTypeWhereUniqueInput
  }

  /**
   * SaleStatusType updateMany
   */
  export type SaleStatusTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleStatusTypes.
     */
    data: XOR<SaleStatusTypeUpdateManyMutationInput, SaleStatusTypeUncheckedUpdateManyInput>
    /**
     * Filter which SaleStatusTypes to update
     */
    where?: SaleStatusTypeWhereInput
  }

  /**
   * SaleStatusType upsert
   */
  export type SaleStatusTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleStatusType to update in case it exists.
     */
    where: SaleStatusTypeWhereUniqueInput
    /**
     * In case the SaleStatusType found by the `where` argument doesn't exist, create a new SaleStatusType with this data.
     */
    create: XOR<SaleStatusTypeCreateInput, SaleStatusTypeUncheckedCreateInput>
    /**
     * In case the SaleStatusType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleStatusTypeUpdateInput, SaleStatusTypeUncheckedUpdateInput>
  }

  /**
   * SaleStatusType delete
   */
  export type SaleStatusTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    /**
     * Filter which SaleStatusType to delete.
     */
    where: SaleStatusTypeWhereUniqueInput
  }

  /**
   * SaleStatusType deleteMany
   */
  export type SaleStatusTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleStatusTypes to delete
     */
    where?: SaleStatusTypeWhereInput
  }

  /**
   * SaleStatusType.sales
   */
  export type SaleStatusType$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * SaleStatusType without action
   */
  export type SaleStatusTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    sale_id: number | null
    counterparty_id: number | null
    responsible_manager_id: number | null
    project_id: number | null
  }

  export type SaleSumAggregateOutputType = {
    sale_id: number | null
    counterparty_id: number | null
    responsible_manager_id: number | null
    project_id: number | null
  }

  export type SaleMinAggregateOutputType = {
    sale_id: number | null
    counterparty_id: number | null
    responsible_manager_id: number | null
    sale_date: Date | null
    status: string | null
    deferred_payment_date: Date | null
    project_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    sale_id: number | null
    counterparty_id: number | null
    responsible_manager_id: number | null
    sale_date: Date | null
    status: string | null
    deferred_payment_date: Date | null
    project_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SaleCountAggregateOutputType = {
    sale_id: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: number
    status: number
    deferred_payment_date: number
    project_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    sale_id?: true
    counterparty_id?: true
    responsible_manager_id?: true
    project_id?: true
  }

  export type SaleSumAggregateInputType = {
    sale_id?: true
    counterparty_id?: true
    responsible_manager_id?: true
    project_id?: true
  }

  export type SaleMinAggregateInputType = {
    sale_id?: true
    counterparty_id?: true
    responsible_manager_id?: true
    sale_date?: true
    status?: true
    deferred_payment_date?: true
    project_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SaleMaxAggregateInputType = {
    sale_id?: true
    counterparty_id?: true
    responsible_manager_id?: true
    sale_date?: true
    status?: true
    deferred_payment_date?: true
    project_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SaleCountAggregateInputType = {
    sale_id?: true
    counterparty_id?: true
    responsible_manager_id?: true
    sale_date?: true
    status?: true
    deferred_payment_date?: true
    project_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    sale_id: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date
    status: string
    deferred_payment_date: Date | null
    project_id: number | null
    created_at: Date
    updated_at: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    counterparty_id?: boolean
    responsible_manager_id?: boolean
    sale_date?: boolean
    status?: boolean
    deferred_payment_date?: boolean
    project_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    counterparty?: boolean | CounterpartyDefaultArgs<ExtArgs>
    responsible_manager?: boolean | ManagerDefaultArgs<ExtArgs>
    project?: boolean | Sale$projectArgs<ExtArgs>
    products?: boolean | Sale$productsArgs<ExtArgs>
    services?: boolean | Sale$servicesArgs<ExtArgs>
    sale_status_type?: boolean | Sale$sale_status_typeArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    counterparty_id?: boolean
    responsible_manager_id?: boolean
    sale_date?: boolean
    status?: boolean
    deferred_payment_date?: boolean
    project_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    counterparty?: boolean | CounterpartyDefaultArgs<ExtArgs>
    responsible_manager?: boolean | ManagerDefaultArgs<ExtArgs>
    project?: boolean | Sale$projectArgs<ExtArgs>
    sale_status_type?: boolean | Sale$sale_status_typeArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    sale_id?: boolean
    counterparty_id?: boolean
    responsible_manager_id?: boolean
    sale_date?: boolean
    status?: boolean
    deferred_payment_date?: boolean
    project_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counterparty?: boolean | CounterpartyDefaultArgs<ExtArgs>
    responsible_manager?: boolean | ManagerDefaultArgs<ExtArgs>
    project?: boolean | Sale$projectArgs<ExtArgs>
    products?: boolean | Sale$productsArgs<ExtArgs>
    services?: boolean | Sale$servicesArgs<ExtArgs>
    sale_status_type?: boolean | Sale$sale_status_typeArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counterparty?: boolean | CounterpartyDefaultArgs<ExtArgs>
    responsible_manager?: boolean | ManagerDefaultArgs<ExtArgs>
    project?: boolean | Sale$projectArgs<ExtArgs>
    sale_status_type?: boolean | Sale$sale_status_typeArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      counterparty: Prisma.$CounterpartyPayload<ExtArgs>
      responsible_manager: Prisma.$ManagerPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      products: Prisma.$SaleProductPayload<ExtArgs>[]
      services: Prisma.$SaleServicePayload<ExtArgs>[]
      sale_status_type: Prisma.$SaleStatusTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sale_id: number
      counterparty_id: number
      responsible_manager_id: number
      sale_date: Date
      status: string
      deferred_payment_date: Date | null
      project_id: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `sale_id`
     * const saleWithSale_idOnly = await prisma.sale.findMany({ select: { sale_id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `sale_id`
     * const saleWithSale_idOnly = await prisma.sale.createManyAndReturn({ 
     *   select: { sale_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    counterparty<T extends CounterpartyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CounterpartyDefaultArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responsible_manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends Sale$projectArgs<ExtArgs> = {}>(args?: Subset<T, Sale$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    products<T extends Sale$productsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Sale$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Sale$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany"> | Null>
    sale_status_type<T extends Sale$sale_status_typeArgs<ExtArgs> = {}>(args?: Subset<T, Sale$sale_status_typeArgs<ExtArgs>>): Prisma__SaleStatusTypeClient<$Result.GetResult<Prisma.$SaleStatusTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly sale_id: FieldRef<"Sale", 'Int'>
    readonly counterparty_id: FieldRef<"Sale", 'Int'>
    readonly responsible_manager_id: FieldRef<"Sale", 'Int'>
    readonly sale_date: FieldRef<"Sale", 'DateTime'>
    readonly status: FieldRef<"Sale", 'String'>
    readonly deferred_payment_date: FieldRef<"Sale", 'DateTime'>
    readonly project_id: FieldRef<"Sale", 'Int'>
    readonly created_at: FieldRef<"Sale", 'DateTime'>
    readonly updated_at: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
  }

  /**
   * Sale.project
   */
  export type Sale$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Sale.products
   */
  export type Sale$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Sale.services
   */
  export type Sale$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    cursor?: SaleServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * Sale.sale_status_type
   */
  export type Sale$sale_status_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleStatusType
     */
    select?: SaleStatusTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleStatusTypeInclude<ExtArgs> | null
    where?: SaleStatusTypeWhereInput
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleProduct
   */

  export type AggregateSaleProduct = {
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  export type SaleProductAvgAggregateOutputType = {
    sale_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type SaleProductSumAggregateOutputType = {
    sale_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type SaleProductMinAggregateOutputType = {
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type SaleProductMaxAggregateOutputType = {
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type SaleProductCountAggregateOutputType = {
    sale_id: number
    product_id: number
    quantity: number
    created_at: number
    _all: number
  }


  export type SaleProductAvgAggregateInputType = {
    sale_id?: true
    product_id?: true
    quantity?: true
  }

  export type SaleProductSumAggregateInputType = {
    sale_id?: true
    product_id?: true
    quantity?: true
  }

  export type SaleProductMinAggregateInputType = {
    sale_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type SaleProductMaxAggregateInputType = {
    sale_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type SaleProductCountAggregateInputType = {
    sale_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
    _all?: true
  }

  export type SaleProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProduct to aggregate.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleProducts
    **/
    _count?: true | SaleProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleProductMaxAggregateInputType
  }

  export type GetSaleProductAggregateType<T extends SaleProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleProduct[P]>
      : GetScalarType<T[P], AggregateSaleProduct[P]>
  }




  export type SaleProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithAggregationInput | SaleProductOrderByWithAggregationInput[]
    by: SaleProductScalarFieldEnum[] | SaleProductScalarFieldEnum
    having?: SaleProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleProductCountAggregateInputType | true
    _avg?: SaleProductAvgAggregateInputType
    _sum?: SaleProductSumAggregateInputType
    _min?: SaleProductMinAggregateInputType
    _max?: SaleProductMaxAggregateInputType
  }

  export type SaleProductGroupByOutputType = {
    sale_id: number
    product_id: number
    quantity: number
    created_at: Date
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  type GetSaleProductGroupByPayload<T extends SaleProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
            : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
        }
      >
    >


  export type SaleProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectScalar = {
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
  }

  export type SaleProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SaleProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SaleProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleProduct"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sale_id: number
      product_id: number
      quantity: number
      created_at: Date
    }, ExtArgs["result"]["saleProduct"]>
    composites: {}
  }

  type SaleProductGetPayload<S extends boolean | null | undefined | SaleProductDefaultArgs> = $Result.GetResult<Prisma.$SaleProductPayload, S>

  type SaleProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleProductCountAggregateInputType | true
    }

  export interface SaleProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleProduct'], meta: { name: 'SaleProduct' } }
    /**
     * Find zero or one SaleProduct that matches the filter.
     * @param {SaleProductFindUniqueArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleProductFindUniqueArgs>(args: SelectSubset<T, SaleProductFindUniqueArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleProductFindUniqueOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleProductFindFirstArgs>(args?: SelectSubset<T, SaleProductFindFirstArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany()
     * 
     * // Get first 10 SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany({ take: 10 })
     * 
     * // Only select the `sale_id`
     * const saleProductWithSale_idOnly = await prisma.saleProduct.findMany({ select: { sale_id: true } })
     * 
     */
    findMany<T extends SaleProductFindManyArgs>(args?: SelectSubset<T, SaleProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleProduct.
     * @param {SaleProductCreateArgs} args - Arguments to create a SaleProduct.
     * @example
     * // Create one SaleProduct
     * const SaleProduct = await prisma.saleProduct.create({
     *   data: {
     *     // ... data to create a SaleProduct
     *   }
     * })
     * 
     */
    create<T extends SaleProductCreateArgs>(args: SelectSubset<T, SaleProductCreateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleProducts.
     * @param {SaleProductCreateManyArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleProductCreateManyArgs>(args?: SelectSubset<T, SaleProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleProducts and returns the data saved in the database.
     * @param {SaleProductCreateManyAndReturnArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleProducts and only return the `sale_id`
     * const saleProductWithSale_idOnly = await prisma.saleProduct.createManyAndReturn({ 
     *   select: { sale_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleProduct.
     * @param {SaleProductDeleteArgs} args - Arguments to delete one SaleProduct.
     * @example
     * // Delete one SaleProduct
     * const SaleProduct = await prisma.saleProduct.delete({
     *   where: {
     *     // ... filter to delete one SaleProduct
     *   }
     * })
     * 
     */
    delete<T extends SaleProductDeleteArgs>(args: SelectSubset<T, SaleProductDeleteArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleProduct.
     * @param {SaleProductUpdateArgs} args - Arguments to update one SaleProduct.
     * @example
     * // Update one SaleProduct
     * const saleProduct = await prisma.saleProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleProductUpdateArgs>(args: SelectSubset<T, SaleProductUpdateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleProducts.
     * @param {SaleProductDeleteManyArgs} args - Arguments to filter SaleProducts to delete.
     * @example
     * // Delete a few SaleProducts
     * const { count } = await prisma.saleProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleProductDeleteManyArgs>(args?: SelectSubset<T, SaleProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleProducts
     * const saleProduct = await prisma.saleProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleProductUpdateManyArgs>(args: SelectSubset<T, SaleProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleProduct.
     * @param {SaleProductUpsertArgs} args - Arguments to update or create a SaleProduct.
     * @example
     * // Update or create a SaleProduct
     * const saleProduct = await prisma.saleProduct.upsert({
     *   create: {
     *     // ... data to create a SaleProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleProduct we want to update
     *   }
     * })
     */
    upsert<T extends SaleProductUpsertArgs>(args: SelectSubset<T, SaleProductUpsertArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductCountArgs} args - Arguments to filter SaleProducts to count.
     * @example
     * // Count the number of SaleProducts
     * const count = await prisma.saleProduct.count({
     *   where: {
     *     // ... the filter for the SaleProducts we want to count
     *   }
     * })
    **/
    count<T extends SaleProductCountArgs>(
      args?: Subset<T, SaleProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleProductAggregateArgs>(args: Subset<T, SaleProductAggregateArgs>): Prisma.PrismaPromise<GetSaleProductAggregateType<T>>

    /**
     * Group by SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleProductGroupByArgs['orderBy'] }
        : { orderBy?: SaleProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleProduct model
   */
  readonly fields: SaleProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleProduct model
   */ 
  interface SaleProductFieldRefs {
    readonly sale_id: FieldRef<"SaleProduct", 'Int'>
    readonly product_id: FieldRef<"SaleProduct", 'Int'>
    readonly quantity: FieldRef<"SaleProduct", 'Int'>
    readonly created_at: FieldRef<"SaleProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleProduct findUnique
   */
  export type SaleProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findUniqueOrThrow
   */
  export type SaleProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findFirst
   */
  export type SaleProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findFirstOrThrow
   */
  export type SaleProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findMany
   */
  export type SaleProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProducts to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct create
   */
  export type SaleProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleProduct.
     */
    data: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
  }

  /**
   * SaleProduct createMany
   */
  export type SaleProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleProduct createManyAndReturn
   */
  export type SaleProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleProduct update
   */
  export type SaleProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleProduct.
     */
    data: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
    /**
     * Choose, which SaleProduct to update.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct updateMany
   */
  export type SaleProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleProducts.
     */
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyInput>
    /**
     * Filter which SaleProducts to update
     */
    where?: SaleProductWhereInput
  }

  /**
   * SaleProduct upsert
   */
  export type SaleProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleProduct to update in case it exists.
     */
    where: SaleProductWhereUniqueInput
    /**
     * In case the SaleProduct found by the `where` argument doesn't exist, create a new SaleProduct with this data.
     */
    create: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
    /**
     * In case the SaleProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
  }

  /**
   * SaleProduct delete
   */
  export type SaleProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter which SaleProduct to delete.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct deleteMany
   */
  export type SaleProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProducts to delete
     */
    where?: SaleProductWhereInput
  }

  /**
   * SaleProduct without action
   */
  export type SaleProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
  }


  /**
   * Model SaleService
   */

  export type AggregateSaleService = {
    _count: SaleServiceCountAggregateOutputType | null
    _avg: SaleServiceAvgAggregateOutputType | null
    _sum: SaleServiceSumAggregateOutputType | null
    _min: SaleServiceMinAggregateOutputType | null
    _max: SaleServiceMaxAggregateOutputType | null
  }

  export type SaleServiceAvgAggregateOutputType = {
    sale_id: number | null
    service_id: number | null
  }

  export type SaleServiceSumAggregateOutputType = {
    sale_id: number | null
    service_id: number | null
  }

  export type SaleServiceMinAggregateOutputType = {
    sale_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type SaleServiceMaxAggregateOutputType = {
    sale_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type SaleServiceCountAggregateOutputType = {
    sale_id: number
    service_id: number
    created_at: number
    _all: number
  }


  export type SaleServiceAvgAggregateInputType = {
    sale_id?: true
    service_id?: true
  }

  export type SaleServiceSumAggregateInputType = {
    sale_id?: true
    service_id?: true
  }

  export type SaleServiceMinAggregateInputType = {
    sale_id?: true
    service_id?: true
    created_at?: true
  }

  export type SaleServiceMaxAggregateInputType = {
    sale_id?: true
    service_id?: true
    created_at?: true
  }

  export type SaleServiceCountAggregateInputType = {
    sale_id?: true
    service_id?: true
    created_at?: true
    _all?: true
  }

  export type SaleServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleService to aggregate.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleServices
    **/
    _count?: true | SaleServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleServiceMaxAggregateInputType
  }

  export type GetSaleServiceAggregateType<T extends SaleServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleService[P]>
      : GetScalarType<T[P], AggregateSaleService[P]>
  }




  export type SaleServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleServiceWhereInput
    orderBy?: SaleServiceOrderByWithAggregationInput | SaleServiceOrderByWithAggregationInput[]
    by: SaleServiceScalarFieldEnum[] | SaleServiceScalarFieldEnum
    having?: SaleServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleServiceCountAggregateInputType | true
    _avg?: SaleServiceAvgAggregateInputType
    _sum?: SaleServiceSumAggregateInputType
    _min?: SaleServiceMinAggregateInputType
    _max?: SaleServiceMaxAggregateInputType
  }

  export type SaleServiceGroupByOutputType = {
    sale_id: number
    service_id: number
    created_at: Date
    _count: SaleServiceCountAggregateOutputType | null
    _avg: SaleServiceAvgAggregateOutputType | null
    _sum: SaleServiceSumAggregateOutputType | null
    _min: SaleServiceMinAggregateOutputType | null
    _max: SaleServiceMaxAggregateOutputType | null
  }

  type GetSaleServiceGroupByPayload<T extends SaleServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleServiceGroupByOutputType[P]>
            : GetScalarType<T[P], SaleServiceGroupByOutputType[P]>
        }
      >
    >


  export type SaleServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    service_id?: boolean
    created_at?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleService"]>

  export type SaleServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sale_id?: boolean
    service_id?: boolean
    created_at?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleService"]>

  export type SaleServiceSelectScalar = {
    sale_id?: boolean
    service_id?: boolean
    created_at?: boolean
  }

  export type SaleServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type SaleServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $SaleServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleService"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sale_id: number
      service_id: number
      created_at: Date
    }, ExtArgs["result"]["saleService"]>
    composites: {}
  }

  type SaleServiceGetPayload<S extends boolean | null | undefined | SaleServiceDefaultArgs> = $Result.GetResult<Prisma.$SaleServicePayload, S>

  type SaleServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleServiceCountAggregateInputType | true
    }

  export interface SaleServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleService'], meta: { name: 'SaleService' } }
    /**
     * Find zero or one SaleService that matches the filter.
     * @param {SaleServiceFindUniqueArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleServiceFindUniqueArgs>(args: SelectSubset<T, SaleServiceFindUniqueArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleServiceFindUniqueOrThrowArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindFirstArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleServiceFindFirstArgs>(args?: SelectSubset<T, SaleServiceFindFirstArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindFirstOrThrowArgs} args - Arguments to find a SaleService
     * @example
     * // Get one SaleService
     * const saleService = await prisma.saleService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleServices
     * const saleServices = await prisma.saleService.findMany()
     * 
     * // Get first 10 SaleServices
     * const saleServices = await prisma.saleService.findMany({ take: 10 })
     * 
     * // Only select the `sale_id`
     * const saleServiceWithSale_idOnly = await prisma.saleService.findMany({ select: { sale_id: true } })
     * 
     */
    findMany<T extends SaleServiceFindManyArgs>(args?: SelectSubset<T, SaleServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleService.
     * @param {SaleServiceCreateArgs} args - Arguments to create a SaleService.
     * @example
     * // Create one SaleService
     * const SaleService = await prisma.saleService.create({
     *   data: {
     *     // ... data to create a SaleService
     *   }
     * })
     * 
     */
    create<T extends SaleServiceCreateArgs>(args: SelectSubset<T, SaleServiceCreateArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleServices.
     * @param {SaleServiceCreateManyArgs} args - Arguments to create many SaleServices.
     * @example
     * // Create many SaleServices
     * const saleService = await prisma.saleService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleServiceCreateManyArgs>(args?: SelectSubset<T, SaleServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleServices and returns the data saved in the database.
     * @param {SaleServiceCreateManyAndReturnArgs} args - Arguments to create many SaleServices.
     * @example
     * // Create many SaleServices
     * const saleService = await prisma.saleService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleServices and only return the `sale_id`
     * const saleServiceWithSale_idOnly = await prisma.saleService.createManyAndReturn({ 
     *   select: { sale_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleService.
     * @param {SaleServiceDeleteArgs} args - Arguments to delete one SaleService.
     * @example
     * // Delete one SaleService
     * const SaleService = await prisma.saleService.delete({
     *   where: {
     *     // ... filter to delete one SaleService
     *   }
     * })
     * 
     */
    delete<T extends SaleServiceDeleteArgs>(args: SelectSubset<T, SaleServiceDeleteArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleService.
     * @param {SaleServiceUpdateArgs} args - Arguments to update one SaleService.
     * @example
     * // Update one SaleService
     * const saleService = await prisma.saleService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleServiceUpdateArgs>(args: SelectSubset<T, SaleServiceUpdateArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleServices.
     * @param {SaleServiceDeleteManyArgs} args - Arguments to filter SaleServices to delete.
     * @example
     * // Delete a few SaleServices
     * const { count } = await prisma.saleService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleServiceDeleteManyArgs>(args?: SelectSubset<T, SaleServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleServices
     * const saleService = await prisma.saleService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleServiceUpdateManyArgs>(args: SelectSubset<T, SaleServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleService.
     * @param {SaleServiceUpsertArgs} args - Arguments to update or create a SaleService.
     * @example
     * // Update or create a SaleService
     * const saleService = await prisma.saleService.upsert({
     *   create: {
     *     // ... data to create a SaleService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleService we want to update
     *   }
     * })
     */
    upsert<T extends SaleServiceUpsertArgs>(args: SelectSubset<T, SaleServiceUpsertArgs<ExtArgs>>): Prisma__SaleServiceClient<$Result.GetResult<Prisma.$SaleServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceCountArgs} args - Arguments to filter SaleServices to count.
     * @example
     * // Count the number of SaleServices
     * const count = await prisma.saleService.count({
     *   where: {
     *     // ... the filter for the SaleServices we want to count
     *   }
     * })
    **/
    count<T extends SaleServiceCountArgs>(
      args?: Subset<T, SaleServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleServiceAggregateArgs>(args: Subset<T, SaleServiceAggregateArgs>): Prisma.PrismaPromise<GetSaleServiceAggregateType<T>>

    /**
     * Group by SaleService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleServiceGroupByArgs['orderBy'] }
        : { orderBy?: SaleServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleService model
   */
  readonly fields: SaleServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleService model
   */ 
  interface SaleServiceFieldRefs {
    readonly sale_id: FieldRef<"SaleService", 'Int'>
    readonly service_id: FieldRef<"SaleService", 'Int'>
    readonly created_at: FieldRef<"SaleService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleService findUnique
   */
  export type SaleServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService findUniqueOrThrow
   */
  export type SaleServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService findFirst
   */
  export type SaleServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleServices.
     */
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService findFirstOrThrow
   */
  export type SaleServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleService to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleServices.
     */
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService findMany
   */
  export type SaleServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter, which SaleServices to fetch.
     */
    where?: SaleServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleServices to fetch.
     */
    orderBy?: SaleServiceOrderByWithRelationInput | SaleServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleServices.
     */
    cursor?: SaleServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleServices.
     */
    skip?: number
    distinct?: SaleServiceScalarFieldEnum | SaleServiceScalarFieldEnum[]
  }

  /**
   * SaleService create
   */
  export type SaleServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleService.
     */
    data: XOR<SaleServiceCreateInput, SaleServiceUncheckedCreateInput>
  }

  /**
   * SaleService createMany
   */
  export type SaleServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleServices.
     */
    data: SaleServiceCreateManyInput | SaleServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleService createManyAndReturn
   */
  export type SaleServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleServices.
     */
    data: SaleServiceCreateManyInput | SaleServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleService update
   */
  export type SaleServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleService.
     */
    data: XOR<SaleServiceUpdateInput, SaleServiceUncheckedUpdateInput>
    /**
     * Choose, which SaleService to update.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService updateMany
   */
  export type SaleServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleServices.
     */
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyInput>
    /**
     * Filter which SaleServices to update
     */
    where?: SaleServiceWhereInput
  }

  /**
   * SaleService upsert
   */
  export type SaleServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleService to update in case it exists.
     */
    where: SaleServiceWhereUniqueInput
    /**
     * In case the SaleService found by the `where` argument doesn't exist, create a new SaleService with this data.
     */
    create: XOR<SaleServiceCreateInput, SaleServiceUncheckedCreateInput>
    /**
     * In case the SaleService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleServiceUpdateInput, SaleServiceUncheckedUpdateInput>
  }

  /**
   * SaleService delete
   */
  export type SaleServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
    /**
     * Filter which SaleService to delete.
     */
    where: SaleServiceWhereUniqueInput
  }

  /**
   * SaleService deleteMany
   */
  export type SaleServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleServices to delete
     */
    where?: SaleServiceWhereInput
  }

  /**
   * SaleService without action
   */
  export type SaleServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleService
     */
    select?: SaleServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleServiceInclude<ExtArgs> | null
  }


  /**
   * Model Funnel
   */

  export type AggregateFunnel = {
    _count: FunnelCountAggregateOutputType | null
    _avg: FunnelAvgAggregateOutputType | null
    _sum: FunnelSumAggregateOutputType | null
    _min: FunnelMinAggregateOutputType | null
    _max: FunnelMaxAggregateOutputType | null
  }

  export type FunnelAvgAggregateOutputType = {
    funnel_id: number | null
  }

  export type FunnelSumAggregateOutputType = {
    funnel_id: number | null
  }

  export type FunnelMinAggregateOutputType = {
    funnel_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type FunnelMaxAggregateOutputType = {
    funnel_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type FunnelCountAggregateOutputType = {
    funnel_id: number
    name: number
    created_at: number
    _all: number
  }


  export type FunnelAvgAggregateInputType = {
    funnel_id?: true
  }

  export type FunnelSumAggregateInputType = {
    funnel_id?: true
  }

  export type FunnelMinAggregateInputType = {
    funnel_id?: true
    name?: true
    created_at?: true
  }

  export type FunnelMaxAggregateInputType = {
    funnel_id?: true
    name?: true
    created_at?: true
  }

  export type FunnelCountAggregateInputType = {
    funnel_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type FunnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnel to aggregate.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funnels
    **/
    _count?: true | FunnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunnelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunnelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelMaxAggregateInputType
  }

  export type GetFunnelAggregateType<T extends FunnelAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnel[P]>
      : GetScalarType<T[P], AggregateFunnel[P]>
  }




  export type FunnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelWhereInput
    orderBy?: FunnelOrderByWithAggregationInput | FunnelOrderByWithAggregationInput[]
    by: FunnelScalarFieldEnum[] | FunnelScalarFieldEnum
    having?: FunnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelCountAggregateInputType | true
    _avg?: FunnelAvgAggregateInputType
    _sum?: FunnelSumAggregateInputType
    _min?: FunnelMinAggregateInputType
    _max?: FunnelMaxAggregateInputType
  }

  export type FunnelGroupByOutputType = {
    funnel_id: number
    name: string
    created_at: Date
    _count: FunnelCountAggregateOutputType | null
    _avg: FunnelAvgAggregateOutputType | null
    _sum: FunnelSumAggregateOutputType | null
    _min: FunnelMinAggregateOutputType | null
    _max: FunnelMaxAggregateOutputType | null
  }

  type GetFunnelGroupByPayload<T extends FunnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelGroupByOutputType[P]>
        }
      >
    >


  export type FunnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    funnel_id?: boolean
    name?: boolean
    created_at?: boolean
    stages?: boolean | Funnel$stagesArgs<ExtArgs>
    projects?: boolean | Funnel$projectsArgs<ExtArgs>
    _count?: boolean | FunnelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnel"]>

  export type FunnelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    funnel_id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["funnel"]>

  export type FunnelSelectScalar = {
    funnel_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type FunnelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | Funnel$stagesArgs<ExtArgs>
    projects?: boolean | Funnel$projectsArgs<ExtArgs>
    _count?: boolean | FunnelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FunnelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FunnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Funnel"
    objects: {
      stages: Prisma.$FunnelStagePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      funnel_id: number
      name: string
      created_at: Date
    }, ExtArgs["result"]["funnel"]>
    composites: {}
  }

  type FunnelGetPayload<S extends boolean | null | undefined | FunnelDefaultArgs> = $Result.GetResult<Prisma.$FunnelPayload, S>

  type FunnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FunnelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FunnelCountAggregateInputType | true
    }

  export interface FunnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Funnel'], meta: { name: 'Funnel' } }
    /**
     * Find zero or one Funnel that matches the filter.
     * @param {FunnelFindUniqueArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelFindUniqueArgs>(args: SelectSubset<T, FunnelFindUniqueArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Funnel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FunnelFindUniqueOrThrowArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Funnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindFirstArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelFindFirstArgs>(args?: SelectSubset<T, FunnelFindFirstArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Funnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindFirstOrThrowArgs} args - Arguments to find a Funnel
     * @example
     * // Get one Funnel
     * const funnel = await prisma.funnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funnels
     * const funnels = await prisma.funnel.findMany()
     * 
     * // Get first 10 Funnels
     * const funnels = await prisma.funnel.findMany({ take: 10 })
     * 
     * // Only select the `funnel_id`
     * const funnelWithFunnel_idOnly = await prisma.funnel.findMany({ select: { funnel_id: true } })
     * 
     */
    findMany<T extends FunnelFindManyArgs>(args?: SelectSubset<T, FunnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Funnel.
     * @param {FunnelCreateArgs} args - Arguments to create a Funnel.
     * @example
     * // Create one Funnel
     * const Funnel = await prisma.funnel.create({
     *   data: {
     *     // ... data to create a Funnel
     *   }
     * })
     * 
     */
    create<T extends FunnelCreateArgs>(args: SelectSubset<T, FunnelCreateArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Funnels.
     * @param {FunnelCreateManyArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnel = await prisma.funnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelCreateManyArgs>(args?: SelectSubset<T, FunnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Funnels and returns the data saved in the database.
     * @param {FunnelCreateManyAndReturnArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnel = await prisma.funnel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Funnels and only return the `funnel_id`
     * const funnelWithFunnel_idOnly = await prisma.funnel.createManyAndReturn({ 
     *   select: { funnel_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Funnel.
     * @param {FunnelDeleteArgs} args - Arguments to delete one Funnel.
     * @example
     * // Delete one Funnel
     * const Funnel = await prisma.funnel.delete({
     *   where: {
     *     // ... filter to delete one Funnel
     *   }
     * })
     * 
     */
    delete<T extends FunnelDeleteArgs>(args: SelectSubset<T, FunnelDeleteArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Funnel.
     * @param {FunnelUpdateArgs} args - Arguments to update one Funnel.
     * @example
     * // Update one Funnel
     * const funnel = await prisma.funnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelUpdateArgs>(args: SelectSubset<T, FunnelUpdateArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Funnels.
     * @param {FunnelDeleteManyArgs} args - Arguments to filter Funnels to delete.
     * @example
     * // Delete a few Funnels
     * const { count } = await prisma.funnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelDeleteManyArgs>(args?: SelectSubset<T, FunnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funnels
     * const funnel = await prisma.funnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelUpdateManyArgs>(args: SelectSubset<T, FunnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Funnel.
     * @param {FunnelUpsertArgs} args - Arguments to update or create a Funnel.
     * @example
     * // Update or create a Funnel
     * const funnel = await prisma.funnel.upsert({
     *   create: {
     *     // ... data to create a Funnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funnel we want to update
     *   }
     * })
     */
    upsert<T extends FunnelUpsertArgs>(args: SelectSubset<T, FunnelUpsertArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelCountArgs} args - Arguments to filter Funnels to count.
     * @example
     * // Count the number of Funnels
     * const count = await prisma.funnel.count({
     *   where: {
     *     // ... the filter for the Funnels we want to count
     *   }
     * })
    **/
    count<T extends FunnelCountArgs>(
      args?: Subset<T, FunnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelAggregateArgs>(args: Subset<T, FunnelAggregateArgs>): Prisma.PrismaPromise<GetFunnelAggregateType<T>>

    /**
     * Group by Funnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelGroupByArgs['orderBy'] }
        : { orderBy?: FunnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Funnel model
   */
  readonly fields: FunnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Funnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stages<T extends Funnel$stagesArgs<ExtArgs> = {}>(args?: Subset<T, Funnel$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Funnel$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Funnel$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Funnel model
   */ 
  interface FunnelFieldRefs {
    readonly funnel_id: FieldRef<"Funnel", 'Int'>
    readonly name: FieldRef<"Funnel", 'String'>
    readonly created_at: FieldRef<"Funnel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Funnel findUnique
   */
  export type FunnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel findUniqueOrThrow
   */
  export type FunnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel findFirst
   */
  export type FunnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel findFirstOrThrow
   */
  export type FunnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnel to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel findMany
   */
  export type FunnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelOrderByWithRelationInput | FunnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funnels.
     */
    cursor?: FunnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    distinct?: FunnelScalarFieldEnum | FunnelScalarFieldEnum[]
  }

  /**
   * Funnel create
   */
  export type FunnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The data needed to create a Funnel.
     */
    data: XOR<FunnelCreateInput, FunnelUncheckedCreateInput>
  }

  /**
   * Funnel createMany
   */
  export type FunnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funnels.
     */
    data: FunnelCreateManyInput | FunnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Funnel createManyAndReturn
   */
  export type FunnelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Funnels.
     */
    data: FunnelCreateManyInput | FunnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Funnel update
   */
  export type FunnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The data needed to update a Funnel.
     */
    data: XOR<FunnelUpdateInput, FunnelUncheckedUpdateInput>
    /**
     * Choose, which Funnel to update.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel updateMany
   */
  export type FunnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelUpdateManyMutationInput, FunnelUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelWhereInput
  }

  /**
   * Funnel upsert
   */
  export type FunnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * The filter to search for the Funnel to update in case it exists.
     */
    where: FunnelWhereUniqueInput
    /**
     * In case the Funnel found by the `where` argument doesn't exist, create a new Funnel with this data.
     */
    create: XOR<FunnelCreateInput, FunnelUncheckedCreateInput>
    /**
     * In case the Funnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelUpdateInput, FunnelUncheckedUpdateInput>
  }

  /**
   * Funnel delete
   */
  export type FunnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    /**
     * Filter which Funnel to delete.
     */
    where: FunnelWhereUniqueInput
  }

  /**
   * Funnel deleteMany
   */
  export type FunnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to delete
     */
    where?: FunnelWhereInput
  }

  /**
   * Funnel.stages
   */
  export type Funnel$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    where?: FunnelStageWhereInput
    orderBy?: FunnelStageOrderByWithRelationInput | FunnelStageOrderByWithRelationInput[]
    cursor?: FunnelStageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelStageScalarFieldEnum | FunnelStageScalarFieldEnum[]
  }

  /**
   * Funnel.projects
   */
  export type Funnel$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Funnel without action
   */
  export type FunnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
  }


  /**
   * Model FunnelStage
   */

  export type AggregateFunnelStage = {
    _count: FunnelStageCountAggregateOutputType | null
    _avg: FunnelStageAvgAggregateOutputType | null
    _sum: FunnelStageSumAggregateOutputType | null
    _min: FunnelStageMinAggregateOutputType | null
    _max: FunnelStageMaxAggregateOutputType | null
  }

  export type FunnelStageAvgAggregateOutputType = {
    funnel_stage_id: number | null
    funnel_id: number | null
    order: number | null
  }

  export type FunnelStageSumAggregateOutputType = {
    funnel_stage_id: number | null
    funnel_id: number | null
    order: number | null
  }

  export type FunnelStageMinAggregateOutputType = {
    funnel_stage_id: number | null
    name: string | null
    funnel_id: number | null
    order: number | null
    created_at: Date | null
  }

  export type FunnelStageMaxAggregateOutputType = {
    funnel_stage_id: number | null
    name: string | null
    funnel_id: number | null
    order: number | null
    created_at: Date | null
  }

  export type FunnelStageCountAggregateOutputType = {
    funnel_stage_id: number
    name: number
    funnel_id: number
    order: number
    created_at: number
    _all: number
  }


  export type FunnelStageAvgAggregateInputType = {
    funnel_stage_id?: true
    funnel_id?: true
    order?: true
  }

  export type FunnelStageSumAggregateInputType = {
    funnel_stage_id?: true
    funnel_id?: true
    order?: true
  }

  export type FunnelStageMinAggregateInputType = {
    funnel_stage_id?: true
    name?: true
    funnel_id?: true
    order?: true
    created_at?: true
  }

  export type FunnelStageMaxAggregateInputType = {
    funnel_stage_id?: true
    name?: true
    funnel_id?: true
    order?: true
    created_at?: true
  }

  export type FunnelStageCountAggregateInputType = {
    funnel_stage_id?: true
    name?: true
    funnel_id?: true
    order?: true
    created_at?: true
    _all?: true
  }

  export type FunnelStageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelStage to aggregate.
     */
    where?: FunnelStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelStages to fetch.
     */
    orderBy?: FunnelStageOrderByWithRelationInput | FunnelStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunnelStages
    **/
    _count?: true | FunnelStageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunnelStageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunnelStageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelStageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelStageMaxAggregateInputType
  }

  export type GetFunnelStageAggregateType<T extends FunnelStageAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnelStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnelStage[P]>
      : GetScalarType<T[P], AggregateFunnelStage[P]>
  }




  export type FunnelStageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelStageWhereInput
    orderBy?: FunnelStageOrderByWithAggregationInput | FunnelStageOrderByWithAggregationInput[]
    by: FunnelStageScalarFieldEnum[] | FunnelStageScalarFieldEnum
    having?: FunnelStageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelStageCountAggregateInputType | true
    _avg?: FunnelStageAvgAggregateInputType
    _sum?: FunnelStageSumAggregateInputType
    _min?: FunnelStageMinAggregateInputType
    _max?: FunnelStageMaxAggregateInputType
  }

  export type FunnelStageGroupByOutputType = {
    funnel_stage_id: number
    name: string
    funnel_id: number
    order: number
    created_at: Date
    _count: FunnelStageCountAggregateOutputType | null
    _avg: FunnelStageAvgAggregateOutputType | null
    _sum: FunnelStageSumAggregateOutputType | null
    _min: FunnelStageMinAggregateOutputType | null
    _max: FunnelStageMaxAggregateOutputType | null
  }

  type GetFunnelStageGroupByPayload<T extends FunnelStageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelStageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelStageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelStageGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelStageGroupByOutputType[P]>
        }
      >
    >


  export type FunnelStageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    funnel_stage_id?: boolean
    name?: boolean
    funnel_id?: boolean
    order?: boolean
    created_at?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
    projects?: boolean | FunnelStage$projectsArgs<ExtArgs>
    _count?: boolean | FunnelStageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelStage"]>

  export type FunnelStageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    funnel_stage_id?: boolean
    name?: boolean
    funnel_id?: boolean
    order?: boolean
    created_at?: boolean
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnelStage"]>

  export type FunnelStageSelectScalar = {
    funnel_stage_id?: boolean
    name?: boolean
    funnel_id?: boolean
    order?: boolean
    created_at?: boolean
  }

  export type FunnelStageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
    projects?: boolean | FunnelStage$projectsArgs<ExtArgs>
    _count?: boolean | FunnelStageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FunnelStageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    funnel?: boolean | FunnelDefaultArgs<ExtArgs>
  }

  export type $FunnelStagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunnelStage"
    objects: {
      funnel: Prisma.$FunnelPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      funnel_stage_id: number
      name: string
      funnel_id: number
      order: number
      created_at: Date
    }, ExtArgs["result"]["funnelStage"]>
    composites: {}
  }

  type FunnelStageGetPayload<S extends boolean | null | undefined | FunnelStageDefaultArgs> = $Result.GetResult<Prisma.$FunnelStagePayload, S>

  type FunnelStageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FunnelStageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FunnelStageCountAggregateInputType | true
    }

  export interface FunnelStageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunnelStage'], meta: { name: 'FunnelStage' } }
    /**
     * Find zero or one FunnelStage that matches the filter.
     * @param {FunnelStageFindUniqueArgs} args - Arguments to find a FunnelStage
     * @example
     * // Get one FunnelStage
     * const funnelStage = await prisma.funnelStage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelStageFindUniqueArgs>(args: SelectSubset<T, FunnelStageFindUniqueArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FunnelStage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FunnelStageFindUniqueOrThrowArgs} args - Arguments to find a FunnelStage
     * @example
     * // Get one FunnelStage
     * const funnelStage = await prisma.funnelStage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelStageFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelStageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FunnelStage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageFindFirstArgs} args - Arguments to find a FunnelStage
     * @example
     * // Get one FunnelStage
     * const funnelStage = await prisma.funnelStage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelStageFindFirstArgs>(args?: SelectSubset<T, FunnelStageFindFirstArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FunnelStage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageFindFirstOrThrowArgs} args - Arguments to find a FunnelStage
     * @example
     * // Get one FunnelStage
     * const funnelStage = await prisma.funnelStage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelStageFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelStageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FunnelStages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunnelStages
     * const funnelStages = await prisma.funnelStage.findMany()
     * 
     * // Get first 10 FunnelStages
     * const funnelStages = await prisma.funnelStage.findMany({ take: 10 })
     * 
     * // Only select the `funnel_stage_id`
     * const funnelStageWithFunnel_stage_idOnly = await prisma.funnelStage.findMany({ select: { funnel_stage_id: true } })
     * 
     */
    findMany<T extends FunnelStageFindManyArgs>(args?: SelectSubset<T, FunnelStageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FunnelStage.
     * @param {FunnelStageCreateArgs} args - Arguments to create a FunnelStage.
     * @example
     * // Create one FunnelStage
     * const FunnelStage = await prisma.funnelStage.create({
     *   data: {
     *     // ... data to create a FunnelStage
     *   }
     * })
     * 
     */
    create<T extends FunnelStageCreateArgs>(args: SelectSubset<T, FunnelStageCreateArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FunnelStages.
     * @param {FunnelStageCreateManyArgs} args - Arguments to create many FunnelStages.
     * @example
     * // Create many FunnelStages
     * const funnelStage = await prisma.funnelStage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelStageCreateManyArgs>(args?: SelectSubset<T, FunnelStageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FunnelStages and returns the data saved in the database.
     * @param {FunnelStageCreateManyAndReturnArgs} args - Arguments to create many FunnelStages.
     * @example
     * // Create many FunnelStages
     * const funnelStage = await prisma.funnelStage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FunnelStages and only return the `funnel_stage_id`
     * const funnelStageWithFunnel_stage_idOnly = await prisma.funnelStage.createManyAndReturn({ 
     *   select: { funnel_stage_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelStageCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelStageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FunnelStage.
     * @param {FunnelStageDeleteArgs} args - Arguments to delete one FunnelStage.
     * @example
     * // Delete one FunnelStage
     * const FunnelStage = await prisma.funnelStage.delete({
     *   where: {
     *     // ... filter to delete one FunnelStage
     *   }
     * })
     * 
     */
    delete<T extends FunnelStageDeleteArgs>(args: SelectSubset<T, FunnelStageDeleteArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FunnelStage.
     * @param {FunnelStageUpdateArgs} args - Arguments to update one FunnelStage.
     * @example
     * // Update one FunnelStage
     * const funnelStage = await prisma.funnelStage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelStageUpdateArgs>(args: SelectSubset<T, FunnelStageUpdateArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FunnelStages.
     * @param {FunnelStageDeleteManyArgs} args - Arguments to filter FunnelStages to delete.
     * @example
     * // Delete a few FunnelStages
     * const { count } = await prisma.funnelStage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelStageDeleteManyArgs>(args?: SelectSubset<T, FunnelStageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunnelStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunnelStages
     * const funnelStage = await prisma.funnelStage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelStageUpdateManyArgs>(args: SelectSubset<T, FunnelStageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FunnelStage.
     * @param {FunnelStageUpsertArgs} args - Arguments to update or create a FunnelStage.
     * @example
     * // Update or create a FunnelStage
     * const funnelStage = await prisma.funnelStage.upsert({
     *   create: {
     *     // ... data to create a FunnelStage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunnelStage we want to update
     *   }
     * })
     */
    upsert<T extends FunnelStageUpsertArgs>(args: SelectSubset<T, FunnelStageUpsertArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FunnelStages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageCountArgs} args - Arguments to filter FunnelStages to count.
     * @example
     * // Count the number of FunnelStages
     * const count = await prisma.funnelStage.count({
     *   where: {
     *     // ... the filter for the FunnelStages we want to count
     *   }
     * })
    **/
    count<T extends FunnelStageCountArgs>(
      args?: Subset<T, FunnelStageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelStageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunnelStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelStageAggregateArgs>(args: Subset<T, FunnelStageAggregateArgs>): Prisma.PrismaPromise<GetFunnelStageAggregateType<T>>

    /**
     * Group by FunnelStage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelStageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelStageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelStageGroupByArgs['orderBy'] }
        : { orderBy?: FunnelStageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelStageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunnelStage model
   */
  readonly fields: FunnelStageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunnelStage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelStageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    funnel<T extends FunnelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelDefaultArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projects<T extends FunnelStage$projectsArgs<ExtArgs> = {}>(args?: Subset<T, FunnelStage$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunnelStage model
   */ 
  interface FunnelStageFieldRefs {
    readonly funnel_stage_id: FieldRef<"FunnelStage", 'Int'>
    readonly name: FieldRef<"FunnelStage", 'String'>
    readonly funnel_id: FieldRef<"FunnelStage", 'Int'>
    readonly order: FieldRef<"FunnelStage", 'Int'>
    readonly created_at: FieldRef<"FunnelStage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FunnelStage findUnique
   */
  export type FunnelStageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelStage to fetch.
     */
    where: FunnelStageWhereUniqueInput
  }

  /**
   * FunnelStage findUniqueOrThrow
   */
  export type FunnelStageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelStage to fetch.
     */
    where: FunnelStageWhereUniqueInput
  }

  /**
   * FunnelStage findFirst
   */
  export type FunnelStageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelStage to fetch.
     */
    where?: FunnelStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelStages to fetch.
     */
    orderBy?: FunnelStageOrderByWithRelationInput | FunnelStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelStages.
     */
    cursor?: FunnelStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelStages.
     */
    distinct?: FunnelStageScalarFieldEnum | FunnelStageScalarFieldEnum[]
  }

  /**
   * FunnelStage findFirstOrThrow
   */
  export type FunnelStageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelStage to fetch.
     */
    where?: FunnelStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelStages to fetch.
     */
    orderBy?: FunnelStageOrderByWithRelationInput | FunnelStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunnelStages.
     */
    cursor?: FunnelStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelStages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunnelStages.
     */
    distinct?: FunnelStageScalarFieldEnum | FunnelStageScalarFieldEnum[]
  }

  /**
   * FunnelStage findMany
   */
  export type FunnelStageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter, which FunnelStages to fetch.
     */
    where?: FunnelStageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunnelStages to fetch.
     */
    orderBy?: FunnelStageOrderByWithRelationInput | FunnelStageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunnelStages.
     */
    cursor?: FunnelStageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunnelStages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunnelStages.
     */
    skip?: number
    distinct?: FunnelStageScalarFieldEnum | FunnelStageScalarFieldEnum[]
  }

  /**
   * FunnelStage create
   */
  export type FunnelStageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * The data needed to create a FunnelStage.
     */
    data: XOR<FunnelStageCreateInput, FunnelStageUncheckedCreateInput>
  }

  /**
   * FunnelStage createMany
   */
  export type FunnelStageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunnelStages.
     */
    data: FunnelStageCreateManyInput | FunnelStageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunnelStage createManyAndReturn
   */
  export type FunnelStageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FunnelStages.
     */
    data: FunnelStageCreateManyInput | FunnelStageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunnelStage update
   */
  export type FunnelStageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * The data needed to update a FunnelStage.
     */
    data: XOR<FunnelStageUpdateInput, FunnelStageUncheckedUpdateInput>
    /**
     * Choose, which FunnelStage to update.
     */
    where: FunnelStageWhereUniqueInput
  }

  /**
   * FunnelStage updateMany
   */
  export type FunnelStageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunnelStages.
     */
    data: XOR<FunnelStageUpdateManyMutationInput, FunnelStageUncheckedUpdateManyInput>
    /**
     * Filter which FunnelStages to update
     */
    where?: FunnelStageWhereInput
  }

  /**
   * FunnelStage upsert
   */
  export type FunnelStageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * The filter to search for the FunnelStage to update in case it exists.
     */
    where: FunnelStageWhereUniqueInput
    /**
     * In case the FunnelStage found by the `where` argument doesn't exist, create a new FunnelStage with this data.
     */
    create: XOR<FunnelStageCreateInput, FunnelStageUncheckedCreateInput>
    /**
     * In case the FunnelStage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelStageUpdateInput, FunnelStageUncheckedUpdateInput>
  }

  /**
   * FunnelStage delete
   */
  export type FunnelStageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    /**
     * Filter which FunnelStage to delete.
     */
    where: FunnelStageWhereUniqueInput
  }

  /**
   * FunnelStage deleteMany
   */
  export type FunnelStageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunnelStages to delete
     */
    where?: FunnelStageWhereInput
  }

  /**
   * FunnelStage.projects
   */
  export type FunnelStage$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * FunnelStage without action
   */
  export type FunnelStageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
  }


  /**
   * Model SubProjectStatusType
   */

  export type AggregateSubProjectStatusType = {
    _count: SubProjectStatusTypeCountAggregateOutputType | null
    _avg: SubProjectStatusTypeAvgAggregateOutputType | null
    _sum: SubProjectStatusTypeSumAggregateOutputType | null
    _min: SubProjectStatusTypeMinAggregateOutputType | null
    _max: SubProjectStatusTypeMaxAggregateOutputType | null
  }

  export type SubProjectStatusTypeAvgAggregateOutputType = {
    sub_project_status_id: number | null
  }

  export type SubProjectStatusTypeSumAggregateOutputType = {
    sub_project_status_id: number | null
  }

  export type SubProjectStatusTypeMinAggregateOutputType = {
    sub_project_status_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SubProjectStatusTypeMaxAggregateOutputType = {
    sub_project_status_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SubProjectStatusTypeCountAggregateOutputType = {
    sub_project_status_id: number
    name: number
    created_at: number
    _all: number
  }


  export type SubProjectStatusTypeAvgAggregateInputType = {
    sub_project_status_id?: true
  }

  export type SubProjectStatusTypeSumAggregateInputType = {
    sub_project_status_id?: true
  }

  export type SubProjectStatusTypeMinAggregateInputType = {
    sub_project_status_id?: true
    name?: true
    created_at?: true
  }

  export type SubProjectStatusTypeMaxAggregateInputType = {
    sub_project_status_id?: true
    name?: true
    created_at?: true
  }

  export type SubProjectStatusTypeCountAggregateInputType = {
    sub_project_status_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type SubProjectStatusTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectStatusType to aggregate.
     */
    where?: SubProjectStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectStatusTypes to fetch.
     */
    orderBy?: SubProjectStatusTypeOrderByWithRelationInput | SubProjectStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubProjectStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubProjectStatusTypes
    **/
    _count?: true | SubProjectStatusTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubProjectStatusTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubProjectStatusTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubProjectStatusTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubProjectStatusTypeMaxAggregateInputType
  }

  export type GetSubProjectStatusTypeAggregateType<T extends SubProjectStatusTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSubProjectStatusType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubProjectStatusType[P]>
      : GetScalarType<T[P], AggregateSubProjectStatusType[P]>
  }




  export type SubProjectStatusTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectStatusTypeWhereInput
    orderBy?: SubProjectStatusTypeOrderByWithAggregationInput | SubProjectStatusTypeOrderByWithAggregationInput[]
    by: SubProjectStatusTypeScalarFieldEnum[] | SubProjectStatusTypeScalarFieldEnum
    having?: SubProjectStatusTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubProjectStatusTypeCountAggregateInputType | true
    _avg?: SubProjectStatusTypeAvgAggregateInputType
    _sum?: SubProjectStatusTypeSumAggregateInputType
    _min?: SubProjectStatusTypeMinAggregateInputType
    _max?: SubProjectStatusTypeMaxAggregateInputType
  }

  export type SubProjectStatusTypeGroupByOutputType = {
    sub_project_status_id: number
    name: string
    created_at: Date
    _count: SubProjectStatusTypeCountAggregateOutputType | null
    _avg: SubProjectStatusTypeAvgAggregateOutputType | null
    _sum: SubProjectStatusTypeSumAggregateOutputType | null
    _min: SubProjectStatusTypeMinAggregateOutputType | null
    _max: SubProjectStatusTypeMaxAggregateOutputType | null
  }

  type GetSubProjectStatusTypeGroupByPayload<T extends SubProjectStatusTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubProjectStatusTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubProjectStatusTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubProjectStatusTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SubProjectStatusTypeGroupByOutputType[P]>
        }
      >
    >


  export type SubProjectStatusTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub_project_status_id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["subProjectStatusType"]>

  export type SubProjectStatusTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub_project_status_id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["subProjectStatusType"]>

  export type SubProjectStatusTypeSelectScalar = {
    sub_project_status_id?: boolean
    name?: boolean
    created_at?: boolean
  }


  export type $SubProjectStatusTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubProjectStatusType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sub_project_status_id: number
      name: string
      created_at: Date
    }, ExtArgs["result"]["subProjectStatusType"]>
    composites: {}
  }

  type SubProjectStatusTypeGetPayload<S extends boolean | null | undefined | SubProjectStatusTypeDefaultArgs> = $Result.GetResult<Prisma.$SubProjectStatusTypePayload, S>

  type SubProjectStatusTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubProjectStatusTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubProjectStatusTypeCountAggregateInputType | true
    }

  export interface SubProjectStatusTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubProjectStatusType'], meta: { name: 'SubProjectStatusType' } }
    /**
     * Find zero or one SubProjectStatusType that matches the filter.
     * @param {SubProjectStatusTypeFindUniqueArgs} args - Arguments to find a SubProjectStatusType
     * @example
     * // Get one SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubProjectStatusTypeFindUniqueArgs>(args: SelectSubset<T, SubProjectStatusTypeFindUniqueArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubProjectStatusType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubProjectStatusTypeFindUniqueOrThrowArgs} args - Arguments to find a SubProjectStatusType
     * @example
     * // Get one SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubProjectStatusTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SubProjectStatusTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubProjectStatusType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeFindFirstArgs} args - Arguments to find a SubProjectStatusType
     * @example
     * // Get one SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubProjectStatusTypeFindFirstArgs>(args?: SelectSubset<T, SubProjectStatusTypeFindFirstArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubProjectStatusType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeFindFirstOrThrowArgs} args - Arguments to find a SubProjectStatusType
     * @example
     * // Get one SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubProjectStatusTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SubProjectStatusTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubProjectStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubProjectStatusTypes
     * const subProjectStatusTypes = await prisma.subProjectStatusType.findMany()
     * 
     * // Get first 10 SubProjectStatusTypes
     * const subProjectStatusTypes = await prisma.subProjectStatusType.findMany({ take: 10 })
     * 
     * // Only select the `sub_project_status_id`
     * const subProjectStatusTypeWithSub_project_status_idOnly = await prisma.subProjectStatusType.findMany({ select: { sub_project_status_id: true } })
     * 
     */
    findMany<T extends SubProjectStatusTypeFindManyArgs>(args?: SelectSubset<T, SubProjectStatusTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubProjectStatusType.
     * @param {SubProjectStatusTypeCreateArgs} args - Arguments to create a SubProjectStatusType.
     * @example
     * // Create one SubProjectStatusType
     * const SubProjectStatusType = await prisma.subProjectStatusType.create({
     *   data: {
     *     // ... data to create a SubProjectStatusType
     *   }
     * })
     * 
     */
    create<T extends SubProjectStatusTypeCreateArgs>(args: SelectSubset<T, SubProjectStatusTypeCreateArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubProjectStatusTypes.
     * @param {SubProjectStatusTypeCreateManyArgs} args - Arguments to create many SubProjectStatusTypes.
     * @example
     * // Create many SubProjectStatusTypes
     * const subProjectStatusType = await prisma.subProjectStatusType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubProjectStatusTypeCreateManyArgs>(args?: SelectSubset<T, SubProjectStatusTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubProjectStatusTypes and returns the data saved in the database.
     * @param {SubProjectStatusTypeCreateManyAndReturnArgs} args - Arguments to create many SubProjectStatusTypes.
     * @example
     * // Create many SubProjectStatusTypes
     * const subProjectStatusType = await prisma.subProjectStatusType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubProjectStatusTypes and only return the `sub_project_status_id`
     * const subProjectStatusTypeWithSub_project_status_idOnly = await prisma.subProjectStatusType.createManyAndReturn({ 
     *   select: { sub_project_status_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubProjectStatusTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SubProjectStatusTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubProjectStatusType.
     * @param {SubProjectStatusTypeDeleteArgs} args - Arguments to delete one SubProjectStatusType.
     * @example
     * // Delete one SubProjectStatusType
     * const SubProjectStatusType = await prisma.subProjectStatusType.delete({
     *   where: {
     *     // ... filter to delete one SubProjectStatusType
     *   }
     * })
     * 
     */
    delete<T extends SubProjectStatusTypeDeleteArgs>(args: SelectSubset<T, SubProjectStatusTypeDeleteArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubProjectStatusType.
     * @param {SubProjectStatusTypeUpdateArgs} args - Arguments to update one SubProjectStatusType.
     * @example
     * // Update one SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubProjectStatusTypeUpdateArgs>(args: SelectSubset<T, SubProjectStatusTypeUpdateArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubProjectStatusTypes.
     * @param {SubProjectStatusTypeDeleteManyArgs} args - Arguments to filter SubProjectStatusTypes to delete.
     * @example
     * // Delete a few SubProjectStatusTypes
     * const { count } = await prisma.subProjectStatusType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubProjectStatusTypeDeleteManyArgs>(args?: SelectSubset<T, SubProjectStatusTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubProjectStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubProjectStatusTypes
     * const subProjectStatusType = await prisma.subProjectStatusType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubProjectStatusTypeUpdateManyArgs>(args: SelectSubset<T, SubProjectStatusTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubProjectStatusType.
     * @param {SubProjectStatusTypeUpsertArgs} args - Arguments to update or create a SubProjectStatusType.
     * @example
     * // Update or create a SubProjectStatusType
     * const subProjectStatusType = await prisma.subProjectStatusType.upsert({
     *   create: {
     *     // ... data to create a SubProjectStatusType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubProjectStatusType we want to update
     *   }
     * })
     */
    upsert<T extends SubProjectStatusTypeUpsertArgs>(args: SelectSubset<T, SubProjectStatusTypeUpsertArgs<ExtArgs>>): Prisma__SubProjectStatusTypeClient<$Result.GetResult<Prisma.$SubProjectStatusTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubProjectStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeCountArgs} args - Arguments to filter SubProjectStatusTypes to count.
     * @example
     * // Count the number of SubProjectStatusTypes
     * const count = await prisma.subProjectStatusType.count({
     *   where: {
     *     // ... the filter for the SubProjectStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends SubProjectStatusTypeCountArgs>(
      args?: Subset<T, SubProjectStatusTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubProjectStatusTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubProjectStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubProjectStatusTypeAggregateArgs>(args: Subset<T, SubProjectStatusTypeAggregateArgs>): Prisma.PrismaPromise<GetSubProjectStatusTypeAggregateType<T>>

    /**
     * Group by SubProjectStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectStatusTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubProjectStatusTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubProjectStatusTypeGroupByArgs['orderBy'] }
        : { orderBy?: SubProjectStatusTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubProjectStatusTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubProjectStatusTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubProjectStatusType model
   */
  readonly fields: SubProjectStatusTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubProjectStatusType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubProjectStatusTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubProjectStatusType model
   */ 
  interface SubProjectStatusTypeFieldRefs {
    readonly sub_project_status_id: FieldRef<"SubProjectStatusType", 'Int'>
    readonly name: FieldRef<"SubProjectStatusType", 'String'>
    readonly created_at: FieldRef<"SubProjectStatusType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubProjectStatusType findUnique
   */
  export type SubProjectStatusTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter, which SubProjectStatusType to fetch.
     */
    where: SubProjectStatusTypeWhereUniqueInput
  }

  /**
   * SubProjectStatusType findUniqueOrThrow
   */
  export type SubProjectStatusTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter, which SubProjectStatusType to fetch.
     */
    where: SubProjectStatusTypeWhereUniqueInput
  }

  /**
   * SubProjectStatusType findFirst
   */
  export type SubProjectStatusTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter, which SubProjectStatusType to fetch.
     */
    where?: SubProjectStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectStatusTypes to fetch.
     */
    orderBy?: SubProjectStatusTypeOrderByWithRelationInput | SubProjectStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectStatusTypes.
     */
    cursor?: SubProjectStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectStatusTypes.
     */
    distinct?: SubProjectStatusTypeScalarFieldEnum | SubProjectStatusTypeScalarFieldEnum[]
  }

  /**
   * SubProjectStatusType findFirstOrThrow
   */
  export type SubProjectStatusTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter, which SubProjectStatusType to fetch.
     */
    where?: SubProjectStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectStatusTypes to fetch.
     */
    orderBy?: SubProjectStatusTypeOrderByWithRelationInput | SubProjectStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectStatusTypes.
     */
    cursor?: SubProjectStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectStatusTypes.
     */
    distinct?: SubProjectStatusTypeScalarFieldEnum | SubProjectStatusTypeScalarFieldEnum[]
  }

  /**
   * SubProjectStatusType findMany
   */
  export type SubProjectStatusTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter, which SubProjectStatusTypes to fetch.
     */
    where?: SubProjectStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectStatusTypes to fetch.
     */
    orderBy?: SubProjectStatusTypeOrderByWithRelationInput | SubProjectStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubProjectStatusTypes.
     */
    cursor?: SubProjectStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectStatusTypes.
     */
    skip?: number
    distinct?: SubProjectStatusTypeScalarFieldEnum | SubProjectStatusTypeScalarFieldEnum[]
  }

  /**
   * SubProjectStatusType create
   */
  export type SubProjectStatusTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a SubProjectStatusType.
     */
    data: XOR<SubProjectStatusTypeCreateInput, SubProjectStatusTypeUncheckedCreateInput>
  }

  /**
   * SubProjectStatusType createMany
   */
  export type SubProjectStatusTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubProjectStatusTypes.
     */
    data: SubProjectStatusTypeCreateManyInput | SubProjectStatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProjectStatusType createManyAndReturn
   */
  export type SubProjectStatusTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubProjectStatusTypes.
     */
    data: SubProjectStatusTypeCreateManyInput | SubProjectStatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProjectStatusType update
   */
  export type SubProjectStatusTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a SubProjectStatusType.
     */
    data: XOR<SubProjectStatusTypeUpdateInput, SubProjectStatusTypeUncheckedUpdateInput>
    /**
     * Choose, which SubProjectStatusType to update.
     */
    where: SubProjectStatusTypeWhereUniqueInput
  }

  /**
   * SubProjectStatusType updateMany
   */
  export type SubProjectStatusTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubProjectStatusTypes.
     */
    data: XOR<SubProjectStatusTypeUpdateManyMutationInput, SubProjectStatusTypeUncheckedUpdateManyInput>
    /**
     * Filter which SubProjectStatusTypes to update
     */
    where?: SubProjectStatusTypeWhereInput
  }

  /**
   * SubProjectStatusType upsert
   */
  export type SubProjectStatusTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the SubProjectStatusType to update in case it exists.
     */
    where: SubProjectStatusTypeWhereUniqueInput
    /**
     * In case the SubProjectStatusType found by the `where` argument doesn't exist, create a new SubProjectStatusType with this data.
     */
    create: XOR<SubProjectStatusTypeCreateInput, SubProjectStatusTypeUncheckedCreateInput>
    /**
     * In case the SubProjectStatusType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubProjectStatusTypeUpdateInput, SubProjectStatusTypeUncheckedUpdateInput>
  }

  /**
   * SubProjectStatusType delete
   */
  export type SubProjectStatusTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
    /**
     * Filter which SubProjectStatusType to delete.
     */
    where: SubProjectStatusTypeWhereUniqueInput
  }

  /**
   * SubProjectStatusType deleteMany
   */
  export type SubProjectStatusTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectStatusTypes to delete
     */
    where?: SubProjectStatusTypeWhereInput
  }

  /**
   * SubProjectStatusType without action
   */
  export type SubProjectStatusTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectStatusType
     */
    select?: SubProjectStatusTypeSelect<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    project_id: number | null
    main_responsible_manager_id: number | null
    counterparty_id: number | null
    funnel_id: number | null
    funnel_stage_id: number | null
    forecast_amount: Decimal | null
  }

  export type ProjectSumAggregateOutputType = {
    project_id: number | null
    main_responsible_manager_id: number | null
    counterparty_id: number | null
    funnel_id: number | null
    funnel_stage_id: number | null
    forecast_amount: Decimal | null
  }

  export type ProjectMinAggregateOutputType = {
    project_id: number | null
    name: string | null
    description: string | null
    main_responsible_manager_id: number | null
    counterparty_id: number | null
    funnel_id: number | null
    funnel_stage_id: number | null
    forecast_amount: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    project_id: number | null
    name: string | null
    description: string | null
    main_responsible_manager_id: number | null
    counterparty_id: number | null
    funnel_id: number | null
    funnel_stage_id: number | null
    forecast_amount: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    project_id: number
    name: number
    description: number
    main_responsible_manager_id: number
    counterparty_id: number
    funnel_id: number
    funnel_stage_id: number
    forecast_amount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    project_id?: true
    main_responsible_manager_id?: true
    counterparty_id?: true
    funnel_id?: true
    funnel_stage_id?: true
    forecast_amount?: true
  }

  export type ProjectSumAggregateInputType = {
    project_id?: true
    main_responsible_manager_id?: true
    counterparty_id?: true
    funnel_id?: true
    funnel_stage_id?: true
    forecast_amount?: true
  }

  export type ProjectMinAggregateInputType = {
    project_id?: true
    name?: true
    description?: true
    main_responsible_manager_id?: true
    counterparty_id?: true
    funnel_id?: true
    funnel_stage_id?: true
    forecast_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectMaxAggregateInputType = {
    project_id?: true
    name?: true
    description?: true
    main_responsible_manager_id?: true
    counterparty_id?: true
    funnel_id?: true
    funnel_stage_id?: true
    forecast_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectCountAggregateInputType = {
    project_id?: true
    name?: true
    description?: true
    main_responsible_manager_id?: true
    counterparty_id?: true
    funnel_id?: true
    funnel_stage_id?: true
    forecast_amount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    project_id: number
    name: string
    description: string | null
    main_responsible_manager_id: number | null
    counterparty_id: number | null
    funnel_id: number | null
    funnel_stage_id: number | null
    forecast_amount: Decimal
    created_at: Date
    updated_at: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_id?: boolean
    name?: boolean
    description?: boolean
    main_responsible_manager_id?: boolean
    counterparty_id?: boolean
    funnel_id?: boolean
    funnel_stage_id?: boolean
    forecast_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    main_responsible_manager?: boolean | Project$main_responsible_managerArgs<ExtArgs>
    secondary_responsible_managers?: boolean | Project$secondary_responsible_managersArgs<ExtArgs>
    counterparty?: boolean | Project$counterpartyArgs<ExtArgs>
    funnel?: boolean | Project$funnelArgs<ExtArgs>
    funnel_stage?: boolean | Project$funnel_stageArgs<ExtArgs>
    subprojects?: boolean | Project$subprojectsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    sales?: boolean | Project$salesArgs<ExtArgs>
    products?: boolean | Project$productsArgs<ExtArgs>
    services?: boolean | Project$servicesArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_id?: boolean
    name?: boolean
    description?: boolean
    main_responsible_manager_id?: boolean
    counterparty_id?: boolean
    funnel_id?: boolean
    funnel_stage_id?: boolean
    forecast_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    main_responsible_manager?: boolean | Project$main_responsible_managerArgs<ExtArgs>
    counterparty?: boolean | Project$counterpartyArgs<ExtArgs>
    funnel?: boolean | Project$funnelArgs<ExtArgs>
    funnel_stage?: boolean | Project$funnel_stageArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    project_id?: boolean
    name?: boolean
    description?: boolean
    main_responsible_manager_id?: boolean
    counterparty_id?: boolean
    funnel_id?: boolean
    funnel_stage_id?: boolean
    forecast_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    main_responsible_manager?: boolean | Project$main_responsible_managerArgs<ExtArgs>
    secondary_responsible_managers?: boolean | Project$secondary_responsible_managersArgs<ExtArgs>
    counterparty?: boolean | Project$counterpartyArgs<ExtArgs>
    funnel?: boolean | Project$funnelArgs<ExtArgs>
    funnel_stage?: boolean | Project$funnel_stageArgs<ExtArgs>
    subprojects?: boolean | Project$subprojectsArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    sales?: boolean | Project$salesArgs<ExtArgs>
    products?: boolean | Project$productsArgs<ExtArgs>
    services?: boolean | Project$servicesArgs<ExtArgs>
    comments?: boolean | Project$commentsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    main_responsible_manager?: boolean | Project$main_responsible_managerArgs<ExtArgs>
    counterparty?: boolean | Project$counterpartyArgs<ExtArgs>
    funnel?: boolean | Project$funnelArgs<ExtArgs>
    funnel_stage?: boolean | Project$funnel_stageArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      main_responsible_manager: Prisma.$ManagerPayload<ExtArgs> | null
      secondary_responsible_managers: Prisma.$ProjectManagerPayload<ExtArgs>[]
      counterparty: Prisma.$CounterpartyPayload<ExtArgs> | null
      funnel: Prisma.$FunnelPayload<ExtArgs> | null
      funnel_stage: Prisma.$FunnelStagePayload<ExtArgs> | null
      subprojects: Prisma.$SubProjectPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      products: Prisma.$ProjectProductPayload<ExtArgs>[]
      services: Prisma.$ProjectServicePayload<ExtArgs>[]
      comments: Prisma.$ProjectCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      project_id: number
      name: string
      description: string | null
      main_responsible_manager_id: number | null
      counterparty_id: number | null
      funnel_id: number | null
      funnel_stage_id: number | null
      forecast_amount: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `project_id`
     * const projectWithProject_idOnly = await prisma.project.findMany({ select: { project_id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `project_id`
     * const projectWithProject_idOnly = await prisma.project.createManyAndReturn({ 
     *   select: { project_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    main_responsible_manager<T extends Project$main_responsible_managerArgs<ExtArgs> = {}>(args?: Subset<T, Project$main_responsible_managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    secondary_responsible_managers<T extends Project$secondary_responsible_managersArgs<ExtArgs> = {}>(args?: Subset<T, Project$secondary_responsible_managersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findMany"> | Null>
    counterparty<T extends Project$counterpartyArgs<ExtArgs> = {}>(args?: Subset<T, Project$counterpartyArgs<ExtArgs>>): Prisma__CounterpartyClient<$Result.GetResult<Prisma.$CounterpartyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    funnel<T extends Project$funnelArgs<ExtArgs> = {}>(args?: Subset<T, Project$funnelArgs<ExtArgs>>): Prisma__FunnelClient<$Result.GetResult<Prisma.$FunnelPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    funnel_stage<T extends Project$funnel_stageArgs<ExtArgs> = {}>(args?: Subset<T, Project$funnel_stageArgs<ExtArgs>>): Prisma__FunnelStageClient<$Result.GetResult<Prisma.$FunnelStagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subprojects<T extends Project$subprojectsArgs<ExtArgs> = {}>(args?: Subset<T, Project$subprojectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    sales<T extends Project$salesArgs<ExtArgs> = {}>(args?: Subset<T, Project$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Project$productsArgs<ExtArgs> = {}>(args?: Subset<T, Project$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends Project$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Project$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Project$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly project_id: FieldRef<"Project", 'Int'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly main_responsible_manager_id: FieldRef<"Project", 'Int'>
    readonly counterparty_id: FieldRef<"Project", 'Int'>
    readonly funnel_id: FieldRef<"Project", 'Int'>
    readonly funnel_stage_id: FieldRef<"Project", 'Int'>
    readonly forecast_amount: FieldRef<"Project", 'Decimal'>
    readonly created_at: FieldRef<"Project", 'DateTime'>
    readonly updated_at: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.main_responsible_manager
   */
  export type Project$main_responsible_managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Project.secondary_responsible_managers
   */
  export type Project$secondary_responsible_managersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    where?: ProjectManagerWhereInput
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    cursor?: ProjectManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectManagerScalarFieldEnum | ProjectManagerScalarFieldEnum[]
  }

  /**
   * Project.counterparty
   */
  export type Project$counterpartyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Counterparty
     */
    select?: CounterpartySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CounterpartyInclude<ExtArgs> | null
    where?: CounterpartyWhereInput
  }

  /**
   * Project.funnel
   */
  export type Project$funnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnel
     */
    select?: FunnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelInclude<ExtArgs> | null
    where?: FunnelWhereInput
  }

  /**
   * Project.funnel_stage
   */
  export type Project$funnel_stageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelStage
     */
    select?: FunnelStageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelStageInclude<ExtArgs> | null
    where?: FunnelStageWhereInput
  }

  /**
   * Project.subprojects
   */
  export type Project$subprojectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    where?: SubProjectWhereInput
    orderBy?: SubProjectOrderByWithRelationInput | SubProjectOrderByWithRelationInput[]
    cursor?: SubProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectScalarFieldEnum | SubProjectScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.sales
   */
  export type Project$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Project.products
   */
  export type Project$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    where?: ProjectProductWhereInput
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    cursor?: ProjectProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectProductScalarFieldEnum | ProjectProductScalarFieldEnum[]
  }

  /**
   * Project.services
   */
  export type Project$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    where?: ProjectServiceWhereInput
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    cursor?: ProjectServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectServiceScalarFieldEnum | ProjectServiceScalarFieldEnum[]
  }

  /**
   * Project.comments
   */
  export type Project$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    where?: ProjectCommentWhereInput
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    cursor?: ProjectCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectCommentScalarFieldEnum | ProjectCommentScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectManager
   */

  export type AggregateProjectManager = {
    _count: ProjectManagerCountAggregateOutputType | null
    _avg: ProjectManagerAvgAggregateOutputType | null
    _sum: ProjectManagerSumAggregateOutputType | null
    _min: ProjectManagerMinAggregateOutputType | null
    _max: ProjectManagerMaxAggregateOutputType | null
  }

  export type ProjectManagerAvgAggregateOutputType = {
    project_id: number | null
    manager_id: number | null
  }

  export type ProjectManagerSumAggregateOutputType = {
    project_id: number | null
    manager_id: number | null
  }

  export type ProjectManagerMinAggregateOutputType = {
    project_id: number | null
    manager_id: number | null
    created_at: Date | null
  }

  export type ProjectManagerMaxAggregateOutputType = {
    project_id: number | null
    manager_id: number | null
    created_at: Date | null
  }

  export type ProjectManagerCountAggregateOutputType = {
    project_id: number
    manager_id: number
    created_at: number
    _all: number
  }


  export type ProjectManagerAvgAggregateInputType = {
    project_id?: true
    manager_id?: true
  }

  export type ProjectManagerSumAggregateInputType = {
    project_id?: true
    manager_id?: true
  }

  export type ProjectManagerMinAggregateInputType = {
    project_id?: true
    manager_id?: true
    created_at?: true
  }

  export type ProjectManagerMaxAggregateInputType = {
    project_id?: true
    manager_id?: true
    created_at?: true
  }

  export type ProjectManagerCountAggregateInputType = {
    project_id?: true
    manager_id?: true
    created_at?: true
    _all?: true
  }

  export type ProjectManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectManager to aggregate.
     */
    where?: ProjectManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectManagers to fetch.
     */
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectManagers
    **/
    _count?: true | ProjectManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectManagerMaxAggregateInputType
  }

  export type GetProjectManagerAggregateType<T extends ProjectManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectManager[P]>
      : GetScalarType<T[P], AggregateProjectManager[P]>
  }




  export type ProjectManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectManagerWhereInput
    orderBy?: ProjectManagerOrderByWithAggregationInput | ProjectManagerOrderByWithAggregationInput[]
    by: ProjectManagerScalarFieldEnum[] | ProjectManagerScalarFieldEnum
    having?: ProjectManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectManagerCountAggregateInputType | true
    _avg?: ProjectManagerAvgAggregateInputType
    _sum?: ProjectManagerSumAggregateInputType
    _min?: ProjectManagerMinAggregateInputType
    _max?: ProjectManagerMaxAggregateInputType
  }

  export type ProjectManagerGroupByOutputType = {
    project_id: number
    manager_id: number
    created_at: Date
    _count: ProjectManagerCountAggregateOutputType | null
    _avg: ProjectManagerAvgAggregateOutputType | null
    _sum: ProjectManagerSumAggregateOutputType | null
    _min: ProjectManagerMinAggregateOutputType | null
    _max: ProjectManagerMaxAggregateOutputType | null
  }

  type GetProjectManagerGroupByPayload<T extends ProjectManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectManagerGroupByOutputType[P]>
        }
      >
    >


  export type ProjectManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_id?: boolean
    manager_id?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectManager"]>

  export type ProjectManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_id?: boolean
    manager_id?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectManager"]>

  export type ProjectManagerSelectScalar = {
    project_id?: boolean
    manager_id?: boolean
    created_at?: boolean
  }

  export type ProjectManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type ProjectManagerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }

  export type $ProjectManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectManager"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      manager: Prisma.$ManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      project_id: number
      manager_id: number
      created_at: Date
    }, ExtArgs["result"]["projectManager"]>
    composites: {}
  }

  type ProjectManagerGetPayload<S extends boolean | null | undefined | ProjectManagerDefaultArgs> = $Result.GetResult<Prisma.$ProjectManagerPayload, S>

  type ProjectManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectManagerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectManagerCountAggregateInputType | true
    }

  export interface ProjectManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectManager'], meta: { name: 'ProjectManager' } }
    /**
     * Find zero or one ProjectManager that matches the filter.
     * @param {ProjectManagerFindUniqueArgs} args - Arguments to find a ProjectManager
     * @example
     * // Get one ProjectManager
     * const projectManager = await prisma.projectManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectManagerFindUniqueArgs>(args: SelectSubset<T, ProjectManagerFindUniqueArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectManager that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectManagerFindUniqueOrThrowArgs} args - Arguments to find a ProjectManager
     * @example
     * // Get one ProjectManager
     * const projectManager = await prisma.projectManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerFindFirstArgs} args - Arguments to find a ProjectManager
     * @example
     * // Get one ProjectManager
     * const projectManager = await prisma.projectManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectManagerFindFirstArgs>(args?: SelectSubset<T, ProjectManagerFindFirstArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerFindFirstOrThrowArgs} args - Arguments to find a ProjectManager
     * @example
     * // Get one ProjectManager
     * const projectManager = await prisma.projectManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectManagers
     * const projectManagers = await prisma.projectManager.findMany()
     * 
     * // Get first 10 ProjectManagers
     * const projectManagers = await prisma.projectManager.findMany({ take: 10 })
     * 
     * // Only select the `project_id`
     * const projectManagerWithProject_idOnly = await prisma.projectManager.findMany({ select: { project_id: true } })
     * 
     */
    findMany<T extends ProjectManagerFindManyArgs>(args?: SelectSubset<T, ProjectManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectManager.
     * @param {ProjectManagerCreateArgs} args - Arguments to create a ProjectManager.
     * @example
     * // Create one ProjectManager
     * const ProjectManager = await prisma.projectManager.create({
     *   data: {
     *     // ... data to create a ProjectManager
     *   }
     * })
     * 
     */
    create<T extends ProjectManagerCreateArgs>(args: SelectSubset<T, ProjectManagerCreateArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectManagers.
     * @param {ProjectManagerCreateManyArgs} args - Arguments to create many ProjectManagers.
     * @example
     * // Create many ProjectManagers
     * const projectManager = await prisma.projectManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectManagerCreateManyArgs>(args?: SelectSubset<T, ProjectManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectManagers and returns the data saved in the database.
     * @param {ProjectManagerCreateManyAndReturnArgs} args - Arguments to create many ProjectManagers.
     * @example
     * // Create many ProjectManagers
     * const projectManager = await prisma.projectManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectManagers and only return the `project_id`
     * const projectManagerWithProject_idOnly = await prisma.projectManager.createManyAndReturn({ 
     *   select: { project_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectManager.
     * @param {ProjectManagerDeleteArgs} args - Arguments to delete one ProjectManager.
     * @example
     * // Delete one ProjectManager
     * const ProjectManager = await prisma.projectManager.delete({
     *   where: {
     *     // ... filter to delete one ProjectManager
     *   }
     * })
     * 
     */
    delete<T extends ProjectManagerDeleteArgs>(args: SelectSubset<T, ProjectManagerDeleteArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectManager.
     * @param {ProjectManagerUpdateArgs} args - Arguments to update one ProjectManager.
     * @example
     * // Update one ProjectManager
     * const projectManager = await prisma.projectManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectManagerUpdateArgs>(args: SelectSubset<T, ProjectManagerUpdateArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectManagers.
     * @param {ProjectManagerDeleteManyArgs} args - Arguments to filter ProjectManagers to delete.
     * @example
     * // Delete a few ProjectManagers
     * const { count } = await prisma.projectManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectManagerDeleteManyArgs>(args?: SelectSubset<T, ProjectManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectManagers
     * const projectManager = await prisma.projectManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectManagerUpdateManyArgs>(args: SelectSubset<T, ProjectManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectManager.
     * @param {ProjectManagerUpsertArgs} args - Arguments to update or create a ProjectManager.
     * @example
     * // Update or create a ProjectManager
     * const projectManager = await prisma.projectManager.upsert({
     *   create: {
     *     // ... data to create a ProjectManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectManager we want to update
     *   }
     * })
     */
    upsert<T extends ProjectManagerUpsertArgs>(args: SelectSubset<T, ProjectManagerUpsertArgs<ExtArgs>>): Prisma__ProjectManagerClient<$Result.GetResult<Prisma.$ProjectManagerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerCountArgs} args - Arguments to filter ProjectManagers to count.
     * @example
     * // Count the number of ProjectManagers
     * const count = await prisma.projectManager.count({
     *   where: {
     *     // ... the filter for the ProjectManagers we want to count
     *   }
     * })
    **/
    count<T extends ProjectManagerCountArgs>(
      args?: Subset<T, ProjectManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectManagerAggregateArgs>(args: Subset<T, ProjectManagerAggregateArgs>): Prisma.PrismaPromise<GetProjectManagerAggregateType<T>>

    /**
     * Group by ProjectManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectManagerGroupByArgs['orderBy'] }
        : { orderBy?: ProjectManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectManager model
   */
  readonly fields: ProjectManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectManager model
   */ 
  interface ProjectManagerFieldRefs {
    readonly project_id: FieldRef<"ProjectManager", 'Int'>
    readonly manager_id: FieldRef<"ProjectManager", 'Int'>
    readonly created_at: FieldRef<"ProjectManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectManager findUnique
   */
  export type ProjectManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter, which ProjectManager to fetch.
     */
    where: ProjectManagerWhereUniqueInput
  }

  /**
   * ProjectManager findUniqueOrThrow
   */
  export type ProjectManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter, which ProjectManager to fetch.
     */
    where: ProjectManagerWhereUniqueInput
  }

  /**
   * ProjectManager findFirst
   */
  export type ProjectManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter, which ProjectManager to fetch.
     */
    where?: ProjectManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectManagers to fetch.
     */
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectManagers.
     */
    cursor?: ProjectManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectManagers.
     */
    distinct?: ProjectManagerScalarFieldEnum | ProjectManagerScalarFieldEnum[]
  }

  /**
   * ProjectManager findFirstOrThrow
   */
  export type ProjectManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter, which ProjectManager to fetch.
     */
    where?: ProjectManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectManagers to fetch.
     */
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectManagers.
     */
    cursor?: ProjectManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectManagers.
     */
    distinct?: ProjectManagerScalarFieldEnum | ProjectManagerScalarFieldEnum[]
  }

  /**
   * ProjectManager findMany
   */
  export type ProjectManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter, which ProjectManagers to fetch.
     */
    where?: ProjectManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectManagers to fetch.
     */
    orderBy?: ProjectManagerOrderByWithRelationInput | ProjectManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectManagers.
     */
    cursor?: ProjectManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectManagers.
     */
    skip?: number
    distinct?: ProjectManagerScalarFieldEnum | ProjectManagerScalarFieldEnum[]
  }

  /**
   * ProjectManager create
   */
  export type ProjectManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectManager.
     */
    data: XOR<ProjectManagerCreateInput, ProjectManagerUncheckedCreateInput>
  }

  /**
   * ProjectManager createMany
   */
  export type ProjectManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectManagers.
     */
    data: ProjectManagerCreateManyInput | ProjectManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectManager createManyAndReturn
   */
  export type ProjectManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectManagers.
     */
    data: ProjectManagerCreateManyInput | ProjectManagerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectManager update
   */
  export type ProjectManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectManager.
     */
    data: XOR<ProjectManagerUpdateInput, ProjectManagerUncheckedUpdateInput>
    /**
     * Choose, which ProjectManager to update.
     */
    where: ProjectManagerWhereUniqueInput
  }

  /**
   * ProjectManager updateMany
   */
  export type ProjectManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectManagers.
     */
    data: XOR<ProjectManagerUpdateManyMutationInput, ProjectManagerUncheckedUpdateManyInput>
    /**
     * Filter which ProjectManagers to update
     */
    where?: ProjectManagerWhereInput
  }

  /**
   * ProjectManager upsert
   */
  export type ProjectManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectManager to update in case it exists.
     */
    where: ProjectManagerWhereUniqueInput
    /**
     * In case the ProjectManager found by the `where` argument doesn't exist, create a new ProjectManager with this data.
     */
    create: XOR<ProjectManagerCreateInput, ProjectManagerUncheckedCreateInput>
    /**
     * In case the ProjectManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectManagerUpdateInput, ProjectManagerUncheckedUpdateInput>
  }

  /**
   * ProjectManager delete
   */
  export type ProjectManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
    /**
     * Filter which ProjectManager to delete.
     */
    where: ProjectManagerWhereUniqueInput
  }

  /**
   * ProjectManager deleteMany
   */
  export type ProjectManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectManagers to delete
     */
    where?: ProjectManagerWhereInput
  }

  /**
   * ProjectManager without action
   */
  export type ProjectManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectManager
     */
    select?: ProjectManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectManagerInclude<ExtArgs> | null
  }


  /**
   * Model SubProject
   */

  export type AggregateSubProject = {
    _count: SubProjectCountAggregateOutputType | null
    _avg: SubProjectAvgAggregateOutputType | null
    _sum: SubProjectSumAggregateOutputType | null
    _min: SubProjectMinAggregateOutputType | null
    _max: SubProjectMaxAggregateOutputType | null
  }

  export type SubProjectAvgAggregateOutputType = {
    subproject_id: number | null
    project_id: number | null
    cost: Decimal | null
  }

  export type SubProjectSumAggregateOutputType = {
    subproject_id: number | null
    project_id: number | null
    cost: Decimal | null
  }

  export type SubProjectMinAggregateOutputType = {
    subproject_id: number | null
    name: string | null
    description: string | null
    project_id: number | null
    status: string | null
    cost: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubProjectMaxAggregateOutputType = {
    subproject_id: number | null
    name: string | null
    description: string | null
    project_id: number | null
    status: string | null
    cost: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubProjectCountAggregateOutputType = {
    subproject_id: number
    name: number
    description: number
    project_id: number
    status: number
    cost: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubProjectAvgAggregateInputType = {
    subproject_id?: true
    project_id?: true
    cost?: true
  }

  export type SubProjectSumAggregateInputType = {
    subproject_id?: true
    project_id?: true
    cost?: true
  }

  export type SubProjectMinAggregateInputType = {
    subproject_id?: true
    name?: true
    description?: true
    project_id?: true
    status?: true
    cost?: true
    created_at?: true
    updated_at?: true
  }

  export type SubProjectMaxAggregateInputType = {
    subproject_id?: true
    name?: true
    description?: true
    project_id?: true
    status?: true
    cost?: true
    created_at?: true
    updated_at?: true
  }

  export type SubProjectCountAggregateInputType = {
    subproject_id?: true
    name?: true
    description?: true
    project_id?: true
    status?: true
    cost?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProject to aggregate.
     */
    where?: SubProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjects to fetch.
     */
    orderBy?: SubProjectOrderByWithRelationInput | SubProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubProjects
    **/
    _count?: true | SubProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubProjectMaxAggregateInputType
  }

  export type GetSubProjectAggregateType<T extends SubProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubProject[P]>
      : GetScalarType<T[P], AggregateSubProject[P]>
  }




  export type SubProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectWhereInput
    orderBy?: SubProjectOrderByWithAggregationInput | SubProjectOrderByWithAggregationInput[]
    by: SubProjectScalarFieldEnum[] | SubProjectScalarFieldEnum
    having?: SubProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubProjectCountAggregateInputType | true
    _avg?: SubProjectAvgAggregateInputType
    _sum?: SubProjectSumAggregateInputType
    _min?: SubProjectMinAggregateInputType
    _max?: SubProjectMaxAggregateInputType
  }

  export type SubProjectGroupByOutputType = {
    subproject_id: number
    name: string
    description: string | null
    project_id: number
    status: string | null
    cost: Decimal
    created_at: Date
    updated_at: Date
    _count: SubProjectCountAggregateOutputType | null
    _avg: SubProjectAvgAggregateOutputType | null
    _sum: SubProjectSumAggregateOutputType | null
    _min: SubProjectMinAggregateOutputType | null
    _max: SubProjectMaxAggregateOutputType | null
  }

  type GetSubProjectGroupByPayload<T extends SubProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubProjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubProjectGroupByOutputType[P]>
        }
      >
    >


  export type SubProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_id?: boolean
    name?: boolean
    description?: boolean
    project_id?: boolean
    status?: boolean
    cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | SubProject$tasksArgs<ExtArgs>
    comments?: boolean | SubProject$commentsArgs<ExtArgs>
    products?: boolean | SubProject$productsArgs<ExtArgs>
    services?: boolean | SubProject$servicesArgs<ExtArgs>
    _count?: boolean | SubProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProject"]>

  export type SubProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_id?: boolean
    name?: boolean
    description?: boolean
    project_id?: boolean
    status?: boolean
    cost?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProject"]>

  export type SubProjectSelectScalar = {
    subproject_id?: boolean
    name?: boolean
    description?: boolean
    project_id?: boolean
    status?: boolean
    cost?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | SubProject$tasksArgs<ExtArgs>
    comments?: boolean | SubProject$commentsArgs<ExtArgs>
    products?: boolean | SubProject$productsArgs<ExtArgs>
    services?: boolean | SubProject$servicesArgs<ExtArgs>
    _count?: boolean | SubProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SubProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubProject"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      comments: Prisma.$SubProjectCommentPayload<ExtArgs>[]
      products: Prisma.$SubProjectProductPayload<ExtArgs>[]
      services: Prisma.$SubProjectServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subproject_id: number
      name: string
      description: string | null
      project_id: number
      status: string | null
      cost: Prisma.Decimal
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["subProject"]>
    composites: {}
  }

  type SubProjectGetPayload<S extends boolean | null | undefined | SubProjectDefaultArgs> = $Result.GetResult<Prisma.$SubProjectPayload, S>

  type SubProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubProjectCountAggregateInputType | true
    }

  export interface SubProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubProject'], meta: { name: 'SubProject' } }
    /**
     * Find zero or one SubProject that matches the filter.
     * @param {SubProjectFindUniqueArgs} args - Arguments to find a SubProject
     * @example
     * // Get one SubProject
     * const subProject = await prisma.subProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubProjectFindUniqueArgs>(args: SelectSubset<T, SubProjectFindUniqueArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubProjectFindUniqueOrThrowArgs} args - Arguments to find a SubProject
     * @example
     * // Get one SubProject
     * const subProject = await prisma.subProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectFindFirstArgs} args - Arguments to find a SubProject
     * @example
     * // Get one SubProject
     * const subProject = await prisma.subProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubProjectFindFirstArgs>(args?: SelectSubset<T, SubProjectFindFirstArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectFindFirstOrThrowArgs} args - Arguments to find a SubProject
     * @example
     * // Get one SubProject
     * const subProject = await prisma.subProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubProjects
     * const subProjects = await prisma.subProject.findMany()
     * 
     * // Get first 10 SubProjects
     * const subProjects = await prisma.subProject.findMany({ take: 10 })
     * 
     * // Only select the `subproject_id`
     * const subProjectWithSubproject_idOnly = await prisma.subProject.findMany({ select: { subproject_id: true } })
     * 
     */
    findMany<T extends SubProjectFindManyArgs>(args?: SelectSubset<T, SubProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubProject.
     * @param {SubProjectCreateArgs} args - Arguments to create a SubProject.
     * @example
     * // Create one SubProject
     * const SubProject = await prisma.subProject.create({
     *   data: {
     *     // ... data to create a SubProject
     *   }
     * })
     * 
     */
    create<T extends SubProjectCreateArgs>(args: SelectSubset<T, SubProjectCreateArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubProjects.
     * @param {SubProjectCreateManyArgs} args - Arguments to create many SubProjects.
     * @example
     * // Create many SubProjects
     * const subProject = await prisma.subProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubProjectCreateManyArgs>(args?: SelectSubset<T, SubProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubProjects and returns the data saved in the database.
     * @param {SubProjectCreateManyAndReturnArgs} args - Arguments to create many SubProjects.
     * @example
     * // Create many SubProjects
     * const subProject = await prisma.subProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubProjects and only return the `subproject_id`
     * const subProjectWithSubproject_idOnly = await prisma.subProject.createManyAndReturn({ 
     *   select: { subproject_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubProject.
     * @param {SubProjectDeleteArgs} args - Arguments to delete one SubProject.
     * @example
     * // Delete one SubProject
     * const SubProject = await prisma.subProject.delete({
     *   where: {
     *     // ... filter to delete one SubProject
     *   }
     * })
     * 
     */
    delete<T extends SubProjectDeleteArgs>(args: SelectSubset<T, SubProjectDeleteArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubProject.
     * @param {SubProjectUpdateArgs} args - Arguments to update one SubProject.
     * @example
     * // Update one SubProject
     * const subProject = await prisma.subProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubProjectUpdateArgs>(args: SelectSubset<T, SubProjectUpdateArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubProjects.
     * @param {SubProjectDeleteManyArgs} args - Arguments to filter SubProjects to delete.
     * @example
     * // Delete a few SubProjects
     * const { count } = await prisma.subProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubProjectDeleteManyArgs>(args?: SelectSubset<T, SubProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubProjects
     * const subProject = await prisma.subProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubProjectUpdateManyArgs>(args: SelectSubset<T, SubProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubProject.
     * @param {SubProjectUpsertArgs} args - Arguments to update or create a SubProject.
     * @example
     * // Update or create a SubProject
     * const subProject = await prisma.subProject.upsert({
     *   create: {
     *     // ... data to create a SubProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubProject we want to update
     *   }
     * })
     */
    upsert<T extends SubProjectUpsertArgs>(args: SelectSubset<T, SubProjectUpsertArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCountArgs} args - Arguments to filter SubProjects to count.
     * @example
     * // Count the number of SubProjects
     * const count = await prisma.subProject.count({
     *   where: {
     *     // ... the filter for the SubProjects we want to count
     *   }
     * })
    **/
    count<T extends SubProjectCountArgs>(
      args?: Subset<T, SubProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubProjectAggregateArgs>(args: Subset<T, SubProjectAggregateArgs>): Prisma.PrismaPromise<GetSubProjectAggregateType<T>>

    /**
     * Group by SubProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubProjectGroupByArgs['orderBy'] }
        : { orderBy?: SubProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubProject model
   */
  readonly fields: SubProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends SubProject$tasksArgs<ExtArgs> = {}>(args?: Subset<T, SubProject$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends SubProject$commentsArgs<ExtArgs> = {}>(args?: Subset<T, SubProject$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends SubProject$productsArgs<ExtArgs> = {}>(args?: Subset<T, SubProject$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findMany"> | Null>
    services<T extends SubProject$servicesArgs<ExtArgs> = {}>(args?: Subset<T, SubProject$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubProject model
   */ 
  interface SubProjectFieldRefs {
    readonly subproject_id: FieldRef<"SubProject", 'Int'>
    readonly name: FieldRef<"SubProject", 'String'>
    readonly description: FieldRef<"SubProject", 'String'>
    readonly project_id: FieldRef<"SubProject", 'Int'>
    readonly status: FieldRef<"SubProject", 'String'>
    readonly cost: FieldRef<"SubProject", 'Decimal'>
    readonly created_at: FieldRef<"SubProject", 'DateTime'>
    readonly updated_at: FieldRef<"SubProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubProject findUnique
   */
  export type SubProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter, which SubProject to fetch.
     */
    where: SubProjectWhereUniqueInput
  }

  /**
   * SubProject findUniqueOrThrow
   */
  export type SubProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter, which SubProject to fetch.
     */
    where: SubProjectWhereUniqueInput
  }

  /**
   * SubProject findFirst
   */
  export type SubProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter, which SubProject to fetch.
     */
    where?: SubProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjects to fetch.
     */
    orderBy?: SubProjectOrderByWithRelationInput | SubProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjects.
     */
    cursor?: SubProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjects.
     */
    distinct?: SubProjectScalarFieldEnum | SubProjectScalarFieldEnum[]
  }

  /**
   * SubProject findFirstOrThrow
   */
  export type SubProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter, which SubProject to fetch.
     */
    where?: SubProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjects to fetch.
     */
    orderBy?: SubProjectOrderByWithRelationInput | SubProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjects.
     */
    cursor?: SubProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjects.
     */
    distinct?: SubProjectScalarFieldEnum | SubProjectScalarFieldEnum[]
  }

  /**
   * SubProject findMany
   */
  export type SubProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter, which SubProjects to fetch.
     */
    where?: SubProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjects to fetch.
     */
    orderBy?: SubProjectOrderByWithRelationInput | SubProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubProjects.
     */
    cursor?: SubProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjects.
     */
    skip?: number
    distinct?: SubProjectScalarFieldEnum | SubProjectScalarFieldEnum[]
  }

  /**
   * SubProject create
   */
  export type SubProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a SubProject.
     */
    data: XOR<SubProjectCreateInput, SubProjectUncheckedCreateInput>
  }

  /**
   * SubProject createMany
   */
  export type SubProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubProjects.
     */
    data: SubProjectCreateManyInput | SubProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProject createManyAndReturn
   */
  export type SubProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubProjects.
     */
    data: SubProjectCreateManyInput | SubProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubProject update
   */
  export type SubProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a SubProject.
     */
    data: XOR<SubProjectUpdateInput, SubProjectUncheckedUpdateInput>
    /**
     * Choose, which SubProject to update.
     */
    where: SubProjectWhereUniqueInput
  }

  /**
   * SubProject updateMany
   */
  export type SubProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubProjects.
     */
    data: XOR<SubProjectUpdateManyMutationInput, SubProjectUncheckedUpdateManyInput>
    /**
     * Filter which SubProjects to update
     */
    where?: SubProjectWhereInput
  }

  /**
   * SubProject upsert
   */
  export type SubProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the SubProject to update in case it exists.
     */
    where: SubProjectWhereUniqueInput
    /**
     * In case the SubProject found by the `where` argument doesn't exist, create a new SubProject with this data.
     */
    create: XOR<SubProjectCreateInput, SubProjectUncheckedCreateInput>
    /**
     * In case the SubProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubProjectUpdateInput, SubProjectUncheckedUpdateInput>
  }

  /**
   * SubProject delete
   */
  export type SubProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    /**
     * Filter which SubProject to delete.
     */
    where: SubProjectWhereUniqueInput
  }

  /**
   * SubProject deleteMany
   */
  export type SubProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjects to delete
     */
    where?: SubProjectWhereInput
  }

  /**
   * SubProject.tasks
   */
  export type SubProject$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * SubProject.comments
   */
  export type SubProject$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    where?: SubProjectCommentWhereInput
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    cursor?: SubProjectCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectCommentScalarFieldEnum | SubProjectCommentScalarFieldEnum[]
  }

  /**
   * SubProject.products
   */
  export type SubProject$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    where?: SubProjectProductWhereInput
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    cursor?: SubProjectProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectProductScalarFieldEnum | SubProjectProductScalarFieldEnum[]
  }

  /**
   * SubProject.services
   */
  export type SubProject$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    where?: SubProjectServiceWhereInput
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    cursor?: SubProjectServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubProjectServiceScalarFieldEnum | SubProjectServiceScalarFieldEnum[]
  }

  /**
   * SubProject without action
   */
  export type SubProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    task_id: number | null
    responsible_manager_id: number | null
    creator_manager_id: number | null
    project_id: number | null
    subproject_id: number | null
  }

  export type TaskSumAggregateOutputType = {
    task_id: number | null
    responsible_manager_id: number | null
    creator_manager_id: number | null
    project_id: number | null
    subproject_id: number | null
  }

  export type TaskMinAggregateOutputType = {
    task_id: number | null
    title: string | null
    description: string | null
    responsible_manager_id: number | null
    creator_manager_id: number | null
    project_id: number | null
    subproject_id: number | null
    due_date: Date | null
    status: $Enums.TaskStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    task_id: number | null
    title: string | null
    description: string | null
    responsible_manager_id: number | null
    creator_manager_id: number | null
    project_id: number | null
    subproject_id: number | null
    due_date: Date | null
    status: $Enums.TaskStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaskCountAggregateOutputType = {
    task_id: number
    title: number
    description: number
    responsible_manager_id: number
    creator_manager_id: number
    project_id: number
    subproject_id: number
    due_date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    task_id?: true
    responsible_manager_id?: true
    creator_manager_id?: true
    project_id?: true
    subproject_id?: true
  }

  export type TaskSumAggregateInputType = {
    task_id?: true
    responsible_manager_id?: true
    creator_manager_id?: true
    project_id?: true
    subproject_id?: true
  }

  export type TaskMinAggregateInputType = {
    task_id?: true
    title?: true
    description?: true
    responsible_manager_id?: true
    creator_manager_id?: true
    project_id?: true
    subproject_id?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskMaxAggregateInputType = {
    task_id?: true
    title?: true
    description?: true
    responsible_manager_id?: true
    creator_manager_id?: true
    project_id?: true
    subproject_id?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type TaskCountAggregateInputType = {
    task_id?: true
    title?: true
    description?: true
    responsible_manager_id?: true
    creator_manager_id?: true
    project_id?: true
    subproject_id?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    task_id: number
    title: string
    description: string | null
    responsible_manager_id: number | null
    creator_manager_id: number | null
    project_id: number | null
    subproject_id: number | null
    due_date: Date | null
    status: $Enums.TaskStatus
    created_at: Date
    updated_at: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_id?: boolean
    title?: boolean
    description?: boolean
    responsible_manager_id?: boolean
    creator_manager_id?: boolean
    project_id?: boolean
    subproject_id?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_manager?: boolean | Task$responsible_managerArgs<ExtArgs>
    creator_manager?: boolean | Task$creator_managerArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    subproject?: boolean | Task$subprojectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_id?: boolean
    title?: boolean
    description?: boolean
    responsible_manager_id?: boolean
    creator_manager_id?: boolean
    project_id?: boolean
    subproject_id?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    responsible_manager?: boolean | Task$responsible_managerArgs<ExtArgs>
    creator_manager?: boolean | Task$creator_managerArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    subproject?: boolean | Task$subprojectArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    task_id?: boolean
    title?: boolean
    description?: boolean
    responsible_manager_id?: boolean
    creator_manager_id?: boolean
    project_id?: boolean
    subproject_id?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible_manager?: boolean | Task$responsible_managerArgs<ExtArgs>
    creator_manager?: boolean | Task$creator_managerArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    subproject?: boolean | Task$subprojectArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible_manager?: boolean | Task$responsible_managerArgs<ExtArgs>
    creator_manager?: boolean | Task$creator_managerArgs<ExtArgs>
    project?: boolean | Task$projectArgs<ExtArgs>
    subproject?: boolean | Task$subprojectArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      responsible_manager: Prisma.$ManagerPayload<ExtArgs> | null
      creator_manager: Prisma.$ManagerPayload<ExtArgs> | null
      project: Prisma.$ProjectPayload<ExtArgs> | null
      subproject: Prisma.$SubProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      task_id: number
      title: string
      description: string | null
      responsible_manager_id: number | null
      creator_manager_id: number | null
      project_id: number | null
      subproject_id: number | null
      due_date: Date | null
      status: $Enums.TaskStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `task_id`
     * const taskWithTask_idOnly = await prisma.task.findMany({ select: { task_id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `task_id`
     * const taskWithTask_idOnly = await prisma.task.createManyAndReturn({ 
     *   select: { task_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsible_manager<T extends Task$responsible_managerArgs<ExtArgs> = {}>(args?: Subset<T, Task$responsible_managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    creator_manager<T extends Task$creator_managerArgs<ExtArgs> = {}>(args?: Subset<T, Task$creator_managerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    project<T extends Task$projectArgs<ExtArgs> = {}>(args?: Subset<T, Task$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subproject<T extends Task$subprojectArgs<ExtArgs> = {}>(args?: Subset<T, Task$subprojectArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly task_id: FieldRef<"Task", 'Int'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly responsible_manager_id: FieldRef<"Task", 'Int'>
    readonly creator_manager_id: FieldRef<"Task", 'Int'>
    readonly project_id: FieldRef<"Task", 'Int'>
    readonly subproject_id: FieldRef<"Task", 'Int'>
    readonly due_date: FieldRef<"Task", 'DateTime'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly created_at: FieldRef<"Task", 'DateTime'>
    readonly updated_at: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.responsible_manager
   */
  export type Task$responsible_managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Task.creator_manager
   */
  export type Task$creator_managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * Task.project
   */
  export type Task$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Task.subproject
   */
  export type Task$subprojectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProject
     */
    select?: SubProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectInclude<ExtArgs> | null
    where?: SubProjectWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model ProjectProduct
   */

  export type AggregateProjectProduct = {
    _count: ProjectProductCountAggregateOutputType | null
    _avg: ProjectProductAvgAggregateOutputType | null
    _sum: ProjectProductSumAggregateOutputType | null
    _min: ProjectProductMinAggregateOutputType | null
    _max: ProjectProductMaxAggregateOutputType | null
  }

  export type ProjectProductAvgAggregateOutputType = {
    project_product_id: number | null
    project_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type ProjectProductSumAggregateOutputType = {
    project_product_id: number | null
    project_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type ProjectProductMinAggregateOutputType = {
    project_product_id: number | null
    project_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type ProjectProductMaxAggregateOutputType = {
    project_product_id: number | null
    project_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type ProjectProductCountAggregateOutputType = {
    project_product_id: number
    project_id: number
    product_id: number
    quantity: number
    created_at: number
    _all: number
  }


  export type ProjectProductAvgAggregateInputType = {
    project_product_id?: true
    project_id?: true
    product_id?: true
    quantity?: true
  }

  export type ProjectProductSumAggregateInputType = {
    project_product_id?: true
    project_id?: true
    product_id?: true
    quantity?: true
  }

  export type ProjectProductMinAggregateInputType = {
    project_product_id?: true
    project_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type ProjectProductMaxAggregateInputType = {
    project_product_id?: true
    project_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type ProjectProductCountAggregateInputType = {
    project_product_id?: true
    project_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
    _all?: true
  }

  export type ProjectProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectProduct to aggregate.
     */
    where?: ProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProducts to fetch.
     */
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectProducts
    **/
    _count?: true | ProjectProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectProductMaxAggregateInputType
  }

  export type GetProjectProductAggregateType<T extends ProjectProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectProduct[P]>
      : GetScalarType<T[P], AggregateProjectProduct[P]>
  }




  export type ProjectProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectProductWhereInput
    orderBy?: ProjectProductOrderByWithAggregationInput | ProjectProductOrderByWithAggregationInput[]
    by: ProjectProductScalarFieldEnum[] | ProjectProductScalarFieldEnum
    having?: ProjectProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectProductCountAggregateInputType | true
    _avg?: ProjectProductAvgAggregateInputType
    _sum?: ProjectProductSumAggregateInputType
    _min?: ProjectProductMinAggregateInputType
    _max?: ProjectProductMaxAggregateInputType
  }

  export type ProjectProductGroupByOutputType = {
    project_product_id: number
    project_id: number
    product_id: number
    quantity: number
    created_at: Date
    _count: ProjectProductCountAggregateOutputType | null
    _avg: ProjectProductAvgAggregateOutputType | null
    _sum: ProjectProductSumAggregateOutputType | null
    _min: ProjectProductMinAggregateOutputType | null
    _max: ProjectProductMaxAggregateOutputType | null
  }

  type GetProjectProductGroupByPayload<T extends ProjectProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectProductGroupByOutputType[P]>
        }
      >
    >


  export type ProjectProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_product_id?: boolean
    project_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectProduct"]>

  export type ProjectProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_product_id?: boolean
    project_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectProduct"]>

  export type ProjectProductSelectScalar = {
    project_product_id?: boolean
    project_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
  }

  export type ProjectProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProjectProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProjectProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectProduct"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      project_product_id: number
      project_id: number
      product_id: number
      quantity: number
      created_at: Date
    }, ExtArgs["result"]["projectProduct"]>
    composites: {}
  }

  type ProjectProductGetPayload<S extends boolean | null | undefined | ProjectProductDefaultArgs> = $Result.GetResult<Prisma.$ProjectProductPayload, S>

  type ProjectProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectProductCountAggregateInputType | true
    }

  export interface ProjectProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectProduct'], meta: { name: 'ProjectProduct' } }
    /**
     * Find zero or one ProjectProduct that matches the filter.
     * @param {ProjectProductFindUniqueArgs} args - Arguments to find a ProjectProduct
     * @example
     * // Get one ProjectProduct
     * const projectProduct = await prisma.projectProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectProductFindUniqueArgs>(args: SelectSubset<T, ProjectProductFindUniqueArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectProductFindUniqueOrThrowArgs} args - Arguments to find a ProjectProduct
     * @example
     * // Get one ProjectProduct
     * const projectProduct = await prisma.projectProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductFindFirstArgs} args - Arguments to find a ProjectProduct
     * @example
     * // Get one ProjectProduct
     * const projectProduct = await prisma.projectProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectProductFindFirstArgs>(args?: SelectSubset<T, ProjectProductFindFirstArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductFindFirstOrThrowArgs} args - Arguments to find a ProjectProduct
     * @example
     * // Get one ProjectProduct
     * const projectProduct = await prisma.projectProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectProducts
     * const projectProducts = await prisma.projectProduct.findMany()
     * 
     * // Get first 10 ProjectProducts
     * const projectProducts = await prisma.projectProduct.findMany({ take: 10 })
     * 
     * // Only select the `project_product_id`
     * const projectProductWithProject_product_idOnly = await prisma.projectProduct.findMany({ select: { project_product_id: true } })
     * 
     */
    findMany<T extends ProjectProductFindManyArgs>(args?: SelectSubset<T, ProjectProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectProduct.
     * @param {ProjectProductCreateArgs} args - Arguments to create a ProjectProduct.
     * @example
     * // Create one ProjectProduct
     * const ProjectProduct = await prisma.projectProduct.create({
     *   data: {
     *     // ... data to create a ProjectProduct
     *   }
     * })
     * 
     */
    create<T extends ProjectProductCreateArgs>(args: SelectSubset<T, ProjectProductCreateArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectProducts.
     * @param {ProjectProductCreateManyArgs} args - Arguments to create many ProjectProducts.
     * @example
     * // Create many ProjectProducts
     * const projectProduct = await prisma.projectProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectProductCreateManyArgs>(args?: SelectSubset<T, ProjectProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectProducts and returns the data saved in the database.
     * @param {ProjectProductCreateManyAndReturnArgs} args - Arguments to create many ProjectProducts.
     * @example
     * // Create many ProjectProducts
     * const projectProduct = await prisma.projectProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectProducts and only return the `project_product_id`
     * const projectProductWithProject_product_idOnly = await prisma.projectProduct.createManyAndReturn({ 
     *   select: { project_product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectProduct.
     * @param {ProjectProductDeleteArgs} args - Arguments to delete one ProjectProduct.
     * @example
     * // Delete one ProjectProduct
     * const ProjectProduct = await prisma.projectProduct.delete({
     *   where: {
     *     // ... filter to delete one ProjectProduct
     *   }
     * })
     * 
     */
    delete<T extends ProjectProductDeleteArgs>(args: SelectSubset<T, ProjectProductDeleteArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectProduct.
     * @param {ProjectProductUpdateArgs} args - Arguments to update one ProjectProduct.
     * @example
     * // Update one ProjectProduct
     * const projectProduct = await prisma.projectProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectProductUpdateArgs>(args: SelectSubset<T, ProjectProductUpdateArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectProducts.
     * @param {ProjectProductDeleteManyArgs} args - Arguments to filter ProjectProducts to delete.
     * @example
     * // Delete a few ProjectProducts
     * const { count } = await prisma.projectProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectProductDeleteManyArgs>(args?: SelectSubset<T, ProjectProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectProducts
     * const projectProduct = await prisma.projectProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectProductUpdateManyArgs>(args: SelectSubset<T, ProjectProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectProduct.
     * @param {ProjectProductUpsertArgs} args - Arguments to update or create a ProjectProduct.
     * @example
     * // Update or create a ProjectProduct
     * const projectProduct = await prisma.projectProduct.upsert({
     *   create: {
     *     // ... data to create a ProjectProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectProduct we want to update
     *   }
     * })
     */
    upsert<T extends ProjectProductUpsertArgs>(args: SelectSubset<T, ProjectProductUpsertArgs<ExtArgs>>): Prisma__ProjectProductClient<$Result.GetResult<Prisma.$ProjectProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductCountArgs} args - Arguments to filter ProjectProducts to count.
     * @example
     * // Count the number of ProjectProducts
     * const count = await prisma.projectProduct.count({
     *   where: {
     *     // ... the filter for the ProjectProducts we want to count
     *   }
     * })
    **/
    count<T extends ProjectProductCountArgs>(
      args?: Subset<T, ProjectProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectProductAggregateArgs>(args: Subset<T, ProjectProductAggregateArgs>): Prisma.PrismaPromise<GetProjectProductAggregateType<T>>

    /**
     * Group by ProjectProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectProductGroupByArgs['orderBy'] }
        : { orderBy?: ProjectProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectProduct model
   */
  readonly fields: ProjectProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectProduct model
   */ 
  interface ProjectProductFieldRefs {
    readonly project_product_id: FieldRef<"ProjectProduct", 'Int'>
    readonly project_id: FieldRef<"ProjectProduct", 'Int'>
    readonly product_id: FieldRef<"ProjectProduct", 'Int'>
    readonly quantity: FieldRef<"ProjectProduct", 'Int'>
    readonly created_at: FieldRef<"ProjectProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectProduct findUnique
   */
  export type ProjectProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which ProjectProduct to fetch.
     */
    where: ProjectProductWhereUniqueInput
  }

  /**
   * ProjectProduct findUniqueOrThrow
   */
  export type ProjectProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which ProjectProduct to fetch.
     */
    where: ProjectProductWhereUniqueInput
  }

  /**
   * ProjectProduct findFirst
   */
  export type ProjectProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which ProjectProduct to fetch.
     */
    where?: ProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProducts to fetch.
     */
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectProducts.
     */
    cursor?: ProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectProducts.
     */
    distinct?: ProjectProductScalarFieldEnum | ProjectProductScalarFieldEnum[]
  }

  /**
   * ProjectProduct findFirstOrThrow
   */
  export type ProjectProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which ProjectProduct to fetch.
     */
    where?: ProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProducts to fetch.
     */
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectProducts.
     */
    cursor?: ProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectProducts.
     */
    distinct?: ProjectProductScalarFieldEnum | ProjectProductScalarFieldEnum[]
  }

  /**
   * ProjectProduct findMany
   */
  export type ProjectProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which ProjectProducts to fetch.
     */
    where?: ProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectProducts to fetch.
     */
    orderBy?: ProjectProductOrderByWithRelationInput | ProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectProducts.
     */
    cursor?: ProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectProducts.
     */
    skip?: number
    distinct?: ProjectProductScalarFieldEnum | ProjectProductScalarFieldEnum[]
  }

  /**
   * ProjectProduct create
   */
  export type ProjectProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectProduct.
     */
    data: XOR<ProjectProductCreateInput, ProjectProductUncheckedCreateInput>
  }

  /**
   * ProjectProduct createMany
   */
  export type ProjectProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectProducts.
     */
    data: ProjectProductCreateManyInput | ProjectProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectProduct createManyAndReturn
   */
  export type ProjectProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectProducts.
     */
    data: ProjectProductCreateManyInput | ProjectProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectProduct update
   */
  export type ProjectProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectProduct.
     */
    data: XOR<ProjectProductUpdateInput, ProjectProductUncheckedUpdateInput>
    /**
     * Choose, which ProjectProduct to update.
     */
    where: ProjectProductWhereUniqueInput
  }

  /**
   * ProjectProduct updateMany
   */
  export type ProjectProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectProducts.
     */
    data: XOR<ProjectProductUpdateManyMutationInput, ProjectProductUncheckedUpdateManyInput>
    /**
     * Filter which ProjectProducts to update
     */
    where?: ProjectProductWhereInput
  }

  /**
   * ProjectProduct upsert
   */
  export type ProjectProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectProduct to update in case it exists.
     */
    where: ProjectProductWhereUniqueInput
    /**
     * In case the ProjectProduct found by the `where` argument doesn't exist, create a new ProjectProduct with this data.
     */
    create: XOR<ProjectProductCreateInput, ProjectProductUncheckedCreateInput>
    /**
     * In case the ProjectProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectProductUpdateInput, ProjectProductUncheckedUpdateInput>
  }

  /**
   * ProjectProduct delete
   */
  export type ProjectProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
    /**
     * Filter which ProjectProduct to delete.
     */
    where: ProjectProductWhereUniqueInput
  }

  /**
   * ProjectProduct deleteMany
   */
  export type ProjectProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectProducts to delete
     */
    where?: ProjectProductWhereInput
  }

  /**
   * ProjectProduct without action
   */
  export type ProjectProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectProduct
     */
    select?: ProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectProductInclude<ExtArgs> | null
  }


  /**
   * Model ProjectService
   */

  export type AggregateProjectService = {
    _count: ProjectServiceCountAggregateOutputType | null
    _avg: ProjectServiceAvgAggregateOutputType | null
    _sum: ProjectServiceSumAggregateOutputType | null
    _min: ProjectServiceMinAggregateOutputType | null
    _max: ProjectServiceMaxAggregateOutputType | null
  }

  export type ProjectServiceAvgAggregateOutputType = {
    project_service_id: number | null
    project_id: number | null
    service_id: number | null
  }

  export type ProjectServiceSumAggregateOutputType = {
    project_service_id: number | null
    project_id: number | null
    service_id: number | null
  }

  export type ProjectServiceMinAggregateOutputType = {
    project_service_id: number | null
    project_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type ProjectServiceMaxAggregateOutputType = {
    project_service_id: number | null
    project_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type ProjectServiceCountAggregateOutputType = {
    project_service_id: number
    project_id: number
    service_id: number
    created_at: number
    _all: number
  }


  export type ProjectServiceAvgAggregateInputType = {
    project_service_id?: true
    project_id?: true
    service_id?: true
  }

  export type ProjectServiceSumAggregateInputType = {
    project_service_id?: true
    project_id?: true
    service_id?: true
  }

  export type ProjectServiceMinAggregateInputType = {
    project_service_id?: true
    project_id?: true
    service_id?: true
    created_at?: true
  }

  export type ProjectServiceMaxAggregateInputType = {
    project_service_id?: true
    project_id?: true
    service_id?: true
    created_at?: true
  }

  export type ProjectServiceCountAggregateInputType = {
    project_service_id?: true
    project_id?: true
    service_id?: true
    created_at?: true
    _all?: true
  }

  export type ProjectServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectService to aggregate.
     */
    where?: ProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectServices to fetch.
     */
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectServices
    **/
    _count?: true | ProjectServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectServiceMaxAggregateInputType
  }

  export type GetProjectServiceAggregateType<T extends ProjectServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectService[P]>
      : GetScalarType<T[P], AggregateProjectService[P]>
  }




  export type ProjectServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectServiceWhereInput
    orderBy?: ProjectServiceOrderByWithAggregationInput | ProjectServiceOrderByWithAggregationInput[]
    by: ProjectServiceScalarFieldEnum[] | ProjectServiceScalarFieldEnum
    having?: ProjectServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectServiceCountAggregateInputType | true
    _avg?: ProjectServiceAvgAggregateInputType
    _sum?: ProjectServiceSumAggregateInputType
    _min?: ProjectServiceMinAggregateInputType
    _max?: ProjectServiceMaxAggregateInputType
  }

  export type ProjectServiceGroupByOutputType = {
    project_service_id: number
    project_id: number
    service_id: number
    created_at: Date
    _count: ProjectServiceCountAggregateOutputType | null
    _avg: ProjectServiceAvgAggregateOutputType | null
    _sum: ProjectServiceSumAggregateOutputType | null
    _min: ProjectServiceMinAggregateOutputType | null
    _max: ProjectServiceMaxAggregateOutputType | null
  }

  type GetProjectServiceGroupByPayload<T extends ProjectServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectServiceGroupByOutputType[P]>
        }
      >
    >


  export type ProjectServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_service_id?: boolean
    project_id?: boolean
    service_id?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectService"]>

  export type ProjectServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    project_service_id?: boolean
    project_id?: boolean
    service_id?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectService"]>

  export type ProjectServiceSelectScalar = {
    project_service_id?: boolean
    project_id?: boolean
    service_id?: boolean
    created_at?: boolean
  }

  export type ProjectServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ProjectServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ProjectServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectService"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      project_service_id: number
      project_id: number
      service_id: number
      created_at: Date
    }, ExtArgs["result"]["projectService"]>
    composites: {}
  }

  type ProjectServiceGetPayload<S extends boolean | null | undefined | ProjectServiceDefaultArgs> = $Result.GetResult<Prisma.$ProjectServicePayload, S>

  type ProjectServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectServiceCountAggregateInputType | true
    }

  export interface ProjectServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectService'], meta: { name: 'ProjectService' } }
    /**
     * Find zero or one ProjectService that matches the filter.
     * @param {ProjectServiceFindUniqueArgs} args - Arguments to find a ProjectService
     * @example
     * // Get one ProjectService
     * const projectService = await prisma.projectService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectServiceFindUniqueArgs>(args: SelectSubset<T, ProjectServiceFindUniqueArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectServiceFindUniqueOrThrowArgs} args - Arguments to find a ProjectService
     * @example
     * // Get one ProjectService
     * const projectService = await prisma.projectService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceFindFirstArgs} args - Arguments to find a ProjectService
     * @example
     * // Get one ProjectService
     * const projectService = await prisma.projectService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectServiceFindFirstArgs>(args?: SelectSubset<T, ProjectServiceFindFirstArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceFindFirstOrThrowArgs} args - Arguments to find a ProjectService
     * @example
     * // Get one ProjectService
     * const projectService = await prisma.projectService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectServices
     * const projectServices = await prisma.projectService.findMany()
     * 
     * // Get first 10 ProjectServices
     * const projectServices = await prisma.projectService.findMany({ take: 10 })
     * 
     * // Only select the `project_service_id`
     * const projectServiceWithProject_service_idOnly = await prisma.projectService.findMany({ select: { project_service_id: true } })
     * 
     */
    findMany<T extends ProjectServiceFindManyArgs>(args?: SelectSubset<T, ProjectServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectService.
     * @param {ProjectServiceCreateArgs} args - Arguments to create a ProjectService.
     * @example
     * // Create one ProjectService
     * const ProjectService = await prisma.projectService.create({
     *   data: {
     *     // ... data to create a ProjectService
     *   }
     * })
     * 
     */
    create<T extends ProjectServiceCreateArgs>(args: SelectSubset<T, ProjectServiceCreateArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectServices.
     * @param {ProjectServiceCreateManyArgs} args - Arguments to create many ProjectServices.
     * @example
     * // Create many ProjectServices
     * const projectService = await prisma.projectService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectServiceCreateManyArgs>(args?: SelectSubset<T, ProjectServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectServices and returns the data saved in the database.
     * @param {ProjectServiceCreateManyAndReturnArgs} args - Arguments to create many ProjectServices.
     * @example
     * // Create many ProjectServices
     * const projectService = await prisma.projectService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectServices and only return the `project_service_id`
     * const projectServiceWithProject_service_idOnly = await prisma.projectService.createManyAndReturn({ 
     *   select: { project_service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectService.
     * @param {ProjectServiceDeleteArgs} args - Arguments to delete one ProjectService.
     * @example
     * // Delete one ProjectService
     * const ProjectService = await prisma.projectService.delete({
     *   where: {
     *     // ... filter to delete one ProjectService
     *   }
     * })
     * 
     */
    delete<T extends ProjectServiceDeleteArgs>(args: SelectSubset<T, ProjectServiceDeleteArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectService.
     * @param {ProjectServiceUpdateArgs} args - Arguments to update one ProjectService.
     * @example
     * // Update one ProjectService
     * const projectService = await prisma.projectService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectServiceUpdateArgs>(args: SelectSubset<T, ProjectServiceUpdateArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectServices.
     * @param {ProjectServiceDeleteManyArgs} args - Arguments to filter ProjectServices to delete.
     * @example
     * // Delete a few ProjectServices
     * const { count } = await prisma.projectService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectServiceDeleteManyArgs>(args?: SelectSubset<T, ProjectServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectServices
     * const projectService = await prisma.projectService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectServiceUpdateManyArgs>(args: SelectSubset<T, ProjectServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectService.
     * @param {ProjectServiceUpsertArgs} args - Arguments to update or create a ProjectService.
     * @example
     * // Update or create a ProjectService
     * const projectService = await prisma.projectService.upsert({
     *   create: {
     *     // ... data to create a ProjectService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectService we want to update
     *   }
     * })
     */
    upsert<T extends ProjectServiceUpsertArgs>(args: SelectSubset<T, ProjectServiceUpsertArgs<ExtArgs>>): Prisma__ProjectServiceClient<$Result.GetResult<Prisma.$ProjectServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceCountArgs} args - Arguments to filter ProjectServices to count.
     * @example
     * // Count the number of ProjectServices
     * const count = await prisma.projectService.count({
     *   where: {
     *     // ... the filter for the ProjectServices we want to count
     *   }
     * })
    **/
    count<T extends ProjectServiceCountArgs>(
      args?: Subset<T, ProjectServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectServiceAggregateArgs>(args: Subset<T, ProjectServiceAggregateArgs>): Prisma.PrismaPromise<GetProjectServiceAggregateType<T>>

    /**
     * Group by ProjectService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectServiceGroupByArgs['orderBy'] }
        : { orderBy?: ProjectServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectService model
   */
  readonly fields: ProjectServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectService model
   */ 
  interface ProjectServiceFieldRefs {
    readonly project_service_id: FieldRef<"ProjectService", 'Int'>
    readonly project_id: FieldRef<"ProjectService", 'Int'>
    readonly service_id: FieldRef<"ProjectService", 'Int'>
    readonly created_at: FieldRef<"ProjectService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectService findUnique
   */
  export type ProjectServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectService to fetch.
     */
    where: ProjectServiceWhereUniqueInput
  }

  /**
   * ProjectService findUniqueOrThrow
   */
  export type ProjectServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectService to fetch.
     */
    where: ProjectServiceWhereUniqueInput
  }

  /**
   * ProjectService findFirst
   */
  export type ProjectServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectService to fetch.
     */
    where?: ProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectServices to fetch.
     */
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectServices.
     */
    cursor?: ProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectServices.
     */
    distinct?: ProjectServiceScalarFieldEnum | ProjectServiceScalarFieldEnum[]
  }

  /**
   * ProjectService findFirstOrThrow
   */
  export type ProjectServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectService to fetch.
     */
    where?: ProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectServices to fetch.
     */
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectServices.
     */
    cursor?: ProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectServices.
     */
    distinct?: ProjectServiceScalarFieldEnum | ProjectServiceScalarFieldEnum[]
  }

  /**
   * ProjectService findMany
   */
  export type ProjectServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which ProjectServices to fetch.
     */
    where?: ProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectServices to fetch.
     */
    orderBy?: ProjectServiceOrderByWithRelationInput | ProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectServices.
     */
    cursor?: ProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectServices.
     */
    skip?: number
    distinct?: ProjectServiceScalarFieldEnum | ProjectServiceScalarFieldEnum[]
  }

  /**
   * ProjectService create
   */
  export type ProjectServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectService.
     */
    data: XOR<ProjectServiceCreateInput, ProjectServiceUncheckedCreateInput>
  }

  /**
   * ProjectService createMany
   */
  export type ProjectServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectServices.
     */
    data: ProjectServiceCreateManyInput | ProjectServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectService createManyAndReturn
   */
  export type ProjectServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectServices.
     */
    data: ProjectServiceCreateManyInput | ProjectServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectService update
   */
  export type ProjectServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectService.
     */
    data: XOR<ProjectServiceUpdateInput, ProjectServiceUncheckedUpdateInput>
    /**
     * Choose, which ProjectService to update.
     */
    where: ProjectServiceWhereUniqueInput
  }

  /**
   * ProjectService updateMany
   */
  export type ProjectServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectServices.
     */
    data: XOR<ProjectServiceUpdateManyMutationInput, ProjectServiceUncheckedUpdateManyInput>
    /**
     * Filter which ProjectServices to update
     */
    where?: ProjectServiceWhereInput
  }

  /**
   * ProjectService upsert
   */
  export type ProjectServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectService to update in case it exists.
     */
    where: ProjectServiceWhereUniqueInput
    /**
     * In case the ProjectService found by the `where` argument doesn't exist, create a new ProjectService with this data.
     */
    create: XOR<ProjectServiceCreateInput, ProjectServiceUncheckedCreateInput>
    /**
     * In case the ProjectService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectServiceUpdateInput, ProjectServiceUncheckedUpdateInput>
  }

  /**
   * ProjectService delete
   */
  export type ProjectServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
    /**
     * Filter which ProjectService to delete.
     */
    where: ProjectServiceWhereUniqueInput
  }

  /**
   * ProjectService deleteMany
   */
  export type ProjectServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectServices to delete
     */
    where?: ProjectServiceWhereInput
  }

  /**
   * ProjectService without action
   */
  export type ProjectServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectService
     */
    select?: ProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectServiceInclude<ExtArgs> | null
  }


  /**
   * Model SubProjectProduct
   */

  export type AggregateSubProjectProduct = {
    _count: SubProjectProductCountAggregateOutputType | null
    _avg: SubProjectProductAvgAggregateOutputType | null
    _sum: SubProjectProductSumAggregateOutputType | null
    _min: SubProjectProductMinAggregateOutputType | null
    _max: SubProjectProductMaxAggregateOutputType | null
  }

  export type SubProjectProductAvgAggregateOutputType = {
    subproject_product_id: number | null
    subproject_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type SubProjectProductSumAggregateOutputType = {
    subproject_product_id: number | null
    subproject_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type SubProjectProductMinAggregateOutputType = {
    subproject_product_id: number | null
    subproject_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type SubProjectProductMaxAggregateOutputType = {
    subproject_product_id: number | null
    subproject_id: number | null
    product_id: number | null
    quantity: number | null
    created_at: Date | null
  }

  export type SubProjectProductCountAggregateOutputType = {
    subproject_product_id: number
    subproject_id: number
    product_id: number
    quantity: number
    created_at: number
    _all: number
  }


  export type SubProjectProductAvgAggregateInputType = {
    subproject_product_id?: true
    subproject_id?: true
    product_id?: true
    quantity?: true
  }

  export type SubProjectProductSumAggregateInputType = {
    subproject_product_id?: true
    subproject_id?: true
    product_id?: true
    quantity?: true
  }

  export type SubProjectProductMinAggregateInputType = {
    subproject_product_id?: true
    subproject_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type SubProjectProductMaxAggregateInputType = {
    subproject_product_id?: true
    subproject_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
  }

  export type SubProjectProductCountAggregateInputType = {
    subproject_product_id?: true
    subproject_id?: true
    product_id?: true
    quantity?: true
    created_at?: true
    _all?: true
  }

  export type SubProjectProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectProduct to aggregate.
     */
    where?: SubProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectProducts to fetch.
     */
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubProjectProducts
    **/
    _count?: true | SubProjectProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubProjectProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubProjectProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubProjectProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubProjectProductMaxAggregateInputType
  }

  export type GetSubProjectProductAggregateType<T extends SubProjectProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSubProjectProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubProjectProduct[P]>
      : GetScalarType<T[P], AggregateSubProjectProduct[P]>
  }




  export type SubProjectProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectProductWhereInput
    orderBy?: SubProjectProductOrderByWithAggregationInput | SubProjectProductOrderByWithAggregationInput[]
    by: SubProjectProductScalarFieldEnum[] | SubProjectProductScalarFieldEnum
    having?: SubProjectProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubProjectProductCountAggregateInputType | true
    _avg?: SubProjectProductAvgAggregateInputType
    _sum?: SubProjectProductSumAggregateInputType
    _min?: SubProjectProductMinAggregateInputType
    _max?: SubProjectProductMaxAggregateInputType
  }

  export type SubProjectProductGroupByOutputType = {
    subproject_product_id: number
    subproject_id: number
    product_id: number
    quantity: number
    created_at: Date
    _count: SubProjectProductCountAggregateOutputType | null
    _avg: SubProjectProductAvgAggregateOutputType | null
    _sum: SubProjectProductSumAggregateOutputType | null
    _min: SubProjectProductMinAggregateOutputType | null
    _max: SubProjectProductMaxAggregateOutputType | null
  }

  type GetSubProjectProductGroupByPayload<T extends SubProjectProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubProjectProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubProjectProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubProjectProductGroupByOutputType[P]>
            : GetScalarType<T[P], SubProjectProductGroupByOutputType[P]>
        }
      >
    >


  export type SubProjectProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_product_id?: boolean
    subproject_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectProduct"]>

  export type SubProjectProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_product_id?: boolean
    subproject_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectProduct"]>

  export type SubProjectProductSelectScalar = {
    subproject_product_id?: boolean
    subproject_id?: boolean
    product_id?: boolean
    quantity?: boolean
    created_at?: boolean
  }

  export type SubProjectProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type SubProjectProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $SubProjectProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubProjectProduct"
    objects: {
      subproject: Prisma.$SubProjectPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subproject_product_id: number
      subproject_id: number
      product_id: number
      quantity: number
      created_at: Date
    }, ExtArgs["result"]["subProjectProduct"]>
    composites: {}
  }

  type SubProjectProductGetPayload<S extends boolean | null | undefined | SubProjectProductDefaultArgs> = $Result.GetResult<Prisma.$SubProjectProductPayload, S>

  type SubProjectProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubProjectProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubProjectProductCountAggregateInputType | true
    }

  export interface SubProjectProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubProjectProduct'], meta: { name: 'SubProjectProduct' } }
    /**
     * Find zero or one SubProjectProduct that matches the filter.
     * @param {SubProjectProductFindUniqueArgs} args - Arguments to find a SubProjectProduct
     * @example
     * // Get one SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubProjectProductFindUniqueArgs>(args: SelectSubset<T, SubProjectProductFindUniqueArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubProjectProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubProjectProductFindUniqueOrThrowArgs} args - Arguments to find a SubProjectProduct
     * @example
     * // Get one SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubProjectProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SubProjectProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubProjectProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductFindFirstArgs} args - Arguments to find a SubProjectProduct
     * @example
     * // Get one SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubProjectProductFindFirstArgs>(args?: SelectSubset<T, SubProjectProductFindFirstArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubProjectProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductFindFirstOrThrowArgs} args - Arguments to find a SubProjectProduct
     * @example
     * // Get one SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubProjectProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SubProjectProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubProjectProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubProjectProducts
     * const subProjectProducts = await prisma.subProjectProduct.findMany()
     * 
     * // Get first 10 SubProjectProducts
     * const subProjectProducts = await prisma.subProjectProduct.findMany({ take: 10 })
     * 
     * // Only select the `subproject_product_id`
     * const subProjectProductWithSubproject_product_idOnly = await prisma.subProjectProduct.findMany({ select: { subproject_product_id: true } })
     * 
     */
    findMany<T extends SubProjectProductFindManyArgs>(args?: SelectSubset<T, SubProjectProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubProjectProduct.
     * @param {SubProjectProductCreateArgs} args - Arguments to create a SubProjectProduct.
     * @example
     * // Create one SubProjectProduct
     * const SubProjectProduct = await prisma.subProjectProduct.create({
     *   data: {
     *     // ... data to create a SubProjectProduct
     *   }
     * })
     * 
     */
    create<T extends SubProjectProductCreateArgs>(args: SelectSubset<T, SubProjectProductCreateArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubProjectProducts.
     * @param {SubProjectProductCreateManyArgs} args - Arguments to create many SubProjectProducts.
     * @example
     * // Create many SubProjectProducts
     * const subProjectProduct = await prisma.subProjectProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubProjectProductCreateManyArgs>(args?: SelectSubset<T, SubProjectProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubProjectProducts and returns the data saved in the database.
     * @param {SubProjectProductCreateManyAndReturnArgs} args - Arguments to create many SubProjectProducts.
     * @example
     * // Create many SubProjectProducts
     * const subProjectProduct = await prisma.subProjectProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubProjectProducts and only return the `subproject_product_id`
     * const subProjectProductWithSubproject_product_idOnly = await prisma.subProjectProduct.createManyAndReturn({ 
     *   select: { subproject_product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubProjectProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SubProjectProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubProjectProduct.
     * @param {SubProjectProductDeleteArgs} args - Arguments to delete one SubProjectProduct.
     * @example
     * // Delete one SubProjectProduct
     * const SubProjectProduct = await prisma.subProjectProduct.delete({
     *   where: {
     *     // ... filter to delete one SubProjectProduct
     *   }
     * })
     * 
     */
    delete<T extends SubProjectProductDeleteArgs>(args: SelectSubset<T, SubProjectProductDeleteArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubProjectProduct.
     * @param {SubProjectProductUpdateArgs} args - Arguments to update one SubProjectProduct.
     * @example
     * // Update one SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubProjectProductUpdateArgs>(args: SelectSubset<T, SubProjectProductUpdateArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubProjectProducts.
     * @param {SubProjectProductDeleteManyArgs} args - Arguments to filter SubProjectProducts to delete.
     * @example
     * // Delete a few SubProjectProducts
     * const { count } = await prisma.subProjectProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubProjectProductDeleteManyArgs>(args?: SelectSubset<T, SubProjectProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubProjectProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubProjectProducts
     * const subProjectProduct = await prisma.subProjectProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubProjectProductUpdateManyArgs>(args: SelectSubset<T, SubProjectProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubProjectProduct.
     * @param {SubProjectProductUpsertArgs} args - Arguments to update or create a SubProjectProduct.
     * @example
     * // Update or create a SubProjectProduct
     * const subProjectProduct = await prisma.subProjectProduct.upsert({
     *   create: {
     *     // ... data to create a SubProjectProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubProjectProduct we want to update
     *   }
     * })
     */
    upsert<T extends SubProjectProductUpsertArgs>(args: SelectSubset<T, SubProjectProductUpsertArgs<ExtArgs>>): Prisma__SubProjectProductClient<$Result.GetResult<Prisma.$SubProjectProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubProjectProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductCountArgs} args - Arguments to filter SubProjectProducts to count.
     * @example
     * // Count the number of SubProjectProducts
     * const count = await prisma.subProjectProduct.count({
     *   where: {
     *     // ... the filter for the SubProjectProducts we want to count
     *   }
     * })
    **/
    count<T extends SubProjectProductCountArgs>(
      args?: Subset<T, SubProjectProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubProjectProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubProjectProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubProjectProductAggregateArgs>(args: Subset<T, SubProjectProductAggregateArgs>): Prisma.PrismaPromise<GetSubProjectProductAggregateType<T>>

    /**
     * Group by SubProjectProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubProjectProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubProjectProductGroupByArgs['orderBy'] }
        : { orderBy?: SubProjectProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubProjectProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubProjectProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubProjectProduct model
   */
  readonly fields: SubProjectProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubProjectProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubProjectProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subproject<T extends SubProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubProjectDefaultArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubProjectProduct model
   */ 
  interface SubProjectProductFieldRefs {
    readonly subproject_product_id: FieldRef<"SubProjectProduct", 'Int'>
    readonly subproject_id: FieldRef<"SubProjectProduct", 'Int'>
    readonly product_id: FieldRef<"SubProjectProduct", 'Int'>
    readonly quantity: FieldRef<"SubProjectProduct", 'Int'>
    readonly created_at: FieldRef<"SubProjectProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubProjectProduct findUnique
   */
  export type SubProjectProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectProduct to fetch.
     */
    where: SubProjectProductWhereUniqueInput
  }

  /**
   * SubProjectProduct findUniqueOrThrow
   */
  export type SubProjectProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectProduct to fetch.
     */
    where: SubProjectProductWhereUniqueInput
  }

  /**
   * SubProjectProduct findFirst
   */
  export type SubProjectProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectProduct to fetch.
     */
    where?: SubProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectProducts to fetch.
     */
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectProducts.
     */
    cursor?: SubProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectProducts.
     */
    distinct?: SubProjectProductScalarFieldEnum | SubProjectProductScalarFieldEnum[]
  }

  /**
   * SubProjectProduct findFirstOrThrow
   */
  export type SubProjectProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectProduct to fetch.
     */
    where?: SubProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectProducts to fetch.
     */
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectProducts.
     */
    cursor?: SubProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectProducts.
     */
    distinct?: SubProjectProductScalarFieldEnum | SubProjectProductScalarFieldEnum[]
  }

  /**
   * SubProjectProduct findMany
   */
  export type SubProjectProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectProducts to fetch.
     */
    where?: SubProjectProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectProducts to fetch.
     */
    orderBy?: SubProjectProductOrderByWithRelationInput | SubProjectProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubProjectProducts.
     */
    cursor?: SubProjectProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectProducts.
     */
    skip?: number
    distinct?: SubProjectProductScalarFieldEnum | SubProjectProductScalarFieldEnum[]
  }

  /**
   * SubProjectProduct create
   */
  export type SubProjectProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SubProjectProduct.
     */
    data: XOR<SubProjectProductCreateInput, SubProjectProductUncheckedCreateInput>
  }

  /**
   * SubProjectProduct createMany
   */
  export type SubProjectProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubProjectProducts.
     */
    data: SubProjectProductCreateManyInput | SubProjectProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProjectProduct createManyAndReturn
   */
  export type SubProjectProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubProjectProducts.
     */
    data: SubProjectProductCreateManyInput | SubProjectProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubProjectProduct update
   */
  export type SubProjectProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SubProjectProduct.
     */
    data: XOR<SubProjectProductUpdateInput, SubProjectProductUncheckedUpdateInput>
    /**
     * Choose, which SubProjectProduct to update.
     */
    where: SubProjectProductWhereUniqueInput
  }

  /**
   * SubProjectProduct updateMany
   */
  export type SubProjectProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubProjectProducts.
     */
    data: XOR<SubProjectProductUpdateManyMutationInput, SubProjectProductUncheckedUpdateManyInput>
    /**
     * Filter which SubProjectProducts to update
     */
    where?: SubProjectProductWhereInput
  }

  /**
   * SubProjectProduct upsert
   */
  export type SubProjectProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SubProjectProduct to update in case it exists.
     */
    where: SubProjectProductWhereUniqueInput
    /**
     * In case the SubProjectProduct found by the `where` argument doesn't exist, create a new SubProjectProduct with this data.
     */
    create: XOR<SubProjectProductCreateInput, SubProjectProductUncheckedCreateInput>
    /**
     * In case the SubProjectProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubProjectProductUpdateInput, SubProjectProductUncheckedUpdateInput>
  }

  /**
   * SubProjectProduct delete
   */
  export type SubProjectProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
    /**
     * Filter which SubProjectProduct to delete.
     */
    where: SubProjectProductWhereUniqueInput
  }

  /**
   * SubProjectProduct deleteMany
   */
  export type SubProjectProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectProducts to delete
     */
    where?: SubProjectProductWhereInput
  }

  /**
   * SubProjectProduct without action
   */
  export type SubProjectProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectProduct
     */
    select?: SubProjectProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectProductInclude<ExtArgs> | null
  }


  /**
   * Model SubProjectService
   */

  export type AggregateSubProjectService = {
    _count: SubProjectServiceCountAggregateOutputType | null
    _avg: SubProjectServiceAvgAggregateOutputType | null
    _sum: SubProjectServiceSumAggregateOutputType | null
    _min: SubProjectServiceMinAggregateOutputType | null
    _max: SubProjectServiceMaxAggregateOutputType | null
  }

  export type SubProjectServiceAvgAggregateOutputType = {
    subproject_service_id: number | null
    subproject_id: number | null
    service_id: number | null
  }

  export type SubProjectServiceSumAggregateOutputType = {
    subproject_service_id: number | null
    subproject_id: number | null
    service_id: number | null
  }

  export type SubProjectServiceMinAggregateOutputType = {
    subproject_service_id: number | null
    subproject_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type SubProjectServiceMaxAggregateOutputType = {
    subproject_service_id: number | null
    subproject_id: number | null
    service_id: number | null
    created_at: Date | null
  }

  export type SubProjectServiceCountAggregateOutputType = {
    subproject_service_id: number
    subproject_id: number
    service_id: number
    created_at: number
    _all: number
  }


  export type SubProjectServiceAvgAggregateInputType = {
    subproject_service_id?: true
    subproject_id?: true
    service_id?: true
  }

  export type SubProjectServiceSumAggregateInputType = {
    subproject_service_id?: true
    subproject_id?: true
    service_id?: true
  }

  export type SubProjectServiceMinAggregateInputType = {
    subproject_service_id?: true
    subproject_id?: true
    service_id?: true
    created_at?: true
  }

  export type SubProjectServiceMaxAggregateInputType = {
    subproject_service_id?: true
    subproject_id?: true
    service_id?: true
    created_at?: true
  }

  export type SubProjectServiceCountAggregateInputType = {
    subproject_service_id?: true
    subproject_id?: true
    service_id?: true
    created_at?: true
    _all?: true
  }

  export type SubProjectServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectService to aggregate.
     */
    where?: SubProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectServices to fetch.
     */
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubProjectServices
    **/
    _count?: true | SubProjectServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubProjectServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubProjectServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubProjectServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubProjectServiceMaxAggregateInputType
  }

  export type GetSubProjectServiceAggregateType<T extends SubProjectServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSubProjectService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubProjectService[P]>
      : GetScalarType<T[P], AggregateSubProjectService[P]>
  }




  export type SubProjectServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectServiceWhereInput
    orderBy?: SubProjectServiceOrderByWithAggregationInput | SubProjectServiceOrderByWithAggregationInput[]
    by: SubProjectServiceScalarFieldEnum[] | SubProjectServiceScalarFieldEnum
    having?: SubProjectServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubProjectServiceCountAggregateInputType | true
    _avg?: SubProjectServiceAvgAggregateInputType
    _sum?: SubProjectServiceSumAggregateInputType
    _min?: SubProjectServiceMinAggregateInputType
    _max?: SubProjectServiceMaxAggregateInputType
  }

  export type SubProjectServiceGroupByOutputType = {
    subproject_service_id: number
    subproject_id: number
    service_id: number
    created_at: Date
    _count: SubProjectServiceCountAggregateOutputType | null
    _avg: SubProjectServiceAvgAggregateOutputType | null
    _sum: SubProjectServiceSumAggregateOutputType | null
    _min: SubProjectServiceMinAggregateOutputType | null
    _max: SubProjectServiceMaxAggregateOutputType | null
  }

  type GetSubProjectServiceGroupByPayload<T extends SubProjectServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubProjectServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubProjectServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubProjectServiceGroupByOutputType[P]>
            : GetScalarType<T[P], SubProjectServiceGroupByOutputType[P]>
        }
      >
    >


  export type SubProjectServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_service_id?: boolean
    subproject_id?: boolean
    service_id?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectService"]>

  export type SubProjectServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subproject_service_id?: boolean
    subproject_id?: boolean
    service_id?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectService"]>

  export type SubProjectServiceSelectScalar = {
    subproject_service_id?: boolean
    subproject_id?: boolean
    service_id?: boolean
    created_at?: boolean
  }

  export type SubProjectServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type SubProjectServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $SubProjectServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubProjectService"
    objects: {
      subproject: Prisma.$SubProjectPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      subproject_service_id: number
      subproject_id: number
      service_id: number
      created_at: Date
    }, ExtArgs["result"]["subProjectService"]>
    composites: {}
  }

  type SubProjectServiceGetPayload<S extends boolean | null | undefined | SubProjectServiceDefaultArgs> = $Result.GetResult<Prisma.$SubProjectServicePayload, S>

  type SubProjectServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubProjectServiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubProjectServiceCountAggregateInputType | true
    }

  export interface SubProjectServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubProjectService'], meta: { name: 'SubProjectService' } }
    /**
     * Find zero or one SubProjectService that matches the filter.
     * @param {SubProjectServiceFindUniqueArgs} args - Arguments to find a SubProjectService
     * @example
     * // Get one SubProjectService
     * const subProjectService = await prisma.subProjectService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubProjectServiceFindUniqueArgs>(args: SelectSubset<T, SubProjectServiceFindUniqueArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubProjectService that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubProjectServiceFindUniqueOrThrowArgs} args - Arguments to find a SubProjectService
     * @example
     * // Get one SubProjectService
     * const subProjectService = await prisma.subProjectService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubProjectServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SubProjectServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubProjectService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceFindFirstArgs} args - Arguments to find a SubProjectService
     * @example
     * // Get one SubProjectService
     * const subProjectService = await prisma.subProjectService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubProjectServiceFindFirstArgs>(args?: SelectSubset<T, SubProjectServiceFindFirstArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubProjectService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceFindFirstOrThrowArgs} args - Arguments to find a SubProjectService
     * @example
     * // Get one SubProjectService
     * const subProjectService = await prisma.subProjectService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubProjectServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SubProjectServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubProjectServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubProjectServices
     * const subProjectServices = await prisma.subProjectService.findMany()
     * 
     * // Get first 10 SubProjectServices
     * const subProjectServices = await prisma.subProjectService.findMany({ take: 10 })
     * 
     * // Only select the `subproject_service_id`
     * const subProjectServiceWithSubproject_service_idOnly = await prisma.subProjectService.findMany({ select: { subproject_service_id: true } })
     * 
     */
    findMany<T extends SubProjectServiceFindManyArgs>(args?: SelectSubset<T, SubProjectServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubProjectService.
     * @param {SubProjectServiceCreateArgs} args - Arguments to create a SubProjectService.
     * @example
     * // Create one SubProjectService
     * const SubProjectService = await prisma.subProjectService.create({
     *   data: {
     *     // ... data to create a SubProjectService
     *   }
     * })
     * 
     */
    create<T extends SubProjectServiceCreateArgs>(args: SelectSubset<T, SubProjectServiceCreateArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubProjectServices.
     * @param {SubProjectServiceCreateManyArgs} args - Arguments to create many SubProjectServices.
     * @example
     * // Create many SubProjectServices
     * const subProjectService = await prisma.subProjectService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubProjectServiceCreateManyArgs>(args?: SelectSubset<T, SubProjectServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubProjectServices and returns the data saved in the database.
     * @param {SubProjectServiceCreateManyAndReturnArgs} args - Arguments to create many SubProjectServices.
     * @example
     * // Create many SubProjectServices
     * const subProjectService = await prisma.subProjectService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubProjectServices and only return the `subproject_service_id`
     * const subProjectServiceWithSubproject_service_idOnly = await prisma.subProjectService.createManyAndReturn({ 
     *   select: { subproject_service_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubProjectServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SubProjectServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubProjectService.
     * @param {SubProjectServiceDeleteArgs} args - Arguments to delete one SubProjectService.
     * @example
     * // Delete one SubProjectService
     * const SubProjectService = await prisma.subProjectService.delete({
     *   where: {
     *     // ... filter to delete one SubProjectService
     *   }
     * })
     * 
     */
    delete<T extends SubProjectServiceDeleteArgs>(args: SelectSubset<T, SubProjectServiceDeleteArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubProjectService.
     * @param {SubProjectServiceUpdateArgs} args - Arguments to update one SubProjectService.
     * @example
     * // Update one SubProjectService
     * const subProjectService = await prisma.subProjectService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubProjectServiceUpdateArgs>(args: SelectSubset<T, SubProjectServiceUpdateArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubProjectServices.
     * @param {SubProjectServiceDeleteManyArgs} args - Arguments to filter SubProjectServices to delete.
     * @example
     * // Delete a few SubProjectServices
     * const { count } = await prisma.subProjectService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubProjectServiceDeleteManyArgs>(args?: SelectSubset<T, SubProjectServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubProjectServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubProjectServices
     * const subProjectService = await prisma.subProjectService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubProjectServiceUpdateManyArgs>(args: SelectSubset<T, SubProjectServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubProjectService.
     * @param {SubProjectServiceUpsertArgs} args - Arguments to update or create a SubProjectService.
     * @example
     * // Update or create a SubProjectService
     * const subProjectService = await prisma.subProjectService.upsert({
     *   create: {
     *     // ... data to create a SubProjectService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubProjectService we want to update
     *   }
     * })
     */
    upsert<T extends SubProjectServiceUpsertArgs>(args: SelectSubset<T, SubProjectServiceUpsertArgs<ExtArgs>>): Prisma__SubProjectServiceClient<$Result.GetResult<Prisma.$SubProjectServicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubProjectServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceCountArgs} args - Arguments to filter SubProjectServices to count.
     * @example
     * // Count the number of SubProjectServices
     * const count = await prisma.subProjectService.count({
     *   where: {
     *     // ... the filter for the SubProjectServices we want to count
     *   }
     * })
    **/
    count<T extends SubProjectServiceCountArgs>(
      args?: Subset<T, SubProjectServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubProjectServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubProjectService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubProjectServiceAggregateArgs>(args: Subset<T, SubProjectServiceAggregateArgs>): Prisma.PrismaPromise<GetSubProjectServiceAggregateType<T>>

    /**
     * Group by SubProjectService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubProjectServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubProjectServiceGroupByArgs['orderBy'] }
        : { orderBy?: SubProjectServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubProjectServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubProjectServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubProjectService model
   */
  readonly fields: SubProjectServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubProjectService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubProjectServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subproject<T extends SubProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubProjectDefaultArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubProjectService model
   */ 
  interface SubProjectServiceFieldRefs {
    readonly subproject_service_id: FieldRef<"SubProjectService", 'Int'>
    readonly subproject_id: FieldRef<"SubProjectService", 'Int'>
    readonly service_id: FieldRef<"SubProjectService", 'Int'>
    readonly created_at: FieldRef<"SubProjectService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubProjectService findUnique
   */
  export type SubProjectServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectService to fetch.
     */
    where: SubProjectServiceWhereUniqueInput
  }

  /**
   * SubProjectService findUniqueOrThrow
   */
  export type SubProjectServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectService to fetch.
     */
    where: SubProjectServiceWhereUniqueInput
  }

  /**
   * SubProjectService findFirst
   */
  export type SubProjectServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectService to fetch.
     */
    where?: SubProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectServices to fetch.
     */
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectServices.
     */
    cursor?: SubProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectServices.
     */
    distinct?: SubProjectServiceScalarFieldEnum | SubProjectServiceScalarFieldEnum[]
  }

  /**
   * SubProjectService findFirstOrThrow
   */
  export type SubProjectServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectService to fetch.
     */
    where?: SubProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectServices to fetch.
     */
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectServices.
     */
    cursor?: SubProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectServices.
     */
    distinct?: SubProjectServiceScalarFieldEnum | SubProjectServiceScalarFieldEnum[]
  }

  /**
   * SubProjectService findMany
   */
  export type SubProjectServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectServices to fetch.
     */
    where?: SubProjectServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectServices to fetch.
     */
    orderBy?: SubProjectServiceOrderByWithRelationInput | SubProjectServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubProjectServices.
     */
    cursor?: SubProjectServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectServices.
     */
    skip?: number
    distinct?: SubProjectServiceScalarFieldEnum | SubProjectServiceScalarFieldEnum[]
  }

  /**
   * SubProjectService create
   */
  export type SubProjectServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SubProjectService.
     */
    data: XOR<SubProjectServiceCreateInput, SubProjectServiceUncheckedCreateInput>
  }

  /**
   * SubProjectService createMany
   */
  export type SubProjectServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubProjectServices.
     */
    data: SubProjectServiceCreateManyInput | SubProjectServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProjectService createManyAndReturn
   */
  export type SubProjectServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubProjectServices.
     */
    data: SubProjectServiceCreateManyInput | SubProjectServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubProjectService update
   */
  export type SubProjectServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SubProjectService.
     */
    data: XOR<SubProjectServiceUpdateInput, SubProjectServiceUncheckedUpdateInput>
    /**
     * Choose, which SubProjectService to update.
     */
    where: SubProjectServiceWhereUniqueInput
  }

  /**
   * SubProjectService updateMany
   */
  export type SubProjectServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubProjectServices.
     */
    data: XOR<SubProjectServiceUpdateManyMutationInput, SubProjectServiceUncheckedUpdateManyInput>
    /**
     * Filter which SubProjectServices to update
     */
    where?: SubProjectServiceWhereInput
  }

  /**
   * SubProjectService upsert
   */
  export type SubProjectServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SubProjectService to update in case it exists.
     */
    where: SubProjectServiceWhereUniqueInput
    /**
     * In case the SubProjectService found by the `where` argument doesn't exist, create a new SubProjectService with this data.
     */
    create: XOR<SubProjectServiceCreateInput, SubProjectServiceUncheckedCreateInput>
    /**
     * In case the SubProjectService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubProjectServiceUpdateInput, SubProjectServiceUncheckedUpdateInput>
  }

  /**
   * SubProjectService delete
   */
  export type SubProjectServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
    /**
     * Filter which SubProjectService to delete.
     */
    where: SubProjectServiceWhereUniqueInput
  }

  /**
   * SubProjectService deleteMany
   */
  export type SubProjectServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectServices to delete
     */
    where?: SubProjectServiceWhereInput
  }

  /**
   * SubProjectService without action
   */
  export type SubProjectServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectService
     */
    select?: SubProjectServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectServiceInclude<ExtArgs> | null
  }


  /**
   * Model ProjectComment
   */

  export type AggregateProjectComment = {
    _count: ProjectCommentCountAggregateOutputType | null
    _avg: ProjectCommentAvgAggregateOutputType | null
    _sum: ProjectCommentSumAggregateOutputType | null
    _min: ProjectCommentMinAggregateOutputType | null
    _max: ProjectCommentMaxAggregateOutputType | null
  }

  export type ProjectCommentAvgAggregateOutputType = {
    comment_id: number | null
    project_id: number | null
    manager_id: number | null
  }

  export type ProjectCommentSumAggregateOutputType = {
    comment_id: number | null
    project_id: number | null
    manager_id: number | null
  }

  export type ProjectCommentMinAggregateOutputType = {
    comment_id: number | null
    project_id: number | null
    manager_id: number | null
    content: string | null
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type ProjectCommentMaxAggregateOutputType = {
    comment_id: number | null
    project_id: number | null
    manager_id: number | null
    content: string | null
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type ProjectCommentCountAggregateOutputType = {
    comment_id: number
    project_id: number
    manager_id: number
    content: number
    file_name: number
    file_type: number
    file_url: number
    created_at: number
    _all: number
  }


  export type ProjectCommentAvgAggregateInputType = {
    comment_id?: true
    project_id?: true
    manager_id?: true
  }

  export type ProjectCommentSumAggregateInputType = {
    comment_id?: true
    project_id?: true
    manager_id?: true
  }

  export type ProjectCommentMinAggregateInputType = {
    comment_id?: true
    project_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
  }

  export type ProjectCommentMaxAggregateInputType = {
    comment_id?: true
    project_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
  }

  export type ProjectCommentCountAggregateInputType = {
    comment_id?: true
    project_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
    _all?: true
  }

  export type ProjectCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectComment to aggregate.
     */
    where?: ProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectComments to fetch.
     */
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectComments
    **/
    _count?: true | ProjectCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectCommentMaxAggregateInputType
  }

  export type GetProjectCommentAggregateType<T extends ProjectCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectComment[P]>
      : GetScalarType<T[P], AggregateProjectComment[P]>
  }




  export type ProjectCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectCommentWhereInput
    orderBy?: ProjectCommentOrderByWithAggregationInput | ProjectCommentOrderByWithAggregationInput[]
    by: ProjectCommentScalarFieldEnum[] | ProjectCommentScalarFieldEnum
    having?: ProjectCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCommentCountAggregateInputType | true
    _avg?: ProjectCommentAvgAggregateInputType
    _sum?: ProjectCommentSumAggregateInputType
    _min?: ProjectCommentMinAggregateInputType
    _max?: ProjectCommentMaxAggregateInputType
  }

  export type ProjectCommentGroupByOutputType = {
    comment_id: number
    project_id: number
    manager_id: number
    content: string
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date
    _count: ProjectCommentCountAggregateOutputType | null
    _avg: ProjectCommentAvgAggregateOutputType | null
    _sum: ProjectCommentSumAggregateOutputType | null
    _min: ProjectCommentMinAggregateOutputType | null
    _max: ProjectCommentMaxAggregateOutputType | null
  }

  type GetProjectCommentGroupByPayload<T extends ProjectCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectCommentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    project_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectComment"]>

  export type ProjectCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    project_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectComment"]>

  export type ProjectCommentSelectScalar = {
    comment_id?: boolean
    project_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
  }

  export type ProjectCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type ProjectCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }

  export type $ProjectCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectComment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      manager: Prisma.$ManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      project_id: number
      manager_id: number
      content: string
      file_name: string | null
      file_type: string | null
      file_url: string | null
      created_at: Date
    }, ExtArgs["result"]["projectComment"]>
    composites: {}
  }

  type ProjectCommentGetPayload<S extends boolean | null | undefined | ProjectCommentDefaultArgs> = $Result.GetResult<Prisma.$ProjectCommentPayload, S>

  type ProjectCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCommentCountAggregateInputType | true
    }

  export interface ProjectCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectComment'], meta: { name: 'ProjectComment' } }
    /**
     * Find zero or one ProjectComment that matches the filter.
     * @param {ProjectCommentFindUniqueArgs} args - Arguments to find a ProjectComment
     * @example
     * // Get one ProjectComment
     * const projectComment = await prisma.projectComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectCommentFindUniqueArgs>(args: SelectSubset<T, ProjectCommentFindUniqueArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectCommentFindUniqueOrThrowArgs} args - Arguments to find a ProjectComment
     * @example
     * // Get one ProjectComment
     * const projectComment = await prisma.projectComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentFindFirstArgs} args - Arguments to find a ProjectComment
     * @example
     * // Get one ProjectComment
     * const projectComment = await prisma.projectComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectCommentFindFirstArgs>(args?: SelectSubset<T, ProjectCommentFindFirstArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentFindFirstOrThrowArgs} args - Arguments to find a ProjectComment
     * @example
     * // Get one ProjectComment
     * const projectComment = await prisma.projectComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectComments
     * const projectComments = await prisma.projectComment.findMany()
     * 
     * // Get first 10 ProjectComments
     * const projectComments = await prisma.projectComment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const projectCommentWithComment_idOnly = await prisma.projectComment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends ProjectCommentFindManyArgs>(args?: SelectSubset<T, ProjectCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectComment.
     * @param {ProjectCommentCreateArgs} args - Arguments to create a ProjectComment.
     * @example
     * // Create one ProjectComment
     * const ProjectComment = await prisma.projectComment.create({
     *   data: {
     *     // ... data to create a ProjectComment
     *   }
     * })
     * 
     */
    create<T extends ProjectCommentCreateArgs>(args: SelectSubset<T, ProjectCommentCreateArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectComments.
     * @param {ProjectCommentCreateManyArgs} args - Arguments to create many ProjectComments.
     * @example
     * // Create many ProjectComments
     * const projectComment = await prisma.projectComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCommentCreateManyArgs>(args?: SelectSubset<T, ProjectCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectComments and returns the data saved in the database.
     * @param {ProjectCommentCreateManyAndReturnArgs} args - Arguments to create many ProjectComments.
     * @example
     * // Create many ProjectComments
     * const projectComment = await prisma.projectComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectComments and only return the `comment_id`
     * const projectCommentWithComment_idOnly = await prisma.projectComment.createManyAndReturn({ 
     *   select: { comment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectComment.
     * @param {ProjectCommentDeleteArgs} args - Arguments to delete one ProjectComment.
     * @example
     * // Delete one ProjectComment
     * const ProjectComment = await prisma.projectComment.delete({
     *   where: {
     *     // ... filter to delete one ProjectComment
     *   }
     * })
     * 
     */
    delete<T extends ProjectCommentDeleteArgs>(args: SelectSubset<T, ProjectCommentDeleteArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectComment.
     * @param {ProjectCommentUpdateArgs} args - Arguments to update one ProjectComment.
     * @example
     * // Update one ProjectComment
     * const projectComment = await prisma.projectComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectCommentUpdateArgs>(args: SelectSubset<T, ProjectCommentUpdateArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectComments.
     * @param {ProjectCommentDeleteManyArgs} args - Arguments to filter ProjectComments to delete.
     * @example
     * // Delete a few ProjectComments
     * const { count } = await prisma.projectComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectCommentDeleteManyArgs>(args?: SelectSubset<T, ProjectCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectComments
     * const projectComment = await prisma.projectComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectCommentUpdateManyArgs>(args: SelectSubset<T, ProjectCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectComment.
     * @param {ProjectCommentUpsertArgs} args - Arguments to update or create a ProjectComment.
     * @example
     * // Update or create a ProjectComment
     * const projectComment = await prisma.projectComment.upsert({
     *   create: {
     *     // ... data to create a ProjectComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectComment we want to update
     *   }
     * })
     */
    upsert<T extends ProjectCommentUpsertArgs>(args: SelectSubset<T, ProjectCommentUpsertArgs<ExtArgs>>): Prisma__ProjectCommentClient<$Result.GetResult<Prisma.$ProjectCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentCountArgs} args - Arguments to filter ProjectComments to count.
     * @example
     * // Count the number of ProjectComments
     * const count = await prisma.projectComment.count({
     *   where: {
     *     // ... the filter for the ProjectComments we want to count
     *   }
     * })
    **/
    count<T extends ProjectCommentCountArgs>(
      args?: Subset<T, ProjectCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectCommentAggregateArgs>(args: Subset<T, ProjectCommentAggregateArgs>): Prisma.PrismaPromise<GetProjectCommentAggregateType<T>>

    /**
     * Group by ProjectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectCommentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectComment model
   */
  readonly fields: ProjectCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectComment model
   */ 
  interface ProjectCommentFieldRefs {
    readonly comment_id: FieldRef<"ProjectComment", 'Int'>
    readonly project_id: FieldRef<"ProjectComment", 'Int'>
    readonly manager_id: FieldRef<"ProjectComment", 'Int'>
    readonly content: FieldRef<"ProjectComment", 'String'>
    readonly file_name: FieldRef<"ProjectComment", 'String'>
    readonly file_type: FieldRef<"ProjectComment", 'String'>
    readonly file_url: FieldRef<"ProjectComment", 'String'>
    readonly created_at: FieldRef<"ProjectComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectComment findUnique
   */
  export type ProjectCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectComment to fetch.
     */
    where: ProjectCommentWhereUniqueInput
  }

  /**
   * ProjectComment findUniqueOrThrow
   */
  export type ProjectCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectComment to fetch.
     */
    where: ProjectCommentWhereUniqueInput
  }

  /**
   * ProjectComment findFirst
   */
  export type ProjectCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectComment to fetch.
     */
    where?: ProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectComments to fetch.
     */
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectComments.
     */
    cursor?: ProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectComments.
     */
    distinct?: ProjectCommentScalarFieldEnum | ProjectCommentScalarFieldEnum[]
  }

  /**
   * ProjectComment findFirstOrThrow
   */
  export type ProjectCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectComment to fetch.
     */
    where?: ProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectComments to fetch.
     */
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectComments.
     */
    cursor?: ProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectComments.
     */
    distinct?: ProjectCommentScalarFieldEnum | ProjectCommentScalarFieldEnum[]
  }

  /**
   * ProjectComment findMany
   */
  export type ProjectCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectComments to fetch.
     */
    where?: ProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectComments to fetch.
     */
    orderBy?: ProjectCommentOrderByWithRelationInput | ProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectComments.
     */
    cursor?: ProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectComments.
     */
    skip?: number
    distinct?: ProjectCommentScalarFieldEnum | ProjectCommentScalarFieldEnum[]
  }

  /**
   * ProjectComment create
   */
  export type ProjectCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectComment.
     */
    data: XOR<ProjectCommentCreateInput, ProjectCommentUncheckedCreateInput>
  }

  /**
   * ProjectComment createMany
   */
  export type ProjectCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectComments.
     */
    data: ProjectCommentCreateManyInput | ProjectCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectComment createManyAndReturn
   */
  export type ProjectCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectComments.
     */
    data: ProjectCommentCreateManyInput | ProjectCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectComment update
   */
  export type ProjectCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectComment.
     */
    data: XOR<ProjectCommentUpdateInput, ProjectCommentUncheckedUpdateInput>
    /**
     * Choose, which ProjectComment to update.
     */
    where: ProjectCommentWhereUniqueInput
  }

  /**
   * ProjectComment updateMany
   */
  export type ProjectCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectComments.
     */
    data: XOR<ProjectCommentUpdateManyMutationInput, ProjectCommentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectComments to update
     */
    where?: ProjectCommentWhereInput
  }

  /**
   * ProjectComment upsert
   */
  export type ProjectCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectComment to update in case it exists.
     */
    where: ProjectCommentWhereUniqueInput
    /**
     * In case the ProjectComment found by the `where` argument doesn't exist, create a new ProjectComment with this data.
     */
    create: XOR<ProjectCommentCreateInput, ProjectCommentUncheckedCreateInput>
    /**
     * In case the ProjectComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectCommentUpdateInput, ProjectCommentUncheckedUpdateInput>
  }

  /**
   * ProjectComment delete
   */
  export type ProjectCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
    /**
     * Filter which ProjectComment to delete.
     */
    where: ProjectCommentWhereUniqueInput
  }

  /**
   * ProjectComment deleteMany
   */
  export type ProjectCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectComments to delete
     */
    where?: ProjectCommentWhereInput
  }

  /**
   * ProjectComment without action
   */
  export type ProjectCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectComment
     */
    select?: ProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectCommentInclude<ExtArgs> | null
  }


  /**
   * Model SubProjectComment
   */

  export type AggregateSubProjectComment = {
    _count: SubProjectCommentCountAggregateOutputType | null
    _avg: SubProjectCommentAvgAggregateOutputType | null
    _sum: SubProjectCommentSumAggregateOutputType | null
    _min: SubProjectCommentMinAggregateOutputType | null
    _max: SubProjectCommentMaxAggregateOutputType | null
  }

  export type SubProjectCommentAvgAggregateOutputType = {
    comment_id: number | null
    subproject_id: number | null
    manager_id: number | null
  }

  export type SubProjectCommentSumAggregateOutputType = {
    comment_id: number | null
    subproject_id: number | null
    manager_id: number | null
  }

  export type SubProjectCommentMinAggregateOutputType = {
    comment_id: number | null
    subproject_id: number | null
    manager_id: number | null
    content: string | null
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type SubProjectCommentMaxAggregateOutputType = {
    comment_id: number | null
    subproject_id: number | null
    manager_id: number | null
    content: string | null
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type SubProjectCommentCountAggregateOutputType = {
    comment_id: number
    subproject_id: number
    manager_id: number
    content: number
    file_name: number
    file_type: number
    file_url: number
    created_at: number
    _all: number
  }


  export type SubProjectCommentAvgAggregateInputType = {
    comment_id?: true
    subproject_id?: true
    manager_id?: true
  }

  export type SubProjectCommentSumAggregateInputType = {
    comment_id?: true
    subproject_id?: true
    manager_id?: true
  }

  export type SubProjectCommentMinAggregateInputType = {
    comment_id?: true
    subproject_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
  }

  export type SubProjectCommentMaxAggregateInputType = {
    comment_id?: true
    subproject_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
  }

  export type SubProjectCommentCountAggregateInputType = {
    comment_id?: true
    subproject_id?: true
    manager_id?: true
    content?: true
    file_name?: true
    file_type?: true
    file_url?: true
    created_at?: true
    _all?: true
  }

  export type SubProjectCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectComment to aggregate.
     */
    where?: SubProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectComments to fetch.
     */
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubProjectComments
    **/
    _count?: true | SubProjectCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubProjectCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubProjectCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubProjectCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubProjectCommentMaxAggregateInputType
  }

  export type GetSubProjectCommentAggregateType<T extends SubProjectCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateSubProjectComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubProjectComment[P]>
      : GetScalarType<T[P], AggregateSubProjectComment[P]>
  }




  export type SubProjectCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubProjectCommentWhereInput
    orderBy?: SubProjectCommentOrderByWithAggregationInput | SubProjectCommentOrderByWithAggregationInput[]
    by: SubProjectCommentScalarFieldEnum[] | SubProjectCommentScalarFieldEnum
    having?: SubProjectCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubProjectCommentCountAggregateInputType | true
    _avg?: SubProjectCommentAvgAggregateInputType
    _sum?: SubProjectCommentSumAggregateInputType
    _min?: SubProjectCommentMinAggregateInputType
    _max?: SubProjectCommentMaxAggregateInputType
  }

  export type SubProjectCommentGroupByOutputType = {
    comment_id: number
    subproject_id: number
    manager_id: number
    content: string
    file_name: string | null
    file_type: string | null
    file_url: string | null
    created_at: Date
    _count: SubProjectCommentCountAggregateOutputType | null
    _avg: SubProjectCommentAvgAggregateOutputType | null
    _sum: SubProjectCommentSumAggregateOutputType | null
    _min: SubProjectCommentMinAggregateOutputType | null
    _max: SubProjectCommentMaxAggregateOutputType | null
  }

  type GetSubProjectCommentGroupByPayload<T extends SubProjectCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubProjectCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubProjectCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubProjectCommentGroupByOutputType[P]>
            : GetScalarType<T[P], SubProjectCommentGroupByOutputType[P]>
        }
      >
    >


  export type SubProjectCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    subproject_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectComment"]>

  export type SubProjectCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    subproject_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subProjectComment"]>

  export type SubProjectCommentSelectScalar = {
    comment_id?: boolean
    subproject_id?: boolean
    manager_id?: boolean
    content?: boolean
    file_name?: boolean
    file_type?: boolean
    file_url?: boolean
    created_at?: boolean
  }

  export type SubProjectCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }
  export type SubProjectCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subproject?: boolean | SubProjectDefaultArgs<ExtArgs>
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
  }

  export type $SubProjectCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubProjectComment"
    objects: {
      subproject: Prisma.$SubProjectPayload<ExtArgs>
      manager: Prisma.$ManagerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      subproject_id: number
      manager_id: number
      content: string
      file_name: string | null
      file_type: string | null
      file_url: string | null
      created_at: Date
    }, ExtArgs["result"]["subProjectComment"]>
    composites: {}
  }

  type SubProjectCommentGetPayload<S extends boolean | null | undefined | SubProjectCommentDefaultArgs> = $Result.GetResult<Prisma.$SubProjectCommentPayload, S>

  type SubProjectCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubProjectCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubProjectCommentCountAggregateInputType | true
    }

  export interface SubProjectCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubProjectComment'], meta: { name: 'SubProjectComment' } }
    /**
     * Find zero or one SubProjectComment that matches the filter.
     * @param {SubProjectCommentFindUniqueArgs} args - Arguments to find a SubProjectComment
     * @example
     * // Get one SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubProjectCommentFindUniqueArgs>(args: SelectSubset<T, SubProjectCommentFindUniqueArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubProjectComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubProjectCommentFindUniqueOrThrowArgs} args - Arguments to find a SubProjectComment
     * @example
     * // Get one SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubProjectCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, SubProjectCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubProjectComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentFindFirstArgs} args - Arguments to find a SubProjectComment
     * @example
     * // Get one SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubProjectCommentFindFirstArgs>(args?: SelectSubset<T, SubProjectCommentFindFirstArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubProjectComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentFindFirstOrThrowArgs} args - Arguments to find a SubProjectComment
     * @example
     * // Get one SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubProjectCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, SubProjectCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubProjectComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubProjectComments
     * const subProjectComments = await prisma.subProjectComment.findMany()
     * 
     * // Get first 10 SubProjectComments
     * const subProjectComments = await prisma.subProjectComment.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const subProjectCommentWithComment_idOnly = await prisma.subProjectComment.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends SubProjectCommentFindManyArgs>(args?: SelectSubset<T, SubProjectCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubProjectComment.
     * @param {SubProjectCommentCreateArgs} args - Arguments to create a SubProjectComment.
     * @example
     * // Create one SubProjectComment
     * const SubProjectComment = await prisma.subProjectComment.create({
     *   data: {
     *     // ... data to create a SubProjectComment
     *   }
     * })
     * 
     */
    create<T extends SubProjectCommentCreateArgs>(args: SelectSubset<T, SubProjectCommentCreateArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubProjectComments.
     * @param {SubProjectCommentCreateManyArgs} args - Arguments to create many SubProjectComments.
     * @example
     * // Create many SubProjectComments
     * const subProjectComment = await prisma.subProjectComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubProjectCommentCreateManyArgs>(args?: SelectSubset<T, SubProjectCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubProjectComments and returns the data saved in the database.
     * @param {SubProjectCommentCreateManyAndReturnArgs} args - Arguments to create many SubProjectComments.
     * @example
     * // Create many SubProjectComments
     * const subProjectComment = await prisma.subProjectComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubProjectComments and only return the `comment_id`
     * const subProjectCommentWithComment_idOnly = await prisma.subProjectComment.createManyAndReturn({ 
     *   select: { comment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubProjectCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, SubProjectCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubProjectComment.
     * @param {SubProjectCommentDeleteArgs} args - Arguments to delete one SubProjectComment.
     * @example
     * // Delete one SubProjectComment
     * const SubProjectComment = await prisma.subProjectComment.delete({
     *   where: {
     *     // ... filter to delete one SubProjectComment
     *   }
     * })
     * 
     */
    delete<T extends SubProjectCommentDeleteArgs>(args: SelectSubset<T, SubProjectCommentDeleteArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubProjectComment.
     * @param {SubProjectCommentUpdateArgs} args - Arguments to update one SubProjectComment.
     * @example
     * // Update one SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubProjectCommentUpdateArgs>(args: SelectSubset<T, SubProjectCommentUpdateArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubProjectComments.
     * @param {SubProjectCommentDeleteManyArgs} args - Arguments to filter SubProjectComments to delete.
     * @example
     * // Delete a few SubProjectComments
     * const { count } = await prisma.subProjectComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubProjectCommentDeleteManyArgs>(args?: SelectSubset<T, SubProjectCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubProjectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubProjectComments
     * const subProjectComment = await prisma.subProjectComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubProjectCommentUpdateManyArgs>(args: SelectSubset<T, SubProjectCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubProjectComment.
     * @param {SubProjectCommentUpsertArgs} args - Arguments to update or create a SubProjectComment.
     * @example
     * // Update or create a SubProjectComment
     * const subProjectComment = await prisma.subProjectComment.upsert({
     *   create: {
     *     // ... data to create a SubProjectComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubProjectComment we want to update
     *   }
     * })
     */
    upsert<T extends SubProjectCommentUpsertArgs>(args: SelectSubset<T, SubProjectCommentUpsertArgs<ExtArgs>>): Prisma__SubProjectCommentClient<$Result.GetResult<Prisma.$SubProjectCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubProjectComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentCountArgs} args - Arguments to filter SubProjectComments to count.
     * @example
     * // Count the number of SubProjectComments
     * const count = await prisma.subProjectComment.count({
     *   where: {
     *     // ... the filter for the SubProjectComments we want to count
     *   }
     * })
    **/
    count<T extends SubProjectCommentCountArgs>(
      args?: Subset<T, SubProjectCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubProjectCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubProjectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubProjectCommentAggregateArgs>(args: Subset<T, SubProjectCommentAggregateArgs>): Prisma.PrismaPromise<GetSubProjectCommentAggregateType<T>>

    /**
     * Group by SubProjectComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubProjectCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubProjectCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubProjectCommentGroupByArgs['orderBy'] }
        : { orderBy?: SubProjectCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubProjectCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubProjectCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubProjectComment model
   */
  readonly fields: SubProjectCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubProjectComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubProjectCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subproject<T extends SubProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubProjectDefaultArgs<ExtArgs>>): Prisma__SubProjectClient<$Result.GetResult<Prisma.$SubProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubProjectComment model
   */ 
  interface SubProjectCommentFieldRefs {
    readonly comment_id: FieldRef<"SubProjectComment", 'Int'>
    readonly subproject_id: FieldRef<"SubProjectComment", 'Int'>
    readonly manager_id: FieldRef<"SubProjectComment", 'Int'>
    readonly content: FieldRef<"SubProjectComment", 'String'>
    readonly file_name: FieldRef<"SubProjectComment", 'String'>
    readonly file_type: FieldRef<"SubProjectComment", 'String'>
    readonly file_url: FieldRef<"SubProjectComment", 'String'>
    readonly created_at: FieldRef<"SubProjectComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubProjectComment findUnique
   */
  export type SubProjectCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectComment to fetch.
     */
    where: SubProjectCommentWhereUniqueInput
  }

  /**
   * SubProjectComment findUniqueOrThrow
   */
  export type SubProjectCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectComment to fetch.
     */
    where: SubProjectCommentWhereUniqueInput
  }

  /**
   * SubProjectComment findFirst
   */
  export type SubProjectCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectComment to fetch.
     */
    where?: SubProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectComments to fetch.
     */
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectComments.
     */
    cursor?: SubProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectComments.
     */
    distinct?: SubProjectCommentScalarFieldEnum | SubProjectCommentScalarFieldEnum[]
  }

  /**
   * SubProjectComment findFirstOrThrow
   */
  export type SubProjectCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectComment to fetch.
     */
    where?: SubProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectComments to fetch.
     */
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubProjectComments.
     */
    cursor?: SubProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubProjectComments.
     */
    distinct?: SubProjectCommentScalarFieldEnum | SubProjectCommentScalarFieldEnum[]
  }

  /**
   * SubProjectComment findMany
   */
  export type SubProjectCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter, which SubProjectComments to fetch.
     */
    where?: SubProjectCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubProjectComments to fetch.
     */
    orderBy?: SubProjectCommentOrderByWithRelationInput | SubProjectCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubProjectComments.
     */
    cursor?: SubProjectCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubProjectComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubProjectComments.
     */
    skip?: number
    distinct?: SubProjectCommentScalarFieldEnum | SubProjectCommentScalarFieldEnum[]
  }

  /**
   * SubProjectComment create
   */
  export type SubProjectCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a SubProjectComment.
     */
    data: XOR<SubProjectCommentCreateInput, SubProjectCommentUncheckedCreateInput>
  }

  /**
   * SubProjectComment createMany
   */
  export type SubProjectCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubProjectComments.
     */
    data: SubProjectCommentCreateManyInput | SubProjectCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubProjectComment createManyAndReturn
   */
  export type SubProjectCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubProjectComments.
     */
    data: SubProjectCommentCreateManyInput | SubProjectCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubProjectComment update
   */
  export type SubProjectCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a SubProjectComment.
     */
    data: XOR<SubProjectCommentUpdateInput, SubProjectCommentUncheckedUpdateInput>
    /**
     * Choose, which SubProjectComment to update.
     */
    where: SubProjectCommentWhereUniqueInput
  }

  /**
   * SubProjectComment updateMany
   */
  export type SubProjectCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubProjectComments.
     */
    data: XOR<SubProjectCommentUpdateManyMutationInput, SubProjectCommentUncheckedUpdateManyInput>
    /**
     * Filter which SubProjectComments to update
     */
    where?: SubProjectCommentWhereInput
  }

  /**
   * SubProjectComment upsert
   */
  export type SubProjectCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the SubProjectComment to update in case it exists.
     */
    where: SubProjectCommentWhereUniqueInput
    /**
     * In case the SubProjectComment found by the `where` argument doesn't exist, create a new SubProjectComment with this data.
     */
    create: XOR<SubProjectCommentCreateInput, SubProjectCommentUncheckedCreateInput>
    /**
     * In case the SubProjectComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubProjectCommentUpdateInput, SubProjectCommentUncheckedUpdateInput>
  }

  /**
   * SubProjectComment delete
   */
  export type SubProjectCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
    /**
     * Filter which SubProjectComment to delete.
     */
    where: SubProjectCommentWhereUniqueInput
  }

  /**
   * SubProjectComment deleteMany
   */
  export type SubProjectCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubProjectComments to delete
     */
    where?: SubProjectCommentWhereInput
  }

  /**
   * SubProjectComment without action
   */
  export type SubProjectCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubProjectComment
     */
    select?: SubProjectCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubProjectCommentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ManagerScalarFieldEnum: {
    manager_id: 'manager_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    role: 'role',
    password_hash: 'password_hash',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const CounterpartyScalarFieldEnum: {
    counterparty_id: 'counterparty_id',
    name: 'name',
    counterparty_type: 'counterparty_type',
    responsible_manager_id: 'responsible_manager_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CounterpartyScalarFieldEnum = (typeof CounterpartyScalarFieldEnum)[keyof typeof CounterpartyScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    unit_id: 'unit_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    warehouse_id: 'warehouse_id',
    name: 'name',
    location: 'location',
    created_at: 'created_at'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    product_id: 'product_id',
    name: 'name',
    description: 'description',
    price: 'price',
    unit_id: 'unit_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductStockScalarFieldEnum: {
    product_stock_id: 'product_stock_id',
    product_id: 'product_id',
    warehouse_id: 'warehouse_id',
    quantity: 'quantity',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductStockScalarFieldEnum = (typeof ProductStockScalarFieldEnum)[keyof typeof ProductStockScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    service_id: 'service_id',
    name: 'name',
    description: 'description',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const SaleStatusTypeScalarFieldEnum: {
    sale_status_id: 'sale_status_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type SaleStatusTypeScalarFieldEnum = (typeof SaleStatusTypeScalarFieldEnum)[keyof typeof SaleStatusTypeScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    sale_id: 'sale_id',
    counterparty_id: 'counterparty_id',
    responsible_manager_id: 'responsible_manager_id',
    sale_date: 'sale_date',
    status: 'status',
    deferred_payment_date: 'deferred_payment_date',
    project_id: 'project_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleProductScalarFieldEnum: {
    sale_id: 'sale_id',
    product_id: 'product_id',
    quantity: 'quantity',
    created_at: 'created_at'
  };

  export type SaleProductScalarFieldEnum = (typeof SaleProductScalarFieldEnum)[keyof typeof SaleProductScalarFieldEnum]


  export const SaleServiceScalarFieldEnum: {
    sale_id: 'sale_id',
    service_id: 'service_id',
    created_at: 'created_at'
  };

  export type SaleServiceScalarFieldEnum = (typeof SaleServiceScalarFieldEnum)[keyof typeof SaleServiceScalarFieldEnum]


  export const FunnelScalarFieldEnum: {
    funnel_id: 'funnel_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type FunnelScalarFieldEnum = (typeof FunnelScalarFieldEnum)[keyof typeof FunnelScalarFieldEnum]


  export const FunnelStageScalarFieldEnum: {
    funnel_stage_id: 'funnel_stage_id',
    name: 'name',
    funnel_id: 'funnel_id',
    order: 'order',
    created_at: 'created_at'
  };

  export type FunnelStageScalarFieldEnum = (typeof FunnelStageScalarFieldEnum)[keyof typeof FunnelStageScalarFieldEnum]


  export const SubProjectStatusTypeScalarFieldEnum: {
    sub_project_status_id: 'sub_project_status_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type SubProjectStatusTypeScalarFieldEnum = (typeof SubProjectStatusTypeScalarFieldEnum)[keyof typeof SubProjectStatusTypeScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    project_id: 'project_id',
    name: 'name',
    description: 'description',
    main_responsible_manager_id: 'main_responsible_manager_id',
    counterparty_id: 'counterparty_id',
    funnel_id: 'funnel_id',
    funnel_stage_id: 'funnel_stage_id',
    forecast_amount: 'forecast_amount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectManagerScalarFieldEnum: {
    project_id: 'project_id',
    manager_id: 'manager_id',
    created_at: 'created_at'
  };

  export type ProjectManagerScalarFieldEnum = (typeof ProjectManagerScalarFieldEnum)[keyof typeof ProjectManagerScalarFieldEnum]


  export const SubProjectScalarFieldEnum: {
    subproject_id: 'subproject_id',
    name: 'name',
    description: 'description',
    project_id: 'project_id',
    status: 'status',
    cost: 'cost',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubProjectScalarFieldEnum = (typeof SubProjectScalarFieldEnum)[keyof typeof SubProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    task_id: 'task_id',
    title: 'title',
    description: 'description',
    responsible_manager_id: 'responsible_manager_id',
    creator_manager_id: 'creator_manager_id',
    project_id: 'project_id',
    subproject_id: 'subproject_id',
    due_date: 'due_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const ProjectProductScalarFieldEnum: {
    project_product_id: 'project_product_id',
    project_id: 'project_id',
    product_id: 'product_id',
    quantity: 'quantity',
    created_at: 'created_at'
  };

  export type ProjectProductScalarFieldEnum = (typeof ProjectProductScalarFieldEnum)[keyof typeof ProjectProductScalarFieldEnum]


  export const ProjectServiceScalarFieldEnum: {
    project_service_id: 'project_service_id',
    project_id: 'project_id',
    service_id: 'service_id',
    created_at: 'created_at'
  };

  export type ProjectServiceScalarFieldEnum = (typeof ProjectServiceScalarFieldEnum)[keyof typeof ProjectServiceScalarFieldEnum]


  export const SubProjectProductScalarFieldEnum: {
    subproject_product_id: 'subproject_product_id',
    subproject_id: 'subproject_id',
    product_id: 'product_id',
    quantity: 'quantity',
    created_at: 'created_at'
  };

  export type SubProjectProductScalarFieldEnum = (typeof SubProjectProductScalarFieldEnum)[keyof typeof SubProjectProductScalarFieldEnum]


  export const SubProjectServiceScalarFieldEnum: {
    subproject_service_id: 'subproject_service_id',
    subproject_id: 'subproject_id',
    service_id: 'service_id',
    created_at: 'created_at'
  };

  export type SubProjectServiceScalarFieldEnum = (typeof SubProjectServiceScalarFieldEnum)[keyof typeof SubProjectServiceScalarFieldEnum]


  export const ProjectCommentScalarFieldEnum: {
    comment_id: 'comment_id',
    project_id: 'project_id',
    manager_id: 'manager_id',
    content: 'content',
    file_name: 'file_name',
    file_type: 'file_type',
    file_url: 'file_url',
    created_at: 'created_at'
  };

  export type ProjectCommentScalarFieldEnum = (typeof ProjectCommentScalarFieldEnum)[keyof typeof ProjectCommentScalarFieldEnum]


  export const SubProjectCommentScalarFieldEnum: {
    comment_id: 'comment_id',
    subproject_id: 'subproject_id',
    manager_id: 'manager_id',
    content: 'content',
    file_name: 'file_name',
    file_type: 'file_type',
    file_url: 'file_url',
    created_at: 'created_at'
  };

  export type SubProjectCommentScalarFieldEnum = (typeof SubProjectCommentScalarFieldEnum)[keyof typeof SubProjectCommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ManagerRole'
   */
  export type EnumManagerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ManagerRole'>
    


  /**
   * Reference to a field of type 'ManagerRole[]'
   */
  export type ListEnumManagerRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ManagerRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CounterpartyType'
   */
  export type EnumCounterpartyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CounterpartyType'>
    


  /**
   * Reference to a field of type 'CounterpartyType[]'
   */
  export type ListEnumCounterpartyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CounterpartyType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    manager_id?: IntFilter<"Manager"> | number
    first_name?: StringFilter<"Manager"> | string
    last_name?: StringFilter<"Manager"> | string
    email?: StringFilter<"Manager"> | string
    phone_number?: StringFilter<"Manager"> | string
    role?: EnumManagerRoleFilter<"Manager"> | $Enums.ManagerRole
    password_hash?: StringFilter<"Manager"> | string
    created_at?: DateTimeFilter<"Manager"> | Date | string
    updated_at?: DateTimeFilter<"Manager"> | Date | string
    supervisors?: ManagerListRelationFilter
    subordinates?: ManagerListRelationFilter
    counterparties?: CounterpartyListRelationFilter
    sales?: SaleListRelationFilter
    projects_as_main?: ProjectListRelationFilter
    projects_as_secondary?: ProjectManagerListRelationFilter
    tasks_as_responsible?: TaskListRelationFilter
    tasks_as_creator?: TaskListRelationFilter
    project_comments?: ProjectCommentListRelationFilter
    subproject_comments?: SubProjectCommentListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    manager_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    supervisors?: ManagerOrderByRelationAggregateInput
    subordinates?: ManagerOrderByRelationAggregateInput
    counterparties?: CounterpartyOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    projects_as_main?: ProjectOrderByRelationAggregateInput
    projects_as_secondary?: ProjectManagerOrderByRelationAggregateInput
    tasks_as_responsible?: TaskOrderByRelationAggregateInput
    tasks_as_creator?: TaskOrderByRelationAggregateInput
    project_comments?: ProjectCommentOrderByRelationAggregateInput
    subproject_comments?: SubProjectCommentOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    manager_id?: number
    email?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    first_name?: StringFilter<"Manager"> | string
    last_name?: StringFilter<"Manager"> | string
    phone_number?: StringFilter<"Manager"> | string
    role?: EnumManagerRoleFilter<"Manager"> | $Enums.ManagerRole
    password_hash?: StringFilter<"Manager"> | string
    created_at?: DateTimeFilter<"Manager"> | Date | string
    updated_at?: DateTimeFilter<"Manager"> | Date | string
    supervisors?: ManagerListRelationFilter
    subordinates?: ManagerListRelationFilter
    counterparties?: CounterpartyListRelationFilter
    sales?: SaleListRelationFilter
    projects_as_main?: ProjectListRelationFilter
    projects_as_secondary?: ProjectManagerListRelationFilter
    tasks_as_responsible?: TaskListRelationFilter
    tasks_as_creator?: TaskListRelationFilter
    project_comments?: ProjectCommentListRelationFilter
    subproject_comments?: SubProjectCommentListRelationFilter
  }, "manager_id" | "email">

  export type ManagerOrderByWithAggregationInput = {
    manager_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _avg?: ManagerAvgOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
    _sum?: ManagerSumOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    manager_id?: IntWithAggregatesFilter<"Manager"> | number
    first_name?: StringWithAggregatesFilter<"Manager"> | string
    last_name?: StringWithAggregatesFilter<"Manager"> | string
    email?: StringWithAggregatesFilter<"Manager"> | string
    phone_number?: StringWithAggregatesFilter<"Manager"> | string
    role?: EnumManagerRoleWithAggregatesFilter<"Manager"> | $Enums.ManagerRole
    password_hash?: StringWithAggregatesFilter<"Manager"> | string
    created_at?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
  }

  export type CounterpartyWhereInput = {
    AND?: CounterpartyWhereInput | CounterpartyWhereInput[]
    OR?: CounterpartyWhereInput[]
    NOT?: CounterpartyWhereInput | CounterpartyWhereInput[]
    counterparty_id?: IntFilter<"Counterparty"> | number
    name?: StringFilter<"Counterparty"> | string
    counterparty_type?: EnumCounterpartyTypeFilter<"Counterparty"> | $Enums.CounterpartyType
    responsible_manager_id?: IntNullableFilter<"Counterparty"> | number | null
    created_at?: DateTimeFilter<"Counterparty"> | Date | string
    updated_at?: DateTimeFilter<"Counterparty"> | Date | string
    responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    sales?: SaleListRelationFilter
    projects?: ProjectListRelationFilter
  }

  export type CounterpartyOrderByWithRelationInput = {
    counterparty_id?: SortOrder
    name?: SortOrder
    counterparty_type?: SortOrder
    responsible_manager_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_manager?: ManagerOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type CounterpartyWhereUniqueInput = Prisma.AtLeast<{
    counterparty_id?: number
    AND?: CounterpartyWhereInput | CounterpartyWhereInput[]
    OR?: CounterpartyWhereInput[]
    NOT?: CounterpartyWhereInput | CounterpartyWhereInput[]
    name?: StringFilter<"Counterparty"> | string
    counterparty_type?: EnumCounterpartyTypeFilter<"Counterparty"> | $Enums.CounterpartyType
    responsible_manager_id?: IntNullableFilter<"Counterparty"> | number | null
    created_at?: DateTimeFilter<"Counterparty"> | Date | string
    updated_at?: DateTimeFilter<"Counterparty"> | Date | string
    responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    sales?: SaleListRelationFilter
    projects?: ProjectListRelationFilter
  }, "counterparty_id">

  export type CounterpartyOrderByWithAggregationInput = {
    counterparty_id?: SortOrder
    name?: SortOrder
    counterparty_type?: SortOrder
    responsible_manager_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CounterpartyCountOrderByAggregateInput
    _avg?: CounterpartyAvgOrderByAggregateInput
    _max?: CounterpartyMaxOrderByAggregateInput
    _min?: CounterpartyMinOrderByAggregateInput
    _sum?: CounterpartySumOrderByAggregateInput
  }

  export type CounterpartyScalarWhereWithAggregatesInput = {
    AND?: CounterpartyScalarWhereWithAggregatesInput | CounterpartyScalarWhereWithAggregatesInput[]
    OR?: CounterpartyScalarWhereWithAggregatesInput[]
    NOT?: CounterpartyScalarWhereWithAggregatesInput | CounterpartyScalarWhereWithAggregatesInput[]
    counterparty_id?: IntWithAggregatesFilter<"Counterparty"> | number
    name?: StringWithAggregatesFilter<"Counterparty"> | string
    counterparty_type?: EnumCounterpartyTypeWithAggregatesFilter<"Counterparty"> | $Enums.CounterpartyType
    responsible_manager_id?: IntNullableWithAggregatesFilter<"Counterparty"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Counterparty"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Counterparty"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    unit_id?: IntFilter<"Unit"> | number
    name?: StringFilter<"Unit"> | string
    created_at?: DateTimeFilter<"Unit"> | Date | string
    products?: ProductListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    unit_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    unit_id?: number
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringFilter<"Unit"> | string
    created_at?: DateTimeFilter<"Unit"> | Date | string
    products?: ProductListRelationFilter
  }, "unit_id">

  export type UnitOrderByWithAggregationInput = {
    unit_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    unit_id?: IntWithAggregatesFilter<"Unit"> | number
    name?: StringWithAggregatesFilter<"Unit"> | string
    created_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    warehouse_id?: IntFilter<"Warehouse"> | number
    name?: StringFilter<"Warehouse"> | string
    location?: StringFilter<"Warehouse"> | string
    created_at?: DateTimeFilter<"Warehouse"> | Date | string
    product_stocks?: ProductStockListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    warehouse_id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    product_stocks?: ProductStockOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    warehouse_id?: number
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    location?: StringFilter<"Warehouse"> | string
    created_at?: DateTimeFilter<"Warehouse"> | Date | string
    product_stocks?: ProductStockListRelationFilter
  }, "warehouse_id">

  export type WarehouseOrderByWithAggregationInput = {
    warehouse_id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    warehouse_id?: IntWithAggregatesFilter<"Warehouse"> | number
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    location?: StringWithAggregatesFilter<"Warehouse"> | string
    created_at?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    product_id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit_id?: IntNullableFilter<"Product"> | number | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    stocks?: ProductStockListRelationFilter
    sales?: SaleProductListRelationFilter
    project_products?: ProjectProductListRelationFilter
    subproject_products?: SubProjectProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    product_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    unit_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
    stocks?: ProductStockOrderByRelationAggregateInput
    sales?: SaleProductOrderByRelationAggregateInput
    project_products?: ProjectProductOrderByRelationAggregateInput
    subproject_products?: SubProjectProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    product_id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit_id?: IntNullableFilter<"Product"> | number | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    stocks?: ProductStockListRelationFilter
    sales?: SaleProductListRelationFilter
    project_products?: ProjectProductListRelationFilter
    subproject_products?: SubProjectProductListRelationFilter
  }, "product_id">

  export type ProductOrderByWithAggregationInput = {
    product_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    unit_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    product_id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit_id?: IntNullableWithAggregatesFilter<"Product"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductStockWhereInput = {
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    product_stock_id?: IntFilter<"ProductStock"> | number
    product_id?: IntFilter<"ProductStock"> | number
    warehouse_id?: IntFilter<"ProductStock"> | number
    quantity?: IntFilter<"ProductStock"> | number
    created_at?: DateTimeFilter<"ProductStock"> | Date | string
    updated_at?: DateTimeFilter<"ProductStock"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
  }

  export type ProductStockOrderByWithRelationInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type ProductStockWhereUniqueInput = Prisma.AtLeast<{
    product_stock_id?: number
    product_id_warehouse_id?: ProductStockProduct_idWarehouse_idCompoundUniqueInput
    AND?: ProductStockWhereInput | ProductStockWhereInput[]
    OR?: ProductStockWhereInput[]
    NOT?: ProductStockWhereInput | ProductStockWhereInput[]
    product_id?: IntFilter<"ProductStock"> | number
    warehouse_id?: IntFilter<"ProductStock"> | number
    quantity?: IntFilter<"ProductStock"> | number
    created_at?: DateTimeFilter<"ProductStock"> | Date | string
    updated_at?: DateTimeFilter<"ProductStock"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
  }, "product_stock_id" | "product_id_warehouse_id">

  export type ProductStockOrderByWithAggregationInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductStockCountOrderByAggregateInput
    _avg?: ProductStockAvgOrderByAggregateInput
    _max?: ProductStockMaxOrderByAggregateInput
    _min?: ProductStockMinOrderByAggregateInput
    _sum?: ProductStockSumOrderByAggregateInput
  }

  export type ProductStockScalarWhereWithAggregatesInput = {
    AND?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    OR?: ProductStockScalarWhereWithAggregatesInput[]
    NOT?: ProductStockScalarWhereWithAggregatesInput | ProductStockScalarWhereWithAggregatesInput[]
    product_stock_id?: IntWithAggregatesFilter<"ProductStock"> | number
    product_id?: IntWithAggregatesFilter<"ProductStock"> | number
    warehouse_id?: IntWithAggregatesFilter<"ProductStock"> | number
    quantity?: IntWithAggregatesFilter<"ProductStock"> | number
    created_at?: DateTimeWithAggregatesFilter<"ProductStock"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductStock"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    service_id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    sales?: SaleServiceListRelationFilter
    project_services?: ProjectServiceListRelationFilter
    subproject_services?: SubProjectServiceListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    service_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sales?: SaleServiceOrderByRelationAggregateInput
    project_services?: ProjectServiceOrderByRelationAggregateInput
    subproject_services?: SubProjectServiceOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    service_id?: number
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    price?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    sales?: SaleServiceListRelationFilter
    project_services?: ProjectServiceListRelationFilter
    subproject_services?: SubProjectServiceListRelationFilter
  }, "service_id">

  export type ServiceOrderByWithAggregationInput = {
    service_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    service_id?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type SaleStatusTypeWhereInput = {
    AND?: SaleStatusTypeWhereInput | SaleStatusTypeWhereInput[]
    OR?: SaleStatusTypeWhereInput[]
    NOT?: SaleStatusTypeWhereInput | SaleStatusTypeWhereInput[]
    sale_status_id?: IntFilter<"SaleStatusType"> | number
    name?: StringFilter<"SaleStatusType"> | string
    created_at?: DateTimeFilter<"SaleStatusType"> | Date | string
    sales?: SaleListRelationFilter
  }

  export type SaleStatusTypeOrderByWithRelationInput = {
    sale_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    sales?: SaleOrderByRelationAggregateInput
  }

  export type SaleStatusTypeWhereUniqueInput = Prisma.AtLeast<{
    sale_status_id?: number
    name?: string
    AND?: SaleStatusTypeWhereInput | SaleStatusTypeWhereInput[]
    OR?: SaleStatusTypeWhereInput[]
    NOT?: SaleStatusTypeWhereInput | SaleStatusTypeWhereInput[]
    created_at?: DateTimeFilter<"SaleStatusType"> | Date | string
    sales?: SaleListRelationFilter
  }, "sale_status_id" | "name">

  export type SaleStatusTypeOrderByWithAggregationInput = {
    sale_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: SaleStatusTypeCountOrderByAggregateInput
    _avg?: SaleStatusTypeAvgOrderByAggregateInput
    _max?: SaleStatusTypeMaxOrderByAggregateInput
    _min?: SaleStatusTypeMinOrderByAggregateInput
    _sum?: SaleStatusTypeSumOrderByAggregateInput
  }

  export type SaleStatusTypeScalarWhereWithAggregatesInput = {
    AND?: SaleStatusTypeScalarWhereWithAggregatesInput | SaleStatusTypeScalarWhereWithAggregatesInput[]
    OR?: SaleStatusTypeScalarWhereWithAggregatesInput[]
    NOT?: SaleStatusTypeScalarWhereWithAggregatesInput | SaleStatusTypeScalarWhereWithAggregatesInput[]
    sale_status_id?: IntWithAggregatesFilter<"SaleStatusType"> | number
    name?: StringWithAggregatesFilter<"SaleStatusType"> | string
    created_at?: DateTimeWithAggregatesFilter<"SaleStatusType"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    sale_id?: IntFilter<"Sale"> | number
    counterparty_id?: IntFilter<"Sale"> | number
    responsible_manager_id?: IntFilter<"Sale"> | number
    sale_date?: DateTimeFilter<"Sale"> | Date | string
    status?: StringFilter<"Sale"> | string
    deferred_payment_date?: DateTimeNullableFilter<"Sale"> | Date | string | null
    project_id?: IntNullableFilter<"Sale"> | number | null
    created_at?: DateTimeFilter<"Sale"> | Date | string
    updated_at?: DateTimeFilter<"Sale"> | Date | string
    counterparty?: XOR<CounterpartyRelationFilter, CounterpartyWhereInput>
    responsible_manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    products?: SaleProductListRelationFilter
    services?: SaleServiceListRelationFilter
    sale_status_type?: XOR<SaleStatusTypeNullableRelationFilter, SaleStatusTypeWhereInput> | null
  }

  export type SaleOrderByWithRelationInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    sale_date?: SortOrder
    status?: SortOrder
    deferred_payment_date?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    counterparty?: CounterpartyOrderByWithRelationInput
    responsible_manager?: ManagerOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    products?: SaleProductOrderByRelationAggregateInput
    services?: SaleServiceOrderByRelationAggregateInput
    sale_status_type?: SaleStatusTypeOrderByWithRelationInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    sale_id?: number
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    counterparty_id?: IntFilter<"Sale"> | number
    responsible_manager_id?: IntFilter<"Sale"> | number
    sale_date?: DateTimeFilter<"Sale"> | Date | string
    status?: StringFilter<"Sale"> | string
    deferred_payment_date?: DateTimeNullableFilter<"Sale"> | Date | string | null
    project_id?: IntNullableFilter<"Sale"> | number | null
    created_at?: DateTimeFilter<"Sale"> | Date | string
    updated_at?: DateTimeFilter<"Sale"> | Date | string
    counterparty?: XOR<CounterpartyRelationFilter, CounterpartyWhereInput>
    responsible_manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    products?: SaleProductListRelationFilter
    services?: SaleServiceListRelationFilter
    sale_status_type?: XOR<SaleStatusTypeNullableRelationFilter, SaleStatusTypeWhereInput> | null
  }, "sale_id">

  export type SaleOrderByWithAggregationInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    sale_date?: SortOrder
    status?: SortOrder
    deferred_payment_date?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    sale_id?: IntWithAggregatesFilter<"Sale"> | number
    counterparty_id?: IntWithAggregatesFilter<"Sale"> | number
    responsible_manager_id?: IntWithAggregatesFilter<"Sale"> | number
    sale_date?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    status?: StringWithAggregatesFilter<"Sale"> | string
    deferred_payment_date?: DateTimeNullableWithAggregatesFilter<"Sale"> | Date | string | null
    project_id?: IntNullableWithAggregatesFilter<"Sale"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleProductWhereInput = {
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    sale_id?: IntFilter<"SaleProduct"> | number
    product_id?: IntFilter<"SaleProduct"> | number
    quantity?: IntFilter<"SaleProduct"> | number
    created_at?: DateTimeFilter<"SaleProduct"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type SaleProductOrderByWithRelationInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SaleProductWhereUniqueInput = Prisma.AtLeast<{
    sale_id_product_id?: SaleProductSale_idProduct_idCompoundUniqueInput
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    sale_id?: IntFilter<"SaleProduct"> | number
    product_id?: IntFilter<"SaleProduct"> | number
    quantity?: IntFilter<"SaleProduct"> | number
    created_at?: DateTimeFilter<"SaleProduct"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "sale_id_product_id">

  export type SaleProductOrderByWithAggregationInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    _count?: SaleProductCountOrderByAggregateInput
    _avg?: SaleProductAvgOrderByAggregateInput
    _max?: SaleProductMaxOrderByAggregateInput
    _min?: SaleProductMinOrderByAggregateInput
    _sum?: SaleProductSumOrderByAggregateInput
  }

  export type SaleProductScalarWhereWithAggregatesInput = {
    AND?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    OR?: SaleProductScalarWhereWithAggregatesInput[]
    NOT?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    sale_id?: IntWithAggregatesFilter<"SaleProduct"> | number
    product_id?: IntWithAggregatesFilter<"SaleProduct"> | number
    quantity?: IntWithAggregatesFilter<"SaleProduct"> | number
    created_at?: DateTimeWithAggregatesFilter<"SaleProduct"> | Date | string
  }

  export type SaleServiceWhereInput = {
    AND?: SaleServiceWhereInput | SaleServiceWhereInput[]
    OR?: SaleServiceWhereInput[]
    NOT?: SaleServiceWhereInput | SaleServiceWhereInput[]
    sale_id?: IntFilter<"SaleService"> | number
    service_id?: IntFilter<"SaleService"> | number
    created_at?: DateTimeFilter<"SaleService"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type SaleServiceOrderByWithRelationInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    sale?: SaleOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type SaleServiceWhereUniqueInput = Prisma.AtLeast<{
    sale_id_service_id?: SaleServiceSale_idService_idCompoundUniqueInput
    AND?: SaleServiceWhereInput | SaleServiceWhereInput[]
    OR?: SaleServiceWhereInput[]
    NOT?: SaleServiceWhereInput | SaleServiceWhereInput[]
    sale_id?: IntFilter<"SaleService"> | number
    service_id?: IntFilter<"SaleService"> | number
    created_at?: DateTimeFilter<"SaleService"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "sale_id_service_id">

  export type SaleServiceOrderByWithAggregationInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    _count?: SaleServiceCountOrderByAggregateInput
    _avg?: SaleServiceAvgOrderByAggregateInput
    _max?: SaleServiceMaxOrderByAggregateInput
    _min?: SaleServiceMinOrderByAggregateInput
    _sum?: SaleServiceSumOrderByAggregateInput
  }

  export type SaleServiceScalarWhereWithAggregatesInput = {
    AND?: SaleServiceScalarWhereWithAggregatesInput | SaleServiceScalarWhereWithAggregatesInput[]
    OR?: SaleServiceScalarWhereWithAggregatesInput[]
    NOT?: SaleServiceScalarWhereWithAggregatesInput | SaleServiceScalarWhereWithAggregatesInput[]
    sale_id?: IntWithAggregatesFilter<"SaleService"> | number
    service_id?: IntWithAggregatesFilter<"SaleService"> | number
    created_at?: DateTimeWithAggregatesFilter<"SaleService"> | Date | string
  }

  export type FunnelWhereInput = {
    AND?: FunnelWhereInput | FunnelWhereInput[]
    OR?: FunnelWhereInput[]
    NOT?: FunnelWhereInput | FunnelWhereInput[]
    funnel_id?: IntFilter<"Funnel"> | number
    name?: StringFilter<"Funnel"> | string
    created_at?: DateTimeFilter<"Funnel"> | Date | string
    stages?: FunnelStageListRelationFilter
    projects?: ProjectListRelationFilter
  }

  export type FunnelOrderByWithRelationInput = {
    funnel_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    stages?: FunnelStageOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type FunnelWhereUniqueInput = Prisma.AtLeast<{
    funnel_id?: number
    AND?: FunnelWhereInput | FunnelWhereInput[]
    OR?: FunnelWhereInput[]
    NOT?: FunnelWhereInput | FunnelWhereInput[]
    name?: StringFilter<"Funnel"> | string
    created_at?: DateTimeFilter<"Funnel"> | Date | string
    stages?: FunnelStageListRelationFilter
    projects?: ProjectListRelationFilter
  }, "funnel_id">

  export type FunnelOrderByWithAggregationInput = {
    funnel_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: FunnelCountOrderByAggregateInput
    _avg?: FunnelAvgOrderByAggregateInput
    _max?: FunnelMaxOrderByAggregateInput
    _min?: FunnelMinOrderByAggregateInput
    _sum?: FunnelSumOrderByAggregateInput
  }

  export type FunnelScalarWhereWithAggregatesInput = {
    AND?: FunnelScalarWhereWithAggregatesInput | FunnelScalarWhereWithAggregatesInput[]
    OR?: FunnelScalarWhereWithAggregatesInput[]
    NOT?: FunnelScalarWhereWithAggregatesInput | FunnelScalarWhereWithAggregatesInput[]
    funnel_id?: IntWithAggregatesFilter<"Funnel"> | number
    name?: StringWithAggregatesFilter<"Funnel"> | string
    created_at?: DateTimeWithAggregatesFilter<"Funnel"> | Date | string
  }

  export type FunnelStageWhereInput = {
    AND?: FunnelStageWhereInput | FunnelStageWhereInput[]
    OR?: FunnelStageWhereInput[]
    NOT?: FunnelStageWhereInput | FunnelStageWhereInput[]
    funnel_stage_id?: IntFilter<"FunnelStage"> | number
    name?: StringFilter<"FunnelStage"> | string
    funnel_id?: IntFilter<"FunnelStage"> | number
    order?: IntFilter<"FunnelStage"> | number
    created_at?: DateTimeFilter<"FunnelStage"> | Date | string
    funnel?: XOR<FunnelRelationFilter, FunnelWhereInput>
    projects?: ProjectListRelationFilter
  }

  export type FunnelStageOrderByWithRelationInput = {
    funnel_stage_id?: SortOrder
    name?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    funnel?: FunnelOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type FunnelStageWhereUniqueInput = Prisma.AtLeast<{
    funnel_stage_id?: number
    AND?: FunnelStageWhereInput | FunnelStageWhereInput[]
    OR?: FunnelStageWhereInput[]
    NOT?: FunnelStageWhereInput | FunnelStageWhereInput[]
    name?: StringFilter<"FunnelStage"> | string
    funnel_id?: IntFilter<"FunnelStage"> | number
    order?: IntFilter<"FunnelStage"> | number
    created_at?: DateTimeFilter<"FunnelStage"> | Date | string
    funnel?: XOR<FunnelRelationFilter, FunnelWhereInput>
    projects?: ProjectListRelationFilter
  }, "funnel_stage_id">

  export type FunnelStageOrderByWithAggregationInput = {
    funnel_stage_id?: SortOrder
    name?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    _count?: FunnelStageCountOrderByAggregateInput
    _avg?: FunnelStageAvgOrderByAggregateInput
    _max?: FunnelStageMaxOrderByAggregateInput
    _min?: FunnelStageMinOrderByAggregateInput
    _sum?: FunnelStageSumOrderByAggregateInput
  }

  export type FunnelStageScalarWhereWithAggregatesInput = {
    AND?: FunnelStageScalarWhereWithAggregatesInput | FunnelStageScalarWhereWithAggregatesInput[]
    OR?: FunnelStageScalarWhereWithAggregatesInput[]
    NOT?: FunnelStageScalarWhereWithAggregatesInput | FunnelStageScalarWhereWithAggregatesInput[]
    funnel_stage_id?: IntWithAggregatesFilter<"FunnelStage"> | number
    name?: StringWithAggregatesFilter<"FunnelStage"> | string
    funnel_id?: IntWithAggregatesFilter<"FunnelStage"> | number
    order?: IntWithAggregatesFilter<"FunnelStage"> | number
    created_at?: DateTimeWithAggregatesFilter<"FunnelStage"> | Date | string
  }

  export type SubProjectStatusTypeWhereInput = {
    AND?: SubProjectStatusTypeWhereInput | SubProjectStatusTypeWhereInput[]
    OR?: SubProjectStatusTypeWhereInput[]
    NOT?: SubProjectStatusTypeWhereInput | SubProjectStatusTypeWhereInput[]
    sub_project_status_id?: IntFilter<"SubProjectStatusType"> | number
    name?: StringFilter<"SubProjectStatusType"> | string
    created_at?: DateTimeFilter<"SubProjectStatusType"> | Date | string
  }

  export type SubProjectStatusTypeOrderByWithRelationInput = {
    sub_project_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectStatusTypeWhereUniqueInput = Prisma.AtLeast<{
    sub_project_status_id?: number
    AND?: SubProjectStatusTypeWhereInput | SubProjectStatusTypeWhereInput[]
    OR?: SubProjectStatusTypeWhereInput[]
    NOT?: SubProjectStatusTypeWhereInput | SubProjectStatusTypeWhereInput[]
    name?: StringFilter<"SubProjectStatusType"> | string
    created_at?: DateTimeFilter<"SubProjectStatusType"> | Date | string
  }, "sub_project_status_id">

  export type SubProjectStatusTypeOrderByWithAggregationInput = {
    sub_project_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    _count?: SubProjectStatusTypeCountOrderByAggregateInput
    _avg?: SubProjectStatusTypeAvgOrderByAggregateInput
    _max?: SubProjectStatusTypeMaxOrderByAggregateInput
    _min?: SubProjectStatusTypeMinOrderByAggregateInput
    _sum?: SubProjectStatusTypeSumOrderByAggregateInput
  }

  export type SubProjectStatusTypeScalarWhereWithAggregatesInput = {
    AND?: SubProjectStatusTypeScalarWhereWithAggregatesInput | SubProjectStatusTypeScalarWhereWithAggregatesInput[]
    OR?: SubProjectStatusTypeScalarWhereWithAggregatesInput[]
    NOT?: SubProjectStatusTypeScalarWhereWithAggregatesInput | SubProjectStatusTypeScalarWhereWithAggregatesInput[]
    sub_project_status_id?: IntWithAggregatesFilter<"SubProjectStatusType"> | number
    name?: StringWithAggregatesFilter<"SubProjectStatusType"> | string
    created_at?: DateTimeWithAggregatesFilter<"SubProjectStatusType"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    project_id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    main_responsible_manager_id?: IntNullableFilter<"Project"> | number | null
    counterparty_id?: IntNullableFilter<"Project"> | number | null
    funnel_id?: IntNullableFilter<"Project"> | number | null
    funnel_stage_id?: IntNullableFilter<"Project"> | number | null
    forecast_amount?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    main_responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    secondary_responsible_managers?: ProjectManagerListRelationFilter
    counterparty?: XOR<CounterpartyNullableRelationFilter, CounterpartyWhereInput> | null
    funnel?: XOR<FunnelNullableRelationFilter, FunnelWhereInput> | null
    funnel_stage?: XOR<FunnelStageNullableRelationFilter, FunnelStageWhereInput> | null
    subprojects?: SubProjectListRelationFilter
    tasks?: TaskListRelationFilter
    sales?: SaleListRelationFilter
    products?: ProjectProductListRelationFilter
    services?: ProjectServiceListRelationFilter
    comments?: ProjectCommentListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    main_responsible_manager_id?: SortOrderInput | SortOrder
    counterparty_id?: SortOrderInput | SortOrder
    funnel_id?: SortOrderInput | SortOrder
    funnel_stage_id?: SortOrderInput | SortOrder
    forecast_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    main_responsible_manager?: ManagerOrderByWithRelationInput
    secondary_responsible_managers?: ProjectManagerOrderByRelationAggregateInput
    counterparty?: CounterpartyOrderByWithRelationInput
    funnel?: FunnelOrderByWithRelationInput
    funnel_stage?: FunnelStageOrderByWithRelationInput
    subprojects?: SubProjectOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    products?: ProjectProductOrderByRelationAggregateInput
    services?: ProjectServiceOrderByRelationAggregateInput
    comments?: ProjectCommentOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    project_id?: number
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    main_responsible_manager_id?: IntNullableFilter<"Project"> | number | null
    counterparty_id?: IntNullableFilter<"Project"> | number | null
    funnel_id?: IntNullableFilter<"Project"> | number | null
    funnel_stage_id?: IntNullableFilter<"Project"> | number | null
    forecast_amount?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    main_responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    secondary_responsible_managers?: ProjectManagerListRelationFilter
    counterparty?: XOR<CounterpartyNullableRelationFilter, CounterpartyWhereInput> | null
    funnel?: XOR<FunnelNullableRelationFilter, FunnelWhereInput> | null
    funnel_stage?: XOR<FunnelStageNullableRelationFilter, FunnelStageWhereInput> | null
    subprojects?: SubProjectListRelationFilter
    tasks?: TaskListRelationFilter
    sales?: SaleListRelationFilter
    products?: ProjectProductListRelationFilter
    services?: ProjectServiceListRelationFilter
    comments?: ProjectCommentListRelationFilter
  }, "project_id">

  export type ProjectOrderByWithAggregationInput = {
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    main_responsible_manager_id?: SortOrderInput | SortOrder
    counterparty_id?: SortOrderInput | SortOrder
    funnel_id?: SortOrderInput | SortOrder
    funnel_stage_id?: SortOrderInput | SortOrder
    forecast_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    project_id?: IntWithAggregatesFilter<"Project"> | number
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    main_responsible_manager_id?: IntNullableWithAggregatesFilter<"Project"> | number | null
    counterparty_id?: IntNullableWithAggregatesFilter<"Project"> | number | null
    funnel_id?: IntNullableWithAggregatesFilter<"Project"> | number | null
    funnel_stage_id?: IntNullableWithAggregatesFilter<"Project"> | number | null
    forecast_amount?: DecimalWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectManagerWhereInput = {
    AND?: ProjectManagerWhereInput | ProjectManagerWhereInput[]
    OR?: ProjectManagerWhereInput[]
    NOT?: ProjectManagerWhereInput | ProjectManagerWhereInput[]
    project_id?: IntFilter<"ProjectManager"> | number
    manager_id?: IntFilter<"ProjectManager"> | number
    created_at?: DateTimeFilter<"ProjectManager"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }

  export type ProjectManagerOrderByWithRelationInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
  }

  export type ProjectManagerWhereUniqueInput = Prisma.AtLeast<{
    project_id_manager_id?: ProjectManagerProject_idManager_idCompoundUniqueInput
    AND?: ProjectManagerWhereInput | ProjectManagerWhereInput[]
    OR?: ProjectManagerWhereInput[]
    NOT?: ProjectManagerWhereInput | ProjectManagerWhereInput[]
    project_id?: IntFilter<"ProjectManager"> | number
    manager_id?: IntFilter<"ProjectManager"> | number
    created_at?: DateTimeFilter<"ProjectManager"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }, "project_id_manager_id">

  export type ProjectManagerOrderByWithAggregationInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
    created_at?: SortOrder
    _count?: ProjectManagerCountOrderByAggregateInput
    _avg?: ProjectManagerAvgOrderByAggregateInput
    _max?: ProjectManagerMaxOrderByAggregateInput
    _min?: ProjectManagerMinOrderByAggregateInput
    _sum?: ProjectManagerSumOrderByAggregateInput
  }

  export type ProjectManagerScalarWhereWithAggregatesInput = {
    AND?: ProjectManagerScalarWhereWithAggregatesInput | ProjectManagerScalarWhereWithAggregatesInput[]
    OR?: ProjectManagerScalarWhereWithAggregatesInput[]
    NOT?: ProjectManagerScalarWhereWithAggregatesInput | ProjectManagerScalarWhereWithAggregatesInput[]
    project_id?: IntWithAggregatesFilter<"ProjectManager"> | number
    manager_id?: IntWithAggregatesFilter<"ProjectManager"> | number
    created_at?: DateTimeWithAggregatesFilter<"ProjectManager"> | Date | string
  }

  export type SubProjectWhereInput = {
    AND?: SubProjectWhereInput | SubProjectWhereInput[]
    OR?: SubProjectWhereInput[]
    NOT?: SubProjectWhereInput | SubProjectWhereInput[]
    subproject_id?: IntFilter<"SubProject"> | number
    name?: StringFilter<"SubProject"> | string
    description?: StringNullableFilter<"SubProject"> | string | null
    project_id?: IntFilter<"SubProject"> | number
    status?: StringNullableFilter<"SubProject"> | string | null
    cost?: DecimalFilter<"SubProject"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"SubProject"> | Date | string
    updated_at?: DateTimeFilter<"SubProject"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
    comments?: SubProjectCommentListRelationFilter
    products?: SubProjectProductListRelationFilter
    services?: SubProjectServiceListRelationFilter
  }

  export type SubProjectOrderByWithRelationInput = {
    subproject_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    project_id?: SortOrder
    status?: SortOrderInput | SortOrder
    cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    comments?: SubProjectCommentOrderByRelationAggregateInput
    products?: SubProjectProductOrderByRelationAggregateInput
    services?: SubProjectServiceOrderByRelationAggregateInput
  }

  export type SubProjectWhereUniqueInput = Prisma.AtLeast<{
    subproject_id?: number
    AND?: SubProjectWhereInput | SubProjectWhereInput[]
    OR?: SubProjectWhereInput[]
    NOT?: SubProjectWhereInput | SubProjectWhereInput[]
    name?: StringFilter<"SubProject"> | string
    description?: StringNullableFilter<"SubProject"> | string | null
    project_id?: IntFilter<"SubProject"> | number
    status?: StringNullableFilter<"SubProject"> | string | null
    cost?: DecimalFilter<"SubProject"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"SubProject"> | Date | string
    updated_at?: DateTimeFilter<"SubProject"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
    comments?: SubProjectCommentListRelationFilter
    products?: SubProjectProductListRelationFilter
    services?: SubProjectServiceListRelationFilter
  }, "subproject_id">

  export type SubProjectOrderByWithAggregationInput = {
    subproject_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    project_id?: SortOrder
    status?: SortOrderInput | SortOrder
    cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubProjectCountOrderByAggregateInput
    _avg?: SubProjectAvgOrderByAggregateInput
    _max?: SubProjectMaxOrderByAggregateInput
    _min?: SubProjectMinOrderByAggregateInput
    _sum?: SubProjectSumOrderByAggregateInput
  }

  export type SubProjectScalarWhereWithAggregatesInput = {
    AND?: SubProjectScalarWhereWithAggregatesInput | SubProjectScalarWhereWithAggregatesInput[]
    OR?: SubProjectScalarWhereWithAggregatesInput[]
    NOT?: SubProjectScalarWhereWithAggregatesInput | SubProjectScalarWhereWithAggregatesInput[]
    subproject_id?: IntWithAggregatesFilter<"SubProject"> | number
    name?: StringWithAggregatesFilter<"SubProject"> | string
    description?: StringNullableWithAggregatesFilter<"SubProject"> | string | null
    project_id?: IntWithAggregatesFilter<"SubProject"> | number
    status?: StringNullableWithAggregatesFilter<"SubProject"> | string | null
    cost?: DecimalWithAggregatesFilter<"SubProject"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"SubProject"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SubProject"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    task_id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    responsible_manager_id?: IntNullableFilter<"Task"> | number | null
    creator_manager_id?: IntNullableFilter<"Task"> | number | null
    project_id?: IntNullableFilter<"Task"> | number | null
    subproject_id?: IntNullableFilter<"Task"> | number | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    creator_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    subproject?: XOR<SubProjectNullableRelationFilter, SubProjectWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    task_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    responsible_manager_id?: SortOrderInput | SortOrder
    creator_manager_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    subproject_id?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    responsible_manager?: ManagerOrderByWithRelationInput
    creator_manager?: ManagerOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    subproject?: SubProjectOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    task_id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    responsible_manager_id?: IntNullableFilter<"Task"> | number | null
    creator_manager_id?: IntNullableFilter<"Task"> | number | null
    project_id?: IntNullableFilter<"Task"> | number | null
    subproject_id?: IntNullableFilter<"Task"> | number | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
    responsible_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    creator_manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    project?: XOR<ProjectNullableRelationFilter, ProjectWhereInput> | null
    subproject?: XOR<SubProjectNullableRelationFilter, SubProjectWhereInput> | null
  }, "task_id">

  export type TaskOrderByWithAggregationInput = {
    task_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    responsible_manager_id?: SortOrderInput | SortOrder
    creator_manager_id?: SortOrderInput | SortOrder
    project_id?: SortOrderInput | SortOrder
    subproject_id?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    task_id?: IntWithAggregatesFilter<"Task"> | number
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    responsible_manager_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    creator_manager_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    project_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    subproject_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    due_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    created_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type ProjectProductWhereInput = {
    AND?: ProjectProductWhereInput | ProjectProductWhereInput[]
    OR?: ProjectProductWhereInput[]
    NOT?: ProjectProductWhereInput | ProjectProductWhereInput[]
    project_product_id?: IntFilter<"ProjectProduct"> | number
    project_id?: IntFilter<"ProjectProduct"> | number
    product_id?: IntFilter<"ProjectProduct"> | number
    quantity?: IntFilter<"ProjectProduct"> | number
    created_at?: DateTimeFilter<"ProjectProduct"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProjectProductOrderByWithRelationInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProjectProductWhereUniqueInput = Prisma.AtLeast<{
    project_product_id?: number
    AND?: ProjectProductWhereInput | ProjectProductWhereInput[]
    OR?: ProjectProductWhereInput[]
    NOT?: ProjectProductWhereInput | ProjectProductWhereInput[]
    project_id?: IntFilter<"ProjectProduct"> | number
    product_id?: IntFilter<"ProjectProduct"> | number
    quantity?: IntFilter<"ProjectProduct"> | number
    created_at?: DateTimeFilter<"ProjectProduct"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "project_product_id">

  export type ProjectProductOrderByWithAggregationInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    _count?: ProjectProductCountOrderByAggregateInput
    _avg?: ProjectProductAvgOrderByAggregateInput
    _max?: ProjectProductMaxOrderByAggregateInput
    _min?: ProjectProductMinOrderByAggregateInput
    _sum?: ProjectProductSumOrderByAggregateInput
  }

  export type ProjectProductScalarWhereWithAggregatesInput = {
    AND?: ProjectProductScalarWhereWithAggregatesInput | ProjectProductScalarWhereWithAggregatesInput[]
    OR?: ProjectProductScalarWhereWithAggregatesInput[]
    NOT?: ProjectProductScalarWhereWithAggregatesInput | ProjectProductScalarWhereWithAggregatesInput[]
    project_product_id?: IntWithAggregatesFilter<"ProjectProduct"> | number
    project_id?: IntWithAggregatesFilter<"ProjectProduct"> | number
    product_id?: IntWithAggregatesFilter<"ProjectProduct"> | number
    quantity?: IntWithAggregatesFilter<"ProjectProduct"> | number
    created_at?: DateTimeWithAggregatesFilter<"ProjectProduct"> | Date | string
  }

  export type ProjectServiceWhereInput = {
    AND?: ProjectServiceWhereInput | ProjectServiceWhereInput[]
    OR?: ProjectServiceWhereInput[]
    NOT?: ProjectServiceWhereInput | ProjectServiceWhereInput[]
    project_service_id?: IntFilter<"ProjectService"> | number
    project_id?: IntFilter<"ProjectService"> | number
    service_id?: IntFilter<"ProjectService"> | number
    created_at?: DateTimeFilter<"ProjectService"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type ProjectServiceOrderByWithRelationInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ProjectServiceWhereUniqueInput = Prisma.AtLeast<{
    project_service_id?: number
    AND?: ProjectServiceWhereInput | ProjectServiceWhereInput[]
    OR?: ProjectServiceWhereInput[]
    NOT?: ProjectServiceWhereInput | ProjectServiceWhereInput[]
    project_id?: IntFilter<"ProjectService"> | number
    service_id?: IntFilter<"ProjectService"> | number
    created_at?: DateTimeFilter<"ProjectService"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "project_service_id">

  export type ProjectServiceOrderByWithAggregationInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    _count?: ProjectServiceCountOrderByAggregateInput
    _avg?: ProjectServiceAvgOrderByAggregateInput
    _max?: ProjectServiceMaxOrderByAggregateInput
    _min?: ProjectServiceMinOrderByAggregateInput
    _sum?: ProjectServiceSumOrderByAggregateInput
  }

  export type ProjectServiceScalarWhereWithAggregatesInput = {
    AND?: ProjectServiceScalarWhereWithAggregatesInput | ProjectServiceScalarWhereWithAggregatesInput[]
    OR?: ProjectServiceScalarWhereWithAggregatesInput[]
    NOT?: ProjectServiceScalarWhereWithAggregatesInput | ProjectServiceScalarWhereWithAggregatesInput[]
    project_service_id?: IntWithAggregatesFilter<"ProjectService"> | number
    project_id?: IntWithAggregatesFilter<"ProjectService"> | number
    service_id?: IntWithAggregatesFilter<"ProjectService"> | number
    created_at?: DateTimeWithAggregatesFilter<"ProjectService"> | Date | string
  }

  export type SubProjectProductWhereInput = {
    AND?: SubProjectProductWhereInput | SubProjectProductWhereInput[]
    OR?: SubProjectProductWhereInput[]
    NOT?: SubProjectProductWhereInput | SubProjectProductWhereInput[]
    subproject_product_id?: IntFilter<"SubProjectProduct"> | number
    subproject_id?: IntFilter<"SubProjectProduct"> | number
    product_id?: IntFilter<"SubProjectProduct"> | number
    quantity?: IntFilter<"SubProjectProduct"> | number
    created_at?: DateTimeFilter<"SubProjectProduct"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type SubProjectProductOrderByWithRelationInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    subproject?: SubProjectOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type SubProjectProductWhereUniqueInput = Prisma.AtLeast<{
    subproject_product_id?: number
    AND?: SubProjectProductWhereInput | SubProjectProductWhereInput[]
    OR?: SubProjectProductWhereInput[]
    NOT?: SubProjectProductWhereInput | SubProjectProductWhereInput[]
    subproject_id?: IntFilter<"SubProjectProduct"> | number
    product_id?: IntFilter<"SubProjectProduct"> | number
    quantity?: IntFilter<"SubProjectProduct"> | number
    created_at?: DateTimeFilter<"SubProjectProduct"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "subproject_product_id">

  export type SubProjectProductOrderByWithAggregationInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    _count?: SubProjectProductCountOrderByAggregateInput
    _avg?: SubProjectProductAvgOrderByAggregateInput
    _max?: SubProjectProductMaxOrderByAggregateInput
    _min?: SubProjectProductMinOrderByAggregateInput
    _sum?: SubProjectProductSumOrderByAggregateInput
  }

  export type SubProjectProductScalarWhereWithAggregatesInput = {
    AND?: SubProjectProductScalarWhereWithAggregatesInput | SubProjectProductScalarWhereWithAggregatesInput[]
    OR?: SubProjectProductScalarWhereWithAggregatesInput[]
    NOT?: SubProjectProductScalarWhereWithAggregatesInput | SubProjectProductScalarWhereWithAggregatesInput[]
    subproject_product_id?: IntWithAggregatesFilter<"SubProjectProduct"> | number
    subproject_id?: IntWithAggregatesFilter<"SubProjectProduct"> | number
    product_id?: IntWithAggregatesFilter<"SubProjectProduct"> | number
    quantity?: IntWithAggregatesFilter<"SubProjectProduct"> | number
    created_at?: DateTimeWithAggregatesFilter<"SubProjectProduct"> | Date | string
  }

  export type SubProjectServiceWhereInput = {
    AND?: SubProjectServiceWhereInput | SubProjectServiceWhereInput[]
    OR?: SubProjectServiceWhereInput[]
    NOT?: SubProjectServiceWhereInput | SubProjectServiceWhereInput[]
    subproject_service_id?: IntFilter<"SubProjectService"> | number
    subproject_id?: IntFilter<"SubProjectService"> | number
    service_id?: IntFilter<"SubProjectService"> | number
    created_at?: DateTimeFilter<"SubProjectService"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }

  export type SubProjectServiceOrderByWithRelationInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    subproject?: SubProjectOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type SubProjectServiceWhereUniqueInput = Prisma.AtLeast<{
    subproject_service_id?: number
    AND?: SubProjectServiceWhereInput | SubProjectServiceWhereInput[]
    OR?: SubProjectServiceWhereInput[]
    NOT?: SubProjectServiceWhereInput | SubProjectServiceWhereInput[]
    subproject_id?: IntFilter<"SubProjectService"> | number
    service_id?: IntFilter<"SubProjectService"> | number
    created_at?: DateTimeFilter<"SubProjectService"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>
  }, "subproject_service_id">

  export type SubProjectServiceOrderByWithAggregationInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
    _count?: SubProjectServiceCountOrderByAggregateInput
    _avg?: SubProjectServiceAvgOrderByAggregateInput
    _max?: SubProjectServiceMaxOrderByAggregateInput
    _min?: SubProjectServiceMinOrderByAggregateInput
    _sum?: SubProjectServiceSumOrderByAggregateInput
  }

  export type SubProjectServiceScalarWhereWithAggregatesInput = {
    AND?: SubProjectServiceScalarWhereWithAggregatesInput | SubProjectServiceScalarWhereWithAggregatesInput[]
    OR?: SubProjectServiceScalarWhereWithAggregatesInput[]
    NOT?: SubProjectServiceScalarWhereWithAggregatesInput | SubProjectServiceScalarWhereWithAggregatesInput[]
    subproject_service_id?: IntWithAggregatesFilter<"SubProjectService"> | number
    subproject_id?: IntWithAggregatesFilter<"SubProjectService"> | number
    service_id?: IntWithAggregatesFilter<"SubProjectService"> | number
    created_at?: DateTimeWithAggregatesFilter<"SubProjectService"> | Date | string
  }

  export type ProjectCommentWhereInput = {
    AND?: ProjectCommentWhereInput | ProjectCommentWhereInput[]
    OR?: ProjectCommentWhereInput[]
    NOT?: ProjectCommentWhereInput | ProjectCommentWhereInput[]
    comment_id?: IntFilter<"ProjectComment"> | number
    project_id?: IntFilter<"ProjectComment"> | number
    manager_id?: IntFilter<"ProjectComment"> | number
    content?: StringFilter<"ProjectComment"> | string
    file_name?: StringNullableFilter<"ProjectComment"> | string | null
    file_type?: StringNullableFilter<"ProjectComment"> | string | null
    file_url?: StringNullableFilter<"ProjectComment"> | string | null
    created_at?: DateTimeFilter<"ProjectComment"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }

  export type ProjectCommentOrderByWithRelationInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_type?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
  }

  export type ProjectCommentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: ProjectCommentWhereInput | ProjectCommentWhereInput[]
    OR?: ProjectCommentWhereInput[]
    NOT?: ProjectCommentWhereInput | ProjectCommentWhereInput[]
    project_id?: IntFilter<"ProjectComment"> | number
    manager_id?: IntFilter<"ProjectComment"> | number
    content?: StringFilter<"ProjectComment"> | string
    file_name?: StringNullableFilter<"ProjectComment"> | string | null
    file_type?: StringNullableFilter<"ProjectComment"> | string | null
    file_url?: StringNullableFilter<"ProjectComment"> | string | null
    created_at?: DateTimeFilter<"ProjectComment"> | Date | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }, "comment_id">

  export type ProjectCommentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_type?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ProjectCommentCountOrderByAggregateInput
    _avg?: ProjectCommentAvgOrderByAggregateInput
    _max?: ProjectCommentMaxOrderByAggregateInput
    _min?: ProjectCommentMinOrderByAggregateInput
    _sum?: ProjectCommentSumOrderByAggregateInput
  }

  export type ProjectCommentScalarWhereWithAggregatesInput = {
    AND?: ProjectCommentScalarWhereWithAggregatesInput | ProjectCommentScalarWhereWithAggregatesInput[]
    OR?: ProjectCommentScalarWhereWithAggregatesInput[]
    NOT?: ProjectCommentScalarWhereWithAggregatesInput | ProjectCommentScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"ProjectComment"> | number
    project_id?: IntWithAggregatesFilter<"ProjectComment"> | number
    manager_id?: IntWithAggregatesFilter<"ProjectComment"> | number
    content?: StringWithAggregatesFilter<"ProjectComment"> | string
    file_name?: StringNullableWithAggregatesFilter<"ProjectComment"> | string | null
    file_type?: StringNullableWithAggregatesFilter<"ProjectComment"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"ProjectComment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ProjectComment"> | Date | string
  }

  export type SubProjectCommentWhereInput = {
    AND?: SubProjectCommentWhereInput | SubProjectCommentWhereInput[]
    OR?: SubProjectCommentWhereInput[]
    NOT?: SubProjectCommentWhereInput | SubProjectCommentWhereInput[]
    comment_id?: IntFilter<"SubProjectComment"> | number
    subproject_id?: IntFilter<"SubProjectComment"> | number
    manager_id?: IntFilter<"SubProjectComment"> | number
    content?: StringFilter<"SubProjectComment"> | string
    file_name?: StringNullableFilter<"SubProjectComment"> | string | null
    file_type?: StringNullableFilter<"SubProjectComment"> | string | null
    file_url?: StringNullableFilter<"SubProjectComment"> | string | null
    created_at?: DateTimeFilter<"SubProjectComment"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }

  export type SubProjectCommentOrderByWithRelationInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_type?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    subproject?: SubProjectOrderByWithRelationInput
    manager?: ManagerOrderByWithRelationInput
  }

  export type SubProjectCommentWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: SubProjectCommentWhereInput | SubProjectCommentWhereInput[]
    OR?: SubProjectCommentWhereInput[]
    NOT?: SubProjectCommentWhereInput | SubProjectCommentWhereInput[]
    subproject_id?: IntFilter<"SubProjectComment"> | number
    manager_id?: IntFilter<"SubProjectComment"> | number
    content?: StringFilter<"SubProjectComment"> | string
    file_name?: StringNullableFilter<"SubProjectComment"> | string | null
    file_type?: StringNullableFilter<"SubProjectComment"> | string | null
    file_url?: StringNullableFilter<"SubProjectComment"> | string | null
    created_at?: DateTimeFilter<"SubProjectComment"> | Date | string
    subproject?: XOR<SubProjectRelationFilter, SubProjectWhereInput>
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
  }, "comment_id">

  export type SubProjectCommentOrderByWithAggregationInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_type?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: SubProjectCommentCountOrderByAggregateInput
    _avg?: SubProjectCommentAvgOrderByAggregateInput
    _max?: SubProjectCommentMaxOrderByAggregateInput
    _min?: SubProjectCommentMinOrderByAggregateInput
    _sum?: SubProjectCommentSumOrderByAggregateInput
  }

  export type SubProjectCommentScalarWhereWithAggregatesInput = {
    AND?: SubProjectCommentScalarWhereWithAggregatesInput | SubProjectCommentScalarWhereWithAggregatesInput[]
    OR?: SubProjectCommentScalarWhereWithAggregatesInput[]
    NOT?: SubProjectCommentScalarWhereWithAggregatesInput | SubProjectCommentScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"SubProjectComment"> | number
    subproject_id?: IntWithAggregatesFilter<"SubProjectComment"> | number
    manager_id?: IntWithAggregatesFilter<"SubProjectComment"> | number
    content?: StringWithAggregatesFilter<"SubProjectComment"> | string
    file_name?: StringNullableWithAggregatesFilter<"SubProjectComment"> | string | null
    file_type?: StringNullableWithAggregatesFilter<"SubProjectComment"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"SubProjectComment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SubProjectComment"> | Date | string
  }

  export type ManagerCreateInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ManagerUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterpartyCreateInput = {
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutCounterpartiesInput
    sales?: SaleCreateNestedManyWithoutCounterpartyInput
    projects?: ProjectCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyUncheckedCreateInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    responsible_manager_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCounterpartyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutCounterpartiesNestedInput
    sales?: SaleUpdateManyWithoutCounterpartyNestedInput
    projects?: ProjectUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyUncheckedUpdateInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCounterpartyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyCreateManyInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    responsible_manager_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CounterpartyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterpartyUncheckedUpdateManyInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    name: string
    created_at?: Date | string
    products?: ProductCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    unit_id?: number
    name: string
    created_at?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    unit_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    unit_id?: number
    name: string
    created_at?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    unit_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    name: string
    location: string
    created_at?: Date | string
    product_stocks?: ProductStockCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    warehouse_id?: number
    name: string
    location: string
    created_at?: Date | string
    product_stocks?: ProductStockUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_stocks?: ProductStockUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_stocks?: ProductStockUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    warehouse_id?: number
    name: string
    location: string
    created_at?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    unit?: UnitCreateNestedOneWithoutProductsInput
    stocks?: ProductStockCreateNestedManyWithoutProductInput
    sales?: SaleProductCreateNestedManyWithoutProductInput
    project_products?: ProjectProductCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    sales?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    project_products?: ProjectProductUncheckedCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutProductsNestedInput
    stocks?: ProductStockUpdateManyWithoutProductNestedInput
    sales?: SaleProductUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    sales?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUncheckedUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateInput = {
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    product: ProductCreateNestedOneWithoutStocksInput
    warehouse: WarehouseCreateNestedOneWithoutProduct_stocksInput
  }

  export type ProductStockUncheckedCreateInput = {
    product_stock_id?: number
    product_id: number
    warehouse_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductStockUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStocksNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProduct_stocksNestedInput
  }

  export type ProductStockUncheckedUpdateInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyInput = {
    product_stock_id?: number
    product_id: number
    warehouse_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductStockUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceCreateNestedManyWithoutServiceInput
    project_services?: ProjectServiceCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    service_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceUncheckedCreateNestedManyWithoutServiceInput
    project_services?: ProjectServiceUncheckedCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUpdateManyWithoutServiceNestedInput
    project_services?: ProjectServiceUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUncheckedUpdateManyWithoutServiceNestedInput
    project_services?: ProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    service_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStatusTypeCreateInput = {
    name: string
    created_at?: Date | string
    sales?: SaleCreateNestedManyWithoutSale_status_typeInput
  }

  export type SaleStatusTypeUncheckedCreateInput = {
    sale_status_id?: number
    name: string
    created_at?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutSale_status_typeInput
  }

  export type SaleStatusTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutSale_status_typeNestedInput
  }

  export type SaleStatusTypeUncheckedUpdateInput = {
    sale_status_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutSale_status_typeNestedInput
  }

  export type SaleStatusTypeCreateManyInput = {
    sale_status_id?: number
    name: string
    created_at?: Date | string
  }

  export type SaleStatusTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStatusTypeUncheckedUpdateManyInput = {
    sale_status_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateInput = {
    quantity: number
    created_at?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSalesInput
  }

  export type SaleProductUncheckedCreateInput = {
    sale_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SaleProductUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleProductUncheckedUpdateInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManyInput = {
    sale_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SaleProductUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceCreateInput = {
    created_at?: Date | string
    sale: SaleCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutSalesInput
  }

  export type SaleServiceUncheckedCreateInput = {
    sale_id: number
    service_id: number
    created_at?: Date | string
  }

  export type SaleServiceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleServiceUncheckedUpdateInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceCreateManyInput = {
    sale_id: number
    service_id: number
    created_at?: Date | string
  }

  export type SaleServiceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelCreateInput = {
    name: string
    created_at?: Date | string
    stages?: FunnelStageCreateNestedManyWithoutFunnelInput
    projects?: ProjectCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateInput = {
    funnel_id?: number
    name: string
    created_at?: Date | string
    stages?: FunnelStageUncheckedCreateNestedManyWithoutFunnelInput
    projects?: ProjectUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: FunnelStageUpdateManyWithoutFunnelNestedInput
    projects?: ProjectUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateInput = {
    funnel_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: FunnelStageUncheckedUpdateManyWithoutFunnelNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelCreateManyInput = {
    funnel_id?: number
    name: string
    created_at?: Date | string
  }

  export type FunnelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelUncheckedUpdateManyInput = {
    funnel_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelStageCreateInput = {
    name: string
    order: number
    created_at?: Date | string
    funnel: FunnelCreateNestedOneWithoutStagesInput
    projects?: ProjectCreateNestedManyWithoutFunnel_stageInput
  }

  export type FunnelStageUncheckedCreateInput = {
    funnel_stage_id?: number
    name: string
    funnel_id: number
    order: number
    created_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutFunnel_stageInput
  }

  export type FunnelStageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    funnel?: FunnelUpdateOneRequiredWithoutStagesNestedInput
    projects?: ProjectUpdateManyWithoutFunnel_stageNestedInput
  }

  export type FunnelStageUncheckedUpdateInput = {
    funnel_stage_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    funnel_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutFunnel_stageNestedInput
  }

  export type FunnelStageCreateManyInput = {
    funnel_stage_id?: number
    name: string
    funnel_id: number
    order: number
    created_at?: Date | string
  }

  export type FunnelStageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelStageUncheckedUpdateManyInput = {
    funnel_stage_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    funnel_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectStatusTypeCreateInput = {
    name: string
    created_at?: Date | string
  }

  export type SubProjectStatusTypeUncheckedCreateInput = {
    sub_project_status_id?: number
    name: string
    created_at?: Date | string
  }

  export type SubProjectStatusTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectStatusTypeUncheckedUpdateInput = {
    sub_project_status_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectStatusTypeCreateManyInput = {
    sub_project_status_id?: number
    name: string
    created_at?: Date | string
  }

  export type SubProjectStatusTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectStatusTypeUncheckedUpdateManyInput = {
    sub_project_status_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerCreateInput = {
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutSecondary_responsible_managersInput
    manager: ManagerCreateNestedOneWithoutProjects_as_secondaryInput
  }

  export type ProjectManagerUncheckedCreateInput = {
    project_id: number
    manager_id: number
    created_at?: Date | string
  }

  export type ProjectManagerUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSecondary_responsible_managersNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProjects_as_secondaryNestedInput
  }

  export type ProjectManagerUncheckedUpdateInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerCreateManyInput = {
    project_id: number
    manager_id: number
    created_at?: Date | string
  }

  export type ProjectManagerUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerUncheckedUpdateManyInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCreateInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutSubprojectsInput
    tasks?: TaskCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubprojectsNestedInput
    tasks?: TaskUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectCreateManyInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubProjectUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectUncheckedUpdateManyInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    title: string
    description?: string | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutTasks_as_responsibleInput
    creator_manager?: ManagerCreateNestedOneWithoutTasks_as_creatorInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    subproject?: SubProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutTasks_as_responsibleNestedInput
    creator_manager?: ManagerUpdateOneWithoutTasks_as_creatorNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    subproject?: SubProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductCreateInput = {
    quantity: number
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutProject_productsInput
  }

  export type ProjectProductUncheckedCreateInput = {
    project_product_id?: number
    project_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectProductUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutProject_productsNestedInput
  }

  export type ProjectProductUncheckedUpdateInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductCreateManyInput = {
    project_product_id?: number
    project_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectProductUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductUncheckedUpdateManyInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceCreateInput = {
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutProject_servicesInput
  }

  export type ProjectServiceUncheckedCreateInput = {
    project_service_id?: number
    project_id: number
    service_id: number
    created_at?: Date | string
  }

  export type ProjectServiceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutProject_servicesNestedInput
  }

  export type ProjectServiceUncheckedUpdateInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceCreateManyInput = {
    project_service_id?: number
    project_id: number
    service_id: number
    created_at?: Date | string
  }

  export type ProjectServiceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceUncheckedUpdateManyInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductCreateInput = {
    quantity: number
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSubproject_productsInput
  }

  export type SubProjectProductUncheckedCreateInput = {
    subproject_product_id?: number
    subproject_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectProductUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSubproject_productsNestedInput
  }

  export type SubProjectProductUncheckedUpdateInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductCreateManyInput = {
    subproject_product_id?: number
    subproject_id: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectProductUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductUncheckedUpdateManyInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceCreateInput = {
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutSubproject_servicesInput
  }

  export type SubProjectServiceUncheckedCreateInput = {
    subproject_service_id?: number
    subproject_id: number
    service_id: number
    created_at?: Date | string
  }

  export type SubProjectServiceUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutSubproject_servicesNestedInput
  }

  export type SubProjectServiceUncheckedUpdateInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceCreateManyInput = {
    subproject_service_id?: number
    subproject_id: number
    service_id: number
    created_at?: Date | string
  }

  export type SubProjectServiceUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceUncheckedUpdateManyInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentCreateInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutCommentsInput
    manager: ManagerCreateNestedOneWithoutProject_commentsInput
  }

  export type ProjectCommentUncheckedCreateInput = {
    comment_id?: number
    project_id: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ProjectCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCommentsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutProject_commentsNestedInput
  }

  export type ProjectCommentUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentCreateManyInput = {
    comment_id?: number
    project_id: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ProjectCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentCreateInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutCommentsInput
    manager: ManagerCreateNestedOneWithoutSubproject_commentsInput
  }

  export type SubProjectCommentUncheckedCreateInput = {
    comment_id?: number
    subproject_id: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutCommentsNestedInput
    manager?: ManagerUpdateOneRequiredWithoutSubproject_commentsNestedInput
  }

  export type SubProjectCommentUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentCreateManyInput = {
    comment_id?: number
    subproject_id: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumManagerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagerRole | EnumManagerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumManagerRoleFilter<$PrismaModel> | $Enums.ManagerRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ManagerListRelationFilter = {
    every?: ManagerWhereInput
    some?: ManagerWhereInput
    none?: ManagerWhereInput
  }

  export type CounterpartyListRelationFilter = {
    every?: CounterpartyWhereInput
    some?: CounterpartyWhereInput
    none?: CounterpartyWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectManagerListRelationFilter = {
    every?: ProjectManagerWhereInput
    some?: ProjectManagerWhereInput
    none?: ProjectManagerWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ProjectCommentListRelationFilter = {
    every?: ProjectCommentWhereInput
    some?: ProjectCommentWhereInput
    none?: ProjectCommentWhereInput
  }

  export type SubProjectCommentListRelationFilter = {
    every?: SubProjectCommentWhereInput
    some?: SubProjectCommentWhereInput
    none?: SubProjectCommentWhereInput
  }

  export type ManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CounterpartyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubProjectCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    manager_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ManagerAvgOrderByAggregateInput = {
    manager_id?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    manager_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    manager_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    role?: SortOrder
    password_hash?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ManagerSumOrderByAggregateInput = {
    manager_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumManagerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagerRole | EnumManagerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumManagerRoleWithAggregatesFilter<$PrismaModel> | $Enums.ManagerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManagerRoleFilter<$PrismaModel>
    _max?: NestedEnumManagerRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumCounterpartyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CounterpartyType | EnumCounterpartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCounterpartyTypeFilter<$PrismaModel> | $Enums.CounterpartyType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ManagerNullableRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CounterpartyCountOrderByAggregateInput = {
    counterparty_id?: SortOrder
    name?: SortOrder
    counterparty_type?: SortOrder
    responsible_manager_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CounterpartyAvgOrderByAggregateInput = {
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
  }

  export type CounterpartyMaxOrderByAggregateInput = {
    counterparty_id?: SortOrder
    name?: SortOrder
    counterparty_type?: SortOrder
    responsible_manager_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CounterpartyMinOrderByAggregateInput = {
    counterparty_id?: SortOrder
    name?: SortOrder
    counterparty_type?: SortOrder
    responsible_manager_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CounterpartySumOrderByAggregateInput = {
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
  }

  export type EnumCounterpartyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CounterpartyType | EnumCounterpartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCounterpartyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CounterpartyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCounterpartyTypeFilter<$PrismaModel>
    _max?: NestedEnumCounterpartyTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    unit_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    unit_id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    unit_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    unit_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    unit_id?: SortOrder
  }

  export type ProductStockListRelationFilter = {
    every?: ProductStockWhereInput
    some?: ProductStockWhereInput
    none?: ProductStockWhereInput
  }

  export type ProductStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    warehouse_id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    warehouse_id?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    warehouse_id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    warehouse_id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    warehouse_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type SaleProductListRelationFilter = {
    every?: SaleProductWhereInput
    some?: SaleProductWhereInput
    none?: SaleProductWhereInput
  }

  export type ProjectProductListRelationFilter = {
    every?: ProjectProductWhereInput
    some?: ProjectProductWhereInput
    none?: ProjectProductWhereInput
  }

  export type SubProjectProductListRelationFilter = {
    every?: SubProjectProductWhereInput
    some?: SubProjectProductWhereInput
    none?: SubProjectProductWhereInput
  }

  export type SaleProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubProjectProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    product_id?: SortOrder
    price?: SortOrder
    unit_id?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    unit_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    product_id?: SortOrder
    price?: SortOrder
    unit_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type WarehouseRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type ProductStockProduct_idWarehouse_idCompoundUniqueInput = {
    product_id: number
    warehouse_id: number
  }

  export type ProductStockCountOrderByAggregateInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductStockAvgOrderByAggregateInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
  }

  export type ProductStockMaxOrderByAggregateInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductStockMinOrderByAggregateInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductStockSumOrderByAggregateInput = {
    product_stock_id?: SortOrder
    product_id?: SortOrder
    warehouse_id?: SortOrder
    quantity?: SortOrder
  }

  export type SaleServiceListRelationFilter = {
    every?: SaleServiceWhereInput
    some?: SaleServiceWhereInput
    none?: SaleServiceWhereInput
  }

  export type ProjectServiceListRelationFilter = {
    every?: ProjectServiceWhereInput
    some?: ProjectServiceWhereInput
    none?: ProjectServiceWhereInput
  }

  export type SubProjectServiceListRelationFilter = {
    every?: SubProjectServiceWhereInput
    some?: SubProjectServiceWhereInput
    none?: SubProjectServiceWhereInput
  }

  export type SaleServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubProjectServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    service_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    service_id?: SortOrder
    price?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    service_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    service_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    service_id?: SortOrder
    price?: SortOrder
  }

  export type SaleStatusTypeCountOrderByAggregateInput = {
    sale_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SaleStatusTypeAvgOrderByAggregateInput = {
    sale_status_id?: SortOrder
  }

  export type SaleStatusTypeMaxOrderByAggregateInput = {
    sale_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SaleStatusTypeMinOrderByAggregateInput = {
    sale_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SaleStatusTypeSumOrderByAggregateInput = {
    sale_status_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CounterpartyRelationFilter = {
    is?: CounterpartyWhereInput
    isNot?: CounterpartyWhereInput
  }

  export type ManagerRelationFilter = {
    is?: ManagerWhereInput
    isNot?: ManagerWhereInput
  }

  export type ProjectNullableRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type SaleStatusTypeNullableRelationFilter = {
    is?: SaleStatusTypeWhereInput | null
    isNot?: SaleStatusTypeWhereInput | null
  }

  export type SaleCountOrderByAggregateInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    sale_date?: SortOrder
    status?: SortOrder
    deferred_payment_date?: SortOrder
    project_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    project_id?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    sale_date?: SortOrder
    status?: SortOrder
    deferred_payment_date?: SortOrder
    project_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    sale_date?: SortOrder
    status?: SortOrder
    deferred_payment_date?: SortOrder
    project_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    sale_id?: SortOrder
    counterparty_id?: SortOrder
    responsible_manager_id?: SortOrder
    project_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type SaleRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type SaleProductSale_idProduct_idCompoundUniqueInput = {
    sale_id: number
    product_id: number
  }

  export type SaleProductCountOrderByAggregateInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SaleProductAvgOrderByAggregateInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type SaleProductMaxOrderByAggregateInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SaleProductMinOrderByAggregateInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SaleProductSumOrderByAggregateInput = {
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type SaleServiceSale_idService_idCompoundUniqueInput = {
    sale_id: number
    service_id: number
  }

  export type SaleServiceCountOrderByAggregateInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SaleServiceAvgOrderByAggregateInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
  }

  export type SaleServiceMaxOrderByAggregateInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SaleServiceMinOrderByAggregateInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SaleServiceSumOrderByAggregateInput = {
    sale_id?: SortOrder
    service_id?: SortOrder
  }

  export type FunnelStageListRelationFilter = {
    every?: FunnelStageWhereInput
    some?: FunnelStageWhereInput
    none?: FunnelStageWhereInput
  }

  export type FunnelStageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelCountOrderByAggregateInput = {
    funnel_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelAvgOrderByAggregateInput = {
    funnel_id?: SortOrder
  }

  export type FunnelMaxOrderByAggregateInput = {
    funnel_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelMinOrderByAggregateInput = {
    funnel_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelSumOrderByAggregateInput = {
    funnel_id?: SortOrder
  }

  export type FunnelRelationFilter = {
    is?: FunnelWhereInput
    isNot?: FunnelWhereInput
  }

  export type FunnelStageCountOrderByAggregateInput = {
    funnel_stage_id?: SortOrder
    name?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelStageAvgOrderByAggregateInput = {
    funnel_stage_id?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
  }

  export type FunnelStageMaxOrderByAggregateInput = {
    funnel_stage_id?: SortOrder
    name?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelStageMinOrderByAggregateInput = {
    funnel_stage_id?: SortOrder
    name?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
  }

  export type FunnelStageSumOrderByAggregateInput = {
    funnel_stage_id?: SortOrder
    funnel_id?: SortOrder
    order?: SortOrder
  }

  export type SubProjectStatusTypeCountOrderByAggregateInput = {
    sub_project_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectStatusTypeAvgOrderByAggregateInput = {
    sub_project_status_id?: SortOrder
  }

  export type SubProjectStatusTypeMaxOrderByAggregateInput = {
    sub_project_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectStatusTypeMinOrderByAggregateInput = {
    sub_project_status_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectStatusTypeSumOrderByAggregateInput = {
    sub_project_status_id?: SortOrder
  }

  export type CounterpartyNullableRelationFilter = {
    is?: CounterpartyWhereInput | null
    isNot?: CounterpartyWhereInput | null
  }

  export type FunnelNullableRelationFilter = {
    is?: FunnelWhereInput | null
    isNot?: FunnelWhereInput | null
  }

  export type FunnelStageNullableRelationFilter = {
    is?: FunnelStageWhereInput | null
    isNot?: FunnelStageWhereInput | null
  }

  export type SubProjectListRelationFilter = {
    every?: SubProjectWhereInput
    some?: SubProjectWhereInput
    none?: SubProjectWhereInput
  }

  export type SubProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    main_responsible_manager_id?: SortOrder
    counterparty_id?: SortOrder
    funnel_id?: SortOrder
    funnel_stage_id?: SortOrder
    forecast_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    project_id?: SortOrder
    main_responsible_manager_id?: SortOrder
    counterparty_id?: SortOrder
    funnel_id?: SortOrder
    funnel_stage_id?: SortOrder
    forecast_amount?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    main_responsible_manager_id?: SortOrder
    counterparty_id?: SortOrder
    funnel_id?: SortOrder
    funnel_stage_id?: SortOrder
    forecast_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    project_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    main_responsible_manager_id?: SortOrder
    counterparty_id?: SortOrder
    funnel_id?: SortOrder
    funnel_stage_id?: SortOrder
    forecast_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    project_id?: SortOrder
    main_responsible_manager_id?: SortOrder
    counterparty_id?: SortOrder
    funnel_id?: SortOrder
    funnel_stage_id?: SortOrder
    forecast_amount?: SortOrder
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectManagerProject_idManager_idCompoundUniqueInput = {
    project_id: number
    manager_id: number
  }

  export type ProjectManagerCountOrderByAggregateInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectManagerAvgOrderByAggregateInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
  }

  export type ProjectManagerMaxOrderByAggregateInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectManagerMinOrderByAggregateInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectManagerSumOrderByAggregateInput = {
    project_id?: SortOrder
    manager_id?: SortOrder
  }

  export type SubProjectCountOrderByAggregateInput = {
    subproject_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    project_id?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubProjectAvgOrderByAggregateInput = {
    subproject_id?: SortOrder
    project_id?: SortOrder
    cost?: SortOrder
  }

  export type SubProjectMaxOrderByAggregateInput = {
    subproject_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    project_id?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubProjectMinOrderByAggregateInput = {
    subproject_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    project_id?: SortOrder
    status?: SortOrder
    cost?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubProjectSumOrderByAggregateInput = {
    subproject_id?: SortOrder
    project_id?: SortOrder
    cost?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type SubProjectNullableRelationFilter = {
    is?: SubProjectWhereInput | null
    isNot?: SubProjectWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    task_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    responsible_manager_id?: SortOrder
    creator_manager_id?: SortOrder
    project_id?: SortOrder
    subproject_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    task_id?: SortOrder
    responsible_manager_id?: SortOrder
    creator_manager_id?: SortOrder
    project_id?: SortOrder
    subproject_id?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    task_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    responsible_manager_id?: SortOrder
    creator_manager_id?: SortOrder
    project_id?: SortOrder
    subproject_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    task_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    responsible_manager_id?: SortOrder
    creator_manager_id?: SortOrder
    project_id?: SortOrder
    subproject_id?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    task_id?: SortOrder
    responsible_manager_id?: SortOrder
    creator_manager_id?: SortOrder
    project_id?: SortOrder
    subproject_id?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type ProjectProductCountOrderByAggregateInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectProductAvgOrderByAggregateInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type ProjectProductMaxOrderByAggregateInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectProductMinOrderByAggregateInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectProductSumOrderByAggregateInput = {
    project_product_id?: SortOrder
    project_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type ProjectServiceCountOrderByAggregateInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectServiceAvgOrderByAggregateInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
  }

  export type ProjectServiceMaxOrderByAggregateInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectServiceMinOrderByAggregateInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectServiceSumOrderByAggregateInput = {
    project_service_id?: SortOrder
    project_id?: SortOrder
    service_id?: SortOrder
  }

  export type SubProjectRelationFilter = {
    is?: SubProjectWhereInput
    isNot?: SubProjectWhereInput
  }

  export type SubProjectProductCountOrderByAggregateInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectProductAvgOrderByAggregateInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type SubProjectProductMaxOrderByAggregateInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectProductMinOrderByAggregateInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectProductSumOrderByAggregateInput = {
    subproject_product_id?: SortOrder
    subproject_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type SubProjectServiceCountOrderByAggregateInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectServiceAvgOrderByAggregateInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
  }

  export type SubProjectServiceMaxOrderByAggregateInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectServiceMinOrderByAggregateInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectServiceSumOrderByAggregateInput = {
    subproject_service_id?: SortOrder
    subproject_id?: SortOrder
    service_id?: SortOrder
  }

  export type ProjectCommentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectCommentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
  }

  export type ProjectCommentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectCommentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectCommentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    project_id?: SortOrder
    manager_id?: SortOrder
  }

  export type SubProjectCommentCountOrderByAggregateInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectCommentAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
  }

  export type SubProjectCommentMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectCommentMinOrderByAggregateInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
    content?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type SubProjectCommentSumOrderByAggregateInput = {
    comment_id?: SortOrder
    subproject_id?: SortOrder
    manager_id?: SortOrder
  }

  export type ManagerCreateNestedManyWithoutSubordinatesInput = {
    create?: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput> | ManagerCreateWithoutSubordinatesInput[] | ManagerUncheckedCreateWithoutSubordinatesInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSubordinatesInput | ManagerCreateOrConnectWithoutSubordinatesInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
  }

  export type ManagerCreateNestedManyWithoutSupervisorsInput = {
    create?: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput> | ManagerCreateWithoutSupervisorsInput[] | ManagerUncheckedCreateWithoutSupervisorsInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSupervisorsInput | ManagerCreateOrConnectWithoutSupervisorsInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
  }

  export type CounterpartyCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput> | CounterpartyCreateWithoutResponsible_managerInput[] | CounterpartyUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: CounterpartyCreateOrConnectWithoutResponsible_managerInput | CounterpartyCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: CounterpartyCreateManyResponsible_managerInputEnvelope
    connect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput> | SaleCreateWithoutResponsible_managerInput[] | SaleUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutResponsible_managerInput | SaleCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: SaleCreateManyResponsible_managerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutMain_responsible_managerInput = {
    create?: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput> | ProjectCreateWithoutMain_responsible_managerInput[] | ProjectUncheckedCreateWithoutMain_responsible_managerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutMain_responsible_managerInput | ProjectCreateOrConnectWithoutMain_responsible_managerInput[]
    createMany?: ProjectCreateManyMain_responsible_managerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectManagerCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput> | ProjectManagerCreateWithoutManagerInput[] | ProjectManagerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutManagerInput | ProjectManagerCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectManagerCreateManyManagerInputEnvelope
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput> | TaskCreateWithoutResponsible_managerInput[] | TaskUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsible_managerInput | TaskCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: TaskCreateManyResponsible_managerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutCreator_managerInput = {
    create?: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput> | TaskCreateWithoutCreator_managerInput[] | TaskUncheckedCreateWithoutCreator_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreator_managerInput | TaskCreateOrConnectWithoutCreator_managerInput[]
    createMany?: TaskCreateManyCreator_managerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectCommentCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput> | ProjectCommentCreateWithoutManagerInput[] | ProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutManagerInput | ProjectCommentCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCommentCreateManyManagerInputEnvelope
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
  }

  export type SubProjectCommentCreateNestedManyWithoutManagerInput = {
    create?: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput> | SubProjectCommentCreateWithoutManagerInput[] | SubProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutManagerInput | SubProjectCommentCreateOrConnectWithoutManagerInput[]
    createMany?: SubProjectCommentCreateManyManagerInputEnvelope
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
  }

  export type ManagerUncheckedCreateNestedManyWithoutSubordinatesInput = {
    create?: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput> | ManagerCreateWithoutSubordinatesInput[] | ManagerUncheckedCreateWithoutSubordinatesInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSubordinatesInput | ManagerCreateOrConnectWithoutSubordinatesInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
  }

  export type ManagerUncheckedCreateNestedManyWithoutSupervisorsInput = {
    create?: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput> | ManagerCreateWithoutSupervisorsInput[] | ManagerUncheckedCreateWithoutSupervisorsInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSupervisorsInput | ManagerCreateOrConnectWithoutSupervisorsInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
  }

  export type CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput> | CounterpartyCreateWithoutResponsible_managerInput[] | CounterpartyUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: CounterpartyCreateOrConnectWithoutResponsible_managerInput | CounterpartyCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: CounterpartyCreateManyResponsible_managerInputEnvelope
    connect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput> | SaleCreateWithoutResponsible_managerInput[] | SaleUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutResponsible_managerInput | SaleCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: SaleCreateManyResponsible_managerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput = {
    create?: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput> | ProjectCreateWithoutMain_responsible_managerInput[] | ProjectUncheckedCreateWithoutMain_responsible_managerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutMain_responsible_managerInput | ProjectCreateOrConnectWithoutMain_responsible_managerInput[]
    createMany?: ProjectCreateManyMain_responsible_managerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectManagerUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput> | ProjectManagerCreateWithoutManagerInput[] | ProjectManagerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutManagerInput | ProjectManagerCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectManagerCreateManyManagerInputEnvelope
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutResponsible_managerInput = {
    create?: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput> | TaskCreateWithoutResponsible_managerInput[] | TaskUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsible_managerInput | TaskCreateOrConnectWithoutResponsible_managerInput[]
    createMany?: TaskCreateManyResponsible_managerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutCreator_managerInput = {
    create?: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput> | TaskCreateWithoutCreator_managerInput[] | TaskUncheckedCreateWithoutCreator_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreator_managerInput | TaskCreateOrConnectWithoutCreator_managerInput[]
    createMany?: TaskCreateManyCreator_managerInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectCommentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput> | ProjectCommentCreateWithoutManagerInput[] | ProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutManagerInput | ProjectCommentCreateOrConnectWithoutManagerInput[]
    createMany?: ProjectCommentCreateManyManagerInputEnvelope
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
  }

  export type SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput> | SubProjectCommentCreateWithoutManagerInput[] | SubProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutManagerInput | SubProjectCommentCreateOrConnectWithoutManagerInput[]
    createMany?: SubProjectCommentCreateManyManagerInputEnvelope
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumManagerRoleFieldUpdateOperationsInput = {
    set?: $Enums.ManagerRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ManagerUpdateManyWithoutSubordinatesNestedInput = {
    create?: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput> | ManagerCreateWithoutSubordinatesInput[] | ManagerUncheckedCreateWithoutSubordinatesInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSubordinatesInput | ManagerCreateOrConnectWithoutSubordinatesInput[]
    upsert?: ManagerUpsertWithWhereUniqueWithoutSubordinatesInput | ManagerUpsertWithWhereUniqueWithoutSubordinatesInput[]
    set?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    disconnect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    delete?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    update?: ManagerUpdateWithWhereUniqueWithoutSubordinatesInput | ManagerUpdateWithWhereUniqueWithoutSubordinatesInput[]
    updateMany?: ManagerUpdateManyWithWhereWithoutSubordinatesInput | ManagerUpdateManyWithWhereWithoutSubordinatesInput[]
    deleteMany?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
  }

  export type ManagerUpdateManyWithoutSupervisorsNestedInput = {
    create?: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput> | ManagerCreateWithoutSupervisorsInput[] | ManagerUncheckedCreateWithoutSupervisorsInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSupervisorsInput | ManagerCreateOrConnectWithoutSupervisorsInput[]
    upsert?: ManagerUpsertWithWhereUniqueWithoutSupervisorsInput | ManagerUpsertWithWhereUniqueWithoutSupervisorsInput[]
    set?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    disconnect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    delete?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    update?: ManagerUpdateWithWhereUniqueWithoutSupervisorsInput | ManagerUpdateWithWhereUniqueWithoutSupervisorsInput[]
    updateMany?: ManagerUpdateManyWithWhereWithoutSupervisorsInput | ManagerUpdateManyWithWhereWithoutSupervisorsInput[]
    deleteMany?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
  }

  export type CounterpartyUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput> | CounterpartyCreateWithoutResponsible_managerInput[] | CounterpartyUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: CounterpartyCreateOrConnectWithoutResponsible_managerInput | CounterpartyCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: CounterpartyUpsertWithWhereUniqueWithoutResponsible_managerInput | CounterpartyUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: CounterpartyCreateManyResponsible_managerInputEnvelope
    set?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    disconnect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    delete?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    connect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    update?: CounterpartyUpdateWithWhereUniqueWithoutResponsible_managerInput | CounterpartyUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: CounterpartyUpdateManyWithWhereWithoutResponsible_managerInput | CounterpartyUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: CounterpartyScalarWhereInput | CounterpartyScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput> | SaleCreateWithoutResponsible_managerInput[] | SaleUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutResponsible_managerInput | SaleCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutResponsible_managerInput | SaleUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: SaleCreateManyResponsible_managerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutResponsible_managerInput | SaleUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutResponsible_managerInput | SaleUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutMain_responsible_managerNestedInput = {
    create?: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput> | ProjectCreateWithoutMain_responsible_managerInput[] | ProjectUncheckedCreateWithoutMain_responsible_managerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutMain_responsible_managerInput | ProjectCreateOrConnectWithoutMain_responsible_managerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutMain_responsible_managerInput | ProjectUpsertWithWhereUniqueWithoutMain_responsible_managerInput[]
    createMany?: ProjectCreateManyMain_responsible_managerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutMain_responsible_managerInput | ProjectUpdateWithWhereUniqueWithoutMain_responsible_managerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutMain_responsible_managerInput | ProjectUpdateManyWithWhereWithoutMain_responsible_managerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectManagerUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput> | ProjectManagerCreateWithoutManagerInput[] | ProjectManagerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutManagerInput | ProjectManagerCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectManagerUpsertWithWhereUniqueWithoutManagerInput | ProjectManagerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectManagerCreateManyManagerInputEnvelope
    set?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    disconnect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    delete?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    update?: ProjectManagerUpdateWithWhereUniqueWithoutManagerInput | ProjectManagerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectManagerUpdateManyWithWhereWithoutManagerInput | ProjectManagerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput> | TaskCreateWithoutResponsible_managerInput[] | TaskUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsible_managerInput | TaskCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutResponsible_managerInput | TaskUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: TaskCreateManyResponsible_managerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutResponsible_managerInput | TaskUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutResponsible_managerInput | TaskUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutCreator_managerNestedInput = {
    create?: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput> | TaskCreateWithoutCreator_managerInput[] | TaskUncheckedCreateWithoutCreator_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreator_managerInput | TaskCreateOrConnectWithoutCreator_managerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreator_managerInput | TaskUpsertWithWhereUniqueWithoutCreator_managerInput[]
    createMany?: TaskCreateManyCreator_managerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreator_managerInput | TaskUpdateWithWhereUniqueWithoutCreator_managerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreator_managerInput | TaskUpdateManyWithWhereWithoutCreator_managerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCommentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput> | ProjectCommentCreateWithoutManagerInput[] | ProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutManagerInput | ProjectCommentCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectCommentUpsertWithWhereUniqueWithoutManagerInput | ProjectCommentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCommentCreateManyManagerInputEnvelope
    set?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    disconnect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    delete?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    update?: ProjectCommentUpdateWithWhereUniqueWithoutManagerInput | ProjectCommentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectCommentUpdateManyWithWhereWithoutManagerInput | ProjectCommentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
  }

  export type SubProjectCommentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput> | SubProjectCommentCreateWithoutManagerInput[] | SubProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutManagerInput | SubProjectCommentCreateOrConnectWithoutManagerInput[]
    upsert?: SubProjectCommentUpsertWithWhereUniqueWithoutManagerInput | SubProjectCommentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: SubProjectCommentCreateManyManagerInputEnvelope
    set?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    disconnect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    delete?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    update?: SubProjectCommentUpdateWithWhereUniqueWithoutManagerInput | SubProjectCommentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: SubProjectCommentUpdateManyWithWhereWithoutManagerInput | SubProjectCommentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput = {
    create?: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput> | ManagerCreateWithoutSubordinatesInput[] | ManagerUncheckedCreateWithoutSubordinatesInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSubordinatesInput | ManagerCreateOrConnectWithoutSubordinatesInput[]
    upsert?: ManagerUpsertWithWhereUniqueWithoutSubordinatesInput | ManagerUpsertWithWhereUniqueWithoutSubordinatesInput[]
    set?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    disconnect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    delete?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    update?: ManagerUpdateWithWhereUniqueWithoutSubordinatesInput | ManagerUpdateWithWhereUniqueWithoutSubordinatesInput[]
    updateMany?: ManagerUpdateManyWithWhereWithoutSubordinatesInput | ManagerUpdateManyWithWhereWithoutSubordinatesInput[]
    deleteMany?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
  }

  export type ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput = {
    create?: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput> | ManagerCreateWithoutSupervisorsInput[] | ManagerUncheckedCreateWithoutSupervisorsInput[]
    connectOrCreate?: ManagerCreateOrConnectWithoutSupervisorsInput | ManagerCreateOrConnectWithoutSupervisorsInput[]
    upsert?: ManagerUpsertWithWhereUniqueWithoutSupervisorsInput | ManagerUpsertWithWhereUniqueWithoutSupervisorsInput[]
    set?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    disconnect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    delete?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    connect?: ManagerWhereUniqueInput | ManagerWhereUniqueInput[]
    update?: ManagerUpdateWithWhereUniqueWithoutSupervisorsInput | ManagerUpdateWithWhereUniqueWithoutSupervisorsInput[]
    updateMany?: ManagerUpdateManyWithWhereWithoutSupervisorsInput | ManagerUpdateManyWithWhereWithoutSupervisorsInput[]
    deleteMany?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
  }

  export type CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput> | CounterpartyCreateWithoutResponsible_managerInput[] | CounterpartyUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: CounterpartyCreateOrConnectWithoutResponsible_managerInput | CounterpartyCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: CounterpartyUpsertWithWhereUniqueWithoutResponsible_managerInput | CounterpartyUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: CounterpartyCreateManyResponsible_managerInputEnvelope
    set?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    disconnect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    delete?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    connect?: CounterpartyWhereUniqueInput | CounterpartyWhereUniqueInput[]
    update?: CounterpartyUpdateWithWhereUniqueWithoutResponsible_managerInput | CounterpartyUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: CounterpartyUpdateManyWithWhereWithoutResponsible_managerInput | CounterpartyUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: CounterpartyScalarWhereInput | CounterpartyScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput> | SaleCreateWithoutResponsible_managerInput[] | SaleUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutResponsible_managerInput | SaleCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutResponsible_managerInput | SaleUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: SaleCreateManyResponsible_managerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutResponsible_managerInput | SaleUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutResponsible_managerInput | SaleUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput = {
    create?: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput> | ProjectCreateWithoutMain_responsible_managerInput[] | ProjectUncheckedCreateWithoutMain_responsible_managerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutMain_responsible_managerInput | ProjectCreateOrConnectWithoutMain_responsible_managerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutMain_responsible_managerInput | ProjectUpsertWithWhereUniqueWithoutMain_responsible_managerInput[]
    createMany?: ProjectCreateManyMain_responsible_managerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutMain_responsible_managerInput | ProjectUpdateWithWhereUniqueWithoutMain_responsible_managerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutMain_responsible_managerInput | ProjectUpdateManyWithWhereWithoutMain_responsible_managerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput> | ProjectManagerCreateWithoutManagerInput[] | ProjectManagerUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutManagerInput | ProjectManagerCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectManagerUpsertWithWhereUniqueWithoutManagerInput | ProjectManagerUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectManagerCreateManyManagerInputEnvelope
    set?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    disconnect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    delete?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    update?: ProjectManagerUpdateWithWhereUniqueWithoutManagerInput | ProjectManagerUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectManagerUpdateManyWithWhereWithoutManagerInput | ProjectManagerUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput = {
    create?: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput> | TaskCreateWithoutResponsible_managerInput[] | TaskUncheckedCreateWithoutResponsible_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutResponsible_managerInput | TaskCreateOrConnectWithoutResponsible_managerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutResponsible_managerInput | TaskUpsertWithWhereUniqueWithoutResponsible_managerInput[]
    createMany?: TaskCreateManyResponsible_managerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutResponsible_managerInput | TaskUpdateWithWhereUniqueWithoutResponsible_managerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutResponsible_managerInput | TaskUpdateManyWithWhereWithoutResponsible_managerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutCreator_managerNestedInput = {
    create?: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput> | TaskCreateWithoutCreator_managerInput[] | TaskUncheckedCreateWithoutCreator_managerInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutCreator_managerInput | TaskCreateOrConnectWithoutCreator_managerInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutCreator_managerInput | TaskUpsertWithWhereUniqueWithoutCreator_managerInput[]
    createMany?: TaskCreateManyCreator_managerInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutCreator_managerInput | TaskUpdateWithWhereUniqueWithoutCreator_managerInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutCreator_managerInput | TaskUpdateManyWithWhereWithoutCreator_managerInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput> | ProjectCommentCreateWithoutManagerInput[] | ProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutManagerInput | ProjectCommentCreateOrConnectWithoutManagerInput[]
    upsert?: ProjectCommentUpsertWithWhereUniqueWithoutManagerInput | ProjectCommentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ProjectCommentCreateManyManagerInputEnvelope
    set?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    disconnect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    delete?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    update?: ProjectCommentUpdateWithWhereUniqueWithoutManagerInput | ProjectCommentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ProjectCommentUpdateManyWithWhereWithoutManagerInput | ProjectCommentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
  }

  export type SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput> | SubProjectCommentCreateWithoutManagerInput[] | SubProjectCommentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutManagerInput | SubProjectCommentCreateOrConnectWithoutManagerInput[]
    upsert?: SubProjectCommentUpsertWithWhereUniqueWithoutManagerInput | SubProjectCommentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: SubProjectCommentCreateManyManagerInputEnvelope
    set?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    disconnect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    delete?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    update?: SubProjectCommentUpdateWithWhereUniqueWithoutManagerInput | SubProjectCommentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: SubProjectCommentUpdateManyWithWhereWithoutManagerInput | SubProjectCommentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
  }

  export type ManagerCreateNestedOneWithoutCounterpartiesInput = {
    create?: XOR<ManagerCreateWithoutCounterpartiesInput, ManagerUncheckedCreateWithoutCounterpartiesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCounterpartiesInput
    connect?: ManagerWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutCounterpartyInput = {
    create?: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput> | SaleCreateWithoutCounterpartyInput[] | SaleUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCounterpartyInput | SaleCreateOrConnectWithoutCounterpartyInput[]
    createMany?: SaleCreateManyCounterpartyInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCounterpartyInput = {
    create?: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput> | ProjectCreateWithoutCounterpartyInput[] | ProjectUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCounterpartyInput | ProjectCreateOrConnectWithoutCounterpartyInput[]
    createMany?: ProjectCreateManyCounterpartyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCounterpartyInput = {
    create?: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput> | SaleCreateWithoutCounterpartyInput[] | SaleUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCounterpartyInput | SaleCreateOrConnectWithoutCounterpartyInput[]
    createMany?: SaleCreateManyCounterpartyInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCounterpartyInput = {
    create?: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput> | ProjectCreateWithoutCounterpartyInput[] | ProjectUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCounterpartyInput | ProjectCreateOrConnectWithoutCounterpartyInput[]
    createMany?: ProjectCreateManyCounterpartyInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type EnumCounterpartyTypeFieldUpdateOperationsInput = {
    set?: $Enums.CounterpartyType
  }

  export type ManagerUpdateOneWithoutCounterpartiesNestedInput = {
    create?: XOR<ManagerCreateWithoutCounterpartiesInput, ManagerUncheckedCreateWithoutCounterpartiesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCounterpartiesInput
    upsert?: ManagerUpsertWithoutCounterpartiesInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutCounterpartiesInput, ManagerUpdateWithoutCounterpartiesInput>, ManagerUncheckedUpdateWithoutCounterpartiesInput>
  }

  export type SaleUpdateManyWithoutCounterpartyNestedInput = {
    create?: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput> | SaleCreateWithoutCounterpartyInput[] | SaleUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCounterpartyInput | SaleCreateOrConnectWithoutCounterpartyInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCounterpartyInput | SaleUpsertWithWhereUniqueWithoutCounterpartyInput[]
    createMany?: SaleCreateManyCounterpartyInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCounterpartyInput | SaleUpdateWithWhereUniqueWithoutCounterpartyInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCounterpartyInput | SaleUpdateManyWithWhereWithoutCounterpartyInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCounterpartyNestedInput = {
    create?: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput> | ProjectCreateWithoutCounterpartyInput[] | ProjectUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCounterpartyInput | ProjectCreateOrConnectWithoutCounterpartyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCounterpartyInput | ProjectUpsertWithWhereUniqueWithoutCounterpartyInput[]
    createMany?: ProjectCreateManyCounterpartyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCounterpartyInput | ProjectUpdateWithWhereUniqueWithoutCounterpartyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCounterpartyInput | ProjectUpdateManyWithWhereWithoutCounterpartyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SaleUncheckedUpdateManyWithoutCounterpartyNestedInput = {
    create?: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput> | SaleCreateWithoutCounterpartyInput[] | SaleUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCounterpartyInput | SaleCreateOrConnectWithoutCounterpartyInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCounterpartyInput | SaleUpsertWithWhereUniqueWithoutCounterpartyInput[]
    createMany?: SaleCreateManyCounterpartyInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCounterpartyInput | SaleUpdateWithWhereUniqueWithoutCounterpartyInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCounterpartyInput | SaleUpdateManyWithWhereWithoutCounterpartyInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCounterpartyNestedInput = {
    create?: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput> | ProjectCreateWithoutCounterpartyInput[] | ProjectUncheckedCreateWithoutCounterpartyInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCounterpartyInput | ProjectCreateOrConnectWithoutCounterpartyInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCounterpartyInput | ProjectUpsertWithWhereUniqueWithoutCounterpartyInput[]
    createMany?: ProjectCreateManyCounterpartyInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCounterpartyInput | ProjectUpdateWithWhereUniqueWithoutCounterpartyInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCounterpartyInput | ProjectUpdateManyWithWhereWithoutCounterpartyInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductStockCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput> | ProductStockCreateWithoutWarehouseInput[] | ProductStockUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutWarehouseInput | ProductStockCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductStockCreateManyWarehouseInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput> | ProductStockCreateWithoutWarehouseInput[] | ProductStockUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutWarehouseInput | ProductStockCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductStockCreateManyWarehouseInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type ProductStockUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput> | ProductStockCreateWithoutWarehouseInput[] | ProductStockUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutWarehouseInput | ProductStockCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutWarehouseInput | ProductStockUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductStockCreateManyWarehouseInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutWarehouseInput | ProductStockUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutWarehouseInput | ProductStockUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput> | ProductStockCreateWithoutWarehouseInput[] | ProductStockUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutWarehouseInput | ProductStockCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutWarehouseInput | ProductStockUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductStockCreateManyWarehouseInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutWarehouseInput | ProductStockUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutWarehouseInput | ProductStockUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutProductsInput = {
    create?: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductsInput
    connect?: UnitWhereUniqueInput
  }

  export type ProductStockCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type SaleProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type ProjectProductCreateNestedManyWithoutProductInput = {
    create?: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput> | ProjectProductCreateWithoutProductInput[] | ProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProductInput | ProjectProductCreateOrConnectWithoutProductInput[]
    createMany?: ProjectProductCreateManyProductInputEnvelope
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
  }

  export type SubProjectProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput> | SubProjectProductCreateWithoutProductInput[] | SubProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutProductInput | SubProjectProductCreateOrConnectWithoutProductInput[]
    createMany?: SubProjectProductCreateManyProductInputEnvelope
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
  }

  export type ProductStockUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
  }

  export type SaleProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type ProjectProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput> | ProjectProductCreateWithoutProductInput[] | ProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProductInput | ProjectProductCreateOrConnectWithoutProductInput[]
    createMany?: ProjectProductCreateManyProductInputEnvelope
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
  }

  export type SubProjectProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput> | SubProjectProductCreateWithoutProductInput[] | SubProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutProductInput | SubProjectProductCreateOrConnectWithoutProductInput[]
    createMany?: SubProjectProductCreateManyProductInputEnvelope
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UnitUpdateOneWithoutProductsNestedInput = {
    create?: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductsInput
    upsert?: UnitUpsertWithoutProductsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutProductsInput, UnitUpdateWithoutProductsInput>, UnitUncheckedUpdateWithoutProductsInput>
  }

  export type ProductStockUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutProductInput | ProductStockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutProductInput | ProductStockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutProductInput | ProductStockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type SaleProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type ProjectProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput> | ProjectProductCreateWithoutProductInput[] | ProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProductInput | ProjectProductCreateOrConnectWithoutProductInput[]
    upsert?: ProjectProductUpsertWithWhereUniqueWithoutProductInput | ProjectProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProjectProductCreateManyProductInputEnvelope
    set?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    disconnect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    delete?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    update?: ProjectProductUpdateWithWhereUniqueWithoutProductInput | ProjectProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProjectProductUpdateManyWithWhereWithoutProductInput | ProjectProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
  }

  export type SubProjectProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput> | SubProjectProductCreateWithoutProductInput[] | SubProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutProductInput | SubProjectProductCreateOrConnectWithoutProductInput[]
    upsert?: SubProjectProductUpsertWithWhereUniqueWithoutProductInput | SubProjectProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SubProjectProductCreateManyProductInputEnvelope
    set?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    disconnect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    delete?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    update?: SubProjectProductUpdateWithWhereUniqueWithoutProductInput | SubProjectProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SubProjectProductUpdateManyWithWhereWithoutProductInput | SubProjectProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
  }

  export type ProductStockUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput> | ProductStockCreateWithoutProductInput[] | ProductStockUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductStockCreateOrConnectWithoutProductInput | ProductStockCreateOrConnectWithoutProductInput[]
    upsert?: ProductStockUpsertWithWhereUniqueWithoutProductInput | ProductStockUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductStockCreateManyProductInputEnvelope
    set?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    disconnect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    delete?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    connect?: ProductStockWhereUniqueInput | ProductStockWhereUniqueInput[]
    update?: ProductStockUpdateWithWhereUniqueWithoutProductInput | ProductStockUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductStockUpdateManyWithWhereWithoutProductInput | ProductStockUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
  }

  export type SaleProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type ProjectProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput> | ProjectProductCreateWithoutProductInput[] | ProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProductInput | ProjectProductCreateOrConnectWithoutProductInput[]
    upsert?: ProjectProductUpsertWithWhereUniqueWithoutProductInput | ProjectProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProjectProductCreateManyProductInputEnvelope
    set?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    disconnect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    delete?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    update?: ProjectProductUpdateWithWhereUniqueWithoutProductInput | ProjectProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProjectProductUpdateManyWithWhereWithoutProductInput | ProjectProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
  }

  export type SubProjectProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput> | SubProjectProductCreateWithoutProductInput[] | SubProjectProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutProductInput | SubProjectProductCreateOrConnectWithoutProductInput[]
    upsert?: SubProjectProductUpsertWithWhereUniqueWithoutProductInput | SubProjectProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SubProjectProductCreateManyProductInputEnvelope
    set?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    disconnect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    delete?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    update?: SubProjectProductUpdateWithWhereUniqueWithoutProductInput | SubProjectProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SubProjectProductUpdateManyWithWhereWithoutProductInput | SubProjectProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStocksInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    connect?: ProductWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutProduct_stocksInput = {
    create?: XOR<WarehouseCreateWithoutProduct_stocksInput, WarehouseUncheckedCreateWithoutProduct_stocksInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProduct_stocksInput
    connect?: WarehouseWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStocksInput
    upsert?: ProductUpsertWithoutStocksInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStocksInput, ProductUpdateWithoutStocksInput>, ProductUncheckedUpdateWithoutStocksInput>
  }

  export type WarehouseUpdateOneRequiredWithoutProduct_stocksNestedInput = {
    create?: XOR<WarehouseCreateWithoutProduct_stocksInput, WarehouseUncheckedCreateWithoutProduct_stocksInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProduct_stocksInput
    upsert?: WarehouseUpsertWithoutProduct_stocksInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutProduct_stocksInput, WarehouseUpdateWithoutProduct_stocksInput>, WarehouseUncheckedUpdateWithoutProduct_stocksInput>
  }

  export type SaleServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type ProjectServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput> | ProjectServiceCreateWithoutServiceInput[] | ProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutServiceInput | ProjectServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ProjectServiceCreateManyServiceInputEnvelope
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
  }

  export type SubProjectServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput> | SubProjectServiceCreateWithoutServiceInput[] | SubProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutServiceInput | SubProjectServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SubProjectServiceCreateManyServiceInputEnvelope
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
  }

  export type SaleServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type ProjectServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput> | ProjectServiceCreateWithoutServiceInput[] | ProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutServiceInput | ProjectServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ProjectServiceCreateManyServiceInputEnvelope
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
  }

  export type SubProjectServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput> | SubProjectServiceCreateWithoutServiceInput[] | SubProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutServiceInput | SubProjectServiceCreateOrConnectWithoutServiceInput[]
    createMany?: SubProjectServiceCreateManyServiceInputEnvelope
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
  }

  export type SaleServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutServiceInput | SaleServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutServiceInput | SaleServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutServiceInput | SaleServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type ProjectServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput> | ProjectServiceCreateWithoutServiceInput[] | ProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutServiceInput | ProjectServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ProjectServiceUpsertWithWhereUniqueWithoutServiceInput | ProjectServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProjectServiceCreateManyServiceInputEnvelope
    set?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    disconnect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    delete?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    update?: ProjectServiceUpdateWithWhereUniqueWithoutServiceInput | ProjectServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProjectServiceUpdateManyWithWhereWithoutServiceInput | ProjectServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
  }

  export type SubProjectServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput> | SubProjectServiceCreateWithoutServiceInput[] | SubProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutServiceInput | SubProjectServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SubProjectServiceUpsertWithWhereUniqueWithoutServiceInput | SubProjectServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SubProjectServiceCreateManyServiceInputEnvelope
    set?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    disconnect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    delete?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    update?: SubProjectServiceUpdateWithWhereUniqueWithoutServiceInput | SubProjectServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SubProjectServiceUpdateManyWithWhereWithoutServiceInput | SubProjectServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
  }

  export type SaleServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput> | SaleServiceCreateWithoutServiceInput[] | SaleServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutServiceInput | SaleServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutServiceInput | SaleServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SaleServiceCreateManyServiceInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutServiceInput | SaleServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutServiceInput | SaleServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type ProjectServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput> | ProjectServiceCreateWithoutServiceInput[] | ProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutServiceInput | ProjectServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ProjectServiceUpsertWithWhereUniqueWithoutServiceInput | ProjectServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProjectServiceCreateManyServiceInputEnvelope
    set?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    disconnect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    delete?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    update?: ProjectServiceUpdateWithWhereUniqueWithoutServiceInput | ProjectServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProjectServiceUpdateManyWithWhereWithoutServiceInput | ProjectServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
  }

  export type SubProjectServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput> | SubProjectServiceCreateWithoutServiceInput[] | SubProjectServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutServiceInput | SubProjectServiceCreateOrConnectWithoutServiceInput[]
    upsert?: SubProjectServiceUpsertWithWhereUniqueWithoutServiceInput | SubProjectServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: SubProjectServiceCreateManyServiceInputEnvelope
    set?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    disconnect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    delete?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    update?: SubProjectServiceUpdateWithWhereUniqueWithoutServiceInput | SubProjectServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: SubProjectServiceUpdateManyWithWhereWithoutServiceInput | SubProjectServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
  }

  export type SaleCreateNestedManyWithoutSale_status_typeInput = {
    create?: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput> | SaleCreateWithoutSale_status_typeInput[] | SaleUncheckedCreateWithoutSale_status_typeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSale_status_typeInput | SaleCreateOrConnectWithoutSale_status_typeInput[]
    createMany?: SaleCreateManySale_status_typeInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutSale_status_typeInput = {
    create?: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput> | SaleCreateWithoutSale_status_typeInput[] | SaleUncheckedCreateWithoutSale_status_typeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSale_status_typeInput | SaleCreateOrConnectWithoutSale_status_typeInput[]
    createMany?: SaleCreateManySale_status_typeInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleUpdateManyWithoutSale_status_typeNestedInput = {
    create?: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput> | SaleCreateWithoutSale_status_typeInput[] | SaleUncheckedCreateWithoutSale_status_typeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSale_status_typeInput | SaleCreateOrConnectWithoutSale_status_typeInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutSale_status_typeInput | SaleUpsertWithWhereUniqueWithoutSale_status_typeInput[]
    createMany?: SaleCreateManySale_status_typeInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutSale_status_typeInput | SaleUpdateWithWhereUniqueWithoutSale_status_typeInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutSale_status_typeInput | SaleUpdateManyWithWhereWithoutSale_status_typeInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutSale_status_typeNestedInput = {
    create?: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput> | SaleCreateWithoutSale_status_typeInput[] | SaleUncheckedCreateWithoutSale_status_typeInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSale_status_typeInput | SaleCreateOrConnectWithoutSale_status_typeInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutSale_status_typeInput | SaleUpsertWithWhereUniqueWithoutSale_status_typeInput[]
    createMany?: SaleCreateManySale_status_typeInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutSale_status_typeInput | SaleUpdateWithWhereUniqueWithoutSale_status_typeInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutSale_status_typeInput | SaleUpdateManyWithWhereWithoutSale_status_typeInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type CounterpartyCreateNestedOneWithoutSalesInput = {
    create?: XOR<CounterpartyCreateWithoutSalesInput, CounterpartyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CounterpartyCreateOrConnectWithoutSalesInput
    connect?: CounterpartyWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutSalesInput = {
    create?: XOR<ManagerCreateWithoutSalesInput, ManagerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutSalesInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSalesInput = {
    create?: XOR<ProjectCreateWithoutSalesInput, ProjectUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSalesInput
    connect?: ProjectWhereUniqueInput
  }

  export type SaleProductCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleServiceCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type SaleStatusTypeCreateNestedOneWithoutSalesInput = {
    create?: XOR<SaleStatusTypeCreateWithoutSalesInput, SaleStatusTypeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: SaleStatusTypeCreateOrConnectWithoutSalesInput
    connect?: SaleStatusTypeWhereUniqueInput
  }

  export type SaleProductUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleServiceUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CounterpartyUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<CounterpartyCreateWithoutSalesInput, CounterpartyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CounterpartyCreateOrConnectWithoutSalesInput
    upsert?: CounterpartyUpsertWithoutSalesInput
    connect?: CounterpartyWhereUniqueInput
    update?: XOR<XOR<CounterpartyUpdateToOneWithWhereWithoutSalesInput, CounterpartyUpdateWithoutSalesInput>, CounterpartyUncheckedUpdateWithoutSalesInput>
  }

  export type ManagerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<ManagerCreateWithoutSalesInput, ManagerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutSalesInput
    upsert?: ManagerUpsertWithoutSalesInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutSalesInput, ManagerUpdateWithoutSalesInput>, ManagerUncheckedUpdateWithoutSalesInput>
  }

  export type ProjectUpdateOneWithoutSalesNestedInput = {
    create?: XOR<ProjectCreateWithoutSalesInput, ProjectUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSalesInput
    upsert?: ProjectUpsertWithoutSalesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSalesInput, ProjectUpdateWithoutSalesInput>, ProjectUncheckedUpdateWithoutSalesInput>
  }

  export type SaleProductUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleServiceUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutSaleInput | SaleServiceUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutSaleInput | SaleServiceUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutSaleInput | SaleServiceUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleStatusTypeUpdateOneWithoutSalesNestedInput = {
    create?: XOR<SaleStatusTypeCreateWithoutSalesInput, SaleStatusTypeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: SaleStatusTypeCreateOrConnectWithoutSalesInput
    upsert?: SaleStatusTypeUpsertWithoutSalesInput
    disconnect?: SaleStatusTypeWhereInput | boolean
    delete?: SaleStatusTypeWhereInput | boolean
    connect?: SaleStatusTypeWhereUniqueInput
    update?: XOR<XOR<SaleStatusTypeUpdateToOneWithWhereWithoutSalesInput, SaleStatusTypeUpdateWithoutSalesInput>, SaleStatusTypeUncheckedUpdateWithoutSalesInput>
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleServiceUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput> | SaleServiceCreateWithoutSaleInput[] | SaleServiceUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleServiceCreateOrConnectWithoutSaleInput | SaleServiceCreateOrConnectWithoutSaleInput[]
    upsert?: SaleServiceUpsertWithWhereUniqueWithoutSaleInput | SaleServiceUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleServiceCreateManySaleInputEnvelope
    set?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    disconnect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    delete?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    connect?: SaleServiceWhereUniqueInput | SaleServiceWhereUniqueInput[]
    update?: SaleServiceUpdateWithWhereUniqueWithoutSaleInput | SaleServiceUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleServiceUpdateManyWithWhereWithoutSaleInput | SaleServiceUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutProductsInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    connect?: SaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSalesInput = {
    create?: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesInput
    connect?: ProductWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    upsert?: SaleUpsertWithoutProductsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutProductsInput, SaleUpdateWithoutProductsInput>, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesInput
    upsert?: ProductUpsertWithoutSalesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSalesInput, ProductUpdateWithoutSalesInput>, ProductUncheckedUpdateWithoutSalesInput>
  }

  export type SaleCreateNestedOneWithoutServicesInput = {
    create?: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutServicesInput
    connect?: SaleWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutSalesInput = {
    create?: XOR<ServiceCreateWithoutSalesInput, ServiceUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSalesInput
    connect?: ServiceWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutServicesInput
    upsert?: SaleUpsertWithoutServicesInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutServicesInput, SaleUpdateWithoutServicesInput>, SaleUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<ServiceCreateWithoutSalesInput, ServiceUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSalesInput
    upsert?: ServiceUpsertWithoutSalesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutSalesInput, ServiceUpdateWithoutSalesInput>, ServiceUncheckedUpdateWithoutSalesInput>
  }

  export type FunnelStageCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput> | FunnelStageCreateWithoutFunnelInput[] | FunnelStageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelStageCreateOrConnectWithoutFunnelInput | FunnelStageCreateOrConnectWithoutFunnelInput[]
    createMany?: FunnelStageCreateManyFunnelInputEnvelope
    connect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput> | ProjectCreateWithoutFunnelInput[] | ProjectUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnelInput | ProjectCreateOrConnectWithoutFunnelInput[]
    createMany?: ProjectCreateManyFunnelInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FunnelStageUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput> | FunnelStageCreateWithoutFunnelInput[] | FunnelStageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelStageCreateOrConnectWithoutFunnelInput | FunnelStageCreateOrConnectWithoutFunnelInput[]
    createMany?: FunnelStageCreateManyFunnelInputEnvelope
    connect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput> | ProjectCreateWithoutFunnelInput[] | ProjectUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnelInput | ProjectCreateOrConnectWithoutFunnelInput[]
    createMany?: ProjectCreateManyFunnelInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FunnelStageUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput> | FunnelStageCreateWithoutFunnelInput[] | FunnelStageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelStageCreateOrConnectWithoutFunnelInput | FunnelStageCreateOrConnectWithoutFunnelInput[]
    upsert?: FunnelStageUpsertWithWhereUniqueWithoutFunnelInput | FunnelStageUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunnelStageCreateManyFunnelInputEnvelope
    set?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    disconnect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    delete?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    connect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    update?: FunnelStageUpdateWithWhereUniqueWithoutFunnelInput | FunnelStageUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunnelStageUpdateManyWithWhereWithoutFunnelInput | FunnelStageUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunnelStageScalarWhereInput | FunnelStageScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput> | ProjectCreateWithoutFunnelInput[] | ProjectUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnelInput | ProjectCreateOrConnectWithoutFunnelInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFunnelInput | ProjectUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ProjectCreateManyFunnelInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFunnelInput | ProjectUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFunnelInput | ProjectUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type FunnelStageUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput> | FunnelStageCreateWithoutFunnelInput[] | FunnelStageUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunnelStageCreateOrConnectWithoutFunnelInput | FunnelStageCreateOrConnectWithoutFunnelInput[]
    upsert?: FunnelStageUpsertWithWhereUniqueWithoutFunnelInput | FunnelStageUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunnelStageCreateManyFunnelInputEnvelope
    set?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    disconnect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    delete?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    connect?: FunnelStageWhereUniqueInput | FunnelStageWhereUniqueInput[]
    update?: FunnelStageUpdateWithWhereUniqueWithoutFunnelInput | FunnelStageUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunnelStageUpdateManyWithWhereWithoutFunnelInput | FunnelStageUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunnelStageScalarWhereInput | FunnelStageScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput> | ProjectCreateWithoutFunnelInput[] | ProjectUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnelInput | ProjectCreateOrConnectWithoutFunnelInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFunnelInput | ProjectUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ProjectCreateManyFunnelInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFunnelInput | ProjectUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFunnelInput | ProjectUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type FunnelCreateNestedOneWithoutStagesInput = {
    create?: XOR<FunnelCreateWithoutStagesInput, FunnelUncheckedCreateWithoutStagesInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutStagesInput
    connect?: FunnelWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutFunnel_stageInput = {
    create?: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput> | ProjectCreateWithoutFunnel_stageInput[] | ProjectUncheckedCreateWithoutFunnel_stageInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnel_stageInput | ProjectCreateOrConnectWithoutFunnel_stageInput[]
    createMany?: ProjectCreateManyFunnel_stageInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutFunnel_stageInput = {
    create?: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput> | ProjectCreateWithoutFunnel_stageInput[] | ProjectUncheckedCreateWithoutFunnel_stageInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnel_stageInput | ProjectCreateOrConnectWithoutFunnel_stageInput[]
    createMany?: ProjectCreateManyFunnel_stageInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FunnelUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<FunnelCreateWithoutStagesInput, FunnelUncheckedCreateWithoutStagesInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutStagesInput
    upsert?: FunnelUpsertWithoutStagesInput
    connect?: FunnelWhereUniqueInput
    update?: XOR<XOR<FunnelUpdateToOneWithWhereWithoutStagesInput, FunnelUpdateWithoutStagesInput>, FunnelUncheckedUpdateWithoutStagesInput>
  }

  export type ProjectUpdateManyWithoutFunnel_stageNestedInput = {
    create?: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput> | ProjectCreateWithoutFunnel_stageInput[] | ProjectUncheckedCreateWithoutFunnel_stageInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnel_stageInput | ProjectCreateOrConnectWithoutFunnel_stageInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFunnel_stageInput | ProjectUpsertWithWhereUniqueWithoutFunnel_stageInput[]
    createMany?: ProjectCreateManyFunnel_stageInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFunnel_stageInput | ProjectUpdateWithWhereUniqueWithoutFunnel_stageInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFunnel_stageInput | ProjectUpdateManyWithWhereWithoutFunnel_stageInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutFunnel_stageNestedInput = {
    create?: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput> | ProjectCreateWithoutFunnel_stageInput[] | ProjectUncheckedCreateWithoutFunnel_stageInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFunnel_stageInput | ProjectCreateOrConnectWithoutFunnel_stageInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFunnel_stageInput | ProjectUpsertWithWhereUniqueWithoutFunnel_stageInput[]
    createMany?: ProjectCreateManyFunnel_stageInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFunnel_stageInput | ProjectUpdateWithWhereUniqueWithoutFunnel_stageInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFunnel_stageInput | ProjectUpdateManyWithWhereWithoutFunnel_stageInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ManagerCreateNestedOneWithoutProjects_as_mainInput = {
    create?: XOR<ManagerCreateWithoutProjects_as_mainInput, ManagerUncheckedCreateWithoutProjects_as_mainInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjects_as_mainInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectManagerCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput> | ProjectManagerCreateWithoutProjectInput[] | ProjectManagerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutProjectInput | ProjectManagerCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectManagerCreateManyProjectInputEnvelope
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
  }

  export type CounterpartyCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CounterpartyCreateWithoutProjectsInput, CounterpartyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CounterpartyCreateOrConnectWithoutProjectsInput
    connect?: CounterpartyWhereUniqueInput
  }

  export type FunnelCreateNestedOneWithoutProjectsInput = {
    create?: XOR<FunnelCreateWithoutProjectsInput, FunnelUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutProjectsInput
    connect?: FunnelWhereUniqueInput
  }

  export type FunnelStageCreateNestedOneWithoutProjectsInput = {
    create?: XOR<FunnelStageCreateWithoutProjectsInput, FunnelStageUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: FunnelStageCreateOrConnectWithoutProjectsInput
    connect?: FunnelStageWhereUniqueInput
  }

  export type SubProjectCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput> | SubProjectCreateWithoutProjectInput[] | SubProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubProjectCreateOrConnectWithoutProjectInput | SubProjectCreateOrConnectWithoutProjectInput[]
    createMany?: SubProjectCreateManyProjectInputEnvelope
    connect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutProjectInput = {
    create?: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput> | SaleCreateWithoutProjectInput[] | SaleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProjectInput | SaleCreateOrConnectWithoutProjectInput[]
    createMany?: SaleCreateManyProjectInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectProductCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput> | ProjectProductCreateWithoutProjectInput[] | ProjectProductUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProjectInput | ProjectProductCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectProductCreateManyProjectInputEnvelope
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
  }

  export type ProjectServiceCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput> | ProjectServiceCreateWithoutProjectInput[] | ProjectServiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutProjectInput | ProjectServiceCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectServiceCreateManyProjectInputEnvelope
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
  }

  export type ProjectCommentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput> | ProjectCommentCreateWithoutProjectInput[] | ProjectCommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutProjectInput | ProjectCommentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCommentCreateManyProjectInputEnvelope
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
  }

  export type ProjectManagerUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput> | ProjectManagerCreateWithoutProjectInput[] | ProjectManagerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutProjectInput | ProjectManagerCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectManagerCreateManyProjectInputEnvelope
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
  }

  export type SubProjectUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput> | SubProjectCreateWithoutProjectInput[] | SubProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubProjectCreateOrConnectWithoutProjectInput | SubProjectCreateOrConnectWithoutProjectInput[]
    createMany?: SubProjectCreateManyProjectInputEnvelope
    connect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput> | SaleCreateWithoutProjectInput[] | SaleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProjectInput | SaleCreateOrConnectWithoutProjectInput[]
    createMany?: SaleCreateManyProjectInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ProjectProductUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput> | ProjectProductCreateWithoutProjectInput[] | ProjectProductUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProjectInput | ProjectProductCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectProductCreateManyProjectInputEnvelope
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
  }

  export type ProjectServiceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput> | ProjectServiceCreateWithoutProjectInput[] | ProjectServiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutProjectInput | ProjectServiceCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectServiceCreateManyProjectInputEnvelope
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
  }

  export type ProjectCommentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput> | ProjectCommentCreateWithoutProjectInput[] | ProjectCommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutProjectInput | ProjectCommentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectCommentCreateManyProjectInputEnvelope
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
  }

  export type ManagerUpdateOneWithoutProjects_as_mainNestedInput = {
    create?: XOR<ManagerCreateWithoutProjects_as_mainInput, ManagerUncheckedCreateWithoutProjects_as_mainInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjects_as_mainInput
    upsert?: ManagerUpsertWithoutProjects_as_mainInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutProjects_as_mainInput, ManagerUpdateWithoutProjects_as_mainInput>, ManagerUncheckedUpdateWithoutProjects_as_mainInput>
  }

  export type ProjectManagerUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput> | ProjectManagerCreateWithoutProjectInput[] | ProjectManagerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutProjectInput | ProjectManagerCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectManagerUpsertWithWhereUniqueWithoutProjectInput | ProjectManagerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectManagerCreateManyProjectInputEnvelope
    set?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    disconnect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    delete?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    update?: ProjectManagerUpdateWithWhereUniqueWithoutProjectInput | ProjectManagerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectManagerUpdateManyWithWhereWithoutProjectInput | ProjectManagerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
  }

  export type CounterpartyUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<CounterpartyCreateWithoutProjectsInput, CounterpartyUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CounterpartyCreateOrConnectWithoutProjectsInput
    upsert?: CounterpartyUpsertWithoutProjectsInput
    disconnect?: CounterpartyWhereInput | boolean
    delete?: CounterpartyWhereInput | boolean
    connect?: CounterpartyWhereUniqueInput
    update?: XOR<XOR<CounterpartyUpdateToOneWithWhereWithoutProjectsInput, CounterpartyUpdateWithoutProjectsInput>, CounterpartyUncheckedUpdateWithoutProjectsInput>
  }

  export type FunnelUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<FunnelCreateWithoutProjectsInput, FunnelUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: FunnelCreateOrConnectWithoutProjectsInput
    upsert?: FunnelUpsertWithoutProjectsInput
    disconnect?: FunnelWhereInput | boolean
    delete?: FunnelWhereInput | boolean
    connect?: FunnelWhereUniqueInput
    update?: XOR<XOR<FunnelUpdateToOneWithWhereWithoutProjectsInput, FunnelUpdateWithoutProjectsInput>, FunnelUncheckedUpdateWithoutProjectsInput>
  }

  export type FunnelStageUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<FunnelStageCreateWithoutProjectsInput, FunnelStageUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: FunnelStageCreateOrConnectWithoutProjectsInput
    upsert?: FunnelStageUpsertWithoutProjectsInput
    disconnect?: FunnelStageWhereInput | boolean
    delete?: FunnelStageWhereInput | boolean
    connect?: FunnelStageWhereUniqueInput
    update?: XOR<XOR<FunnelStageUpdateToOneWithWhereWithoutProjectsInput, FunnelStageUpdateWithoutProjectsInput>, FunnelStageUncheckedUpdateWithoutProjectsInput>
  }

  export type SubProjectUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput> | SubProjectCreateWithoutProjectInput[] | SubProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubProjectCreateOrConnectWithoutProjectInput | SubProjectCreateOrConnectWithoutProjectInput[]
    upsert?: SubProjectUpsertWithWhereUniqueWithoutProjectInput | SubProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubProjectCreateManyProjectInputEnvelope
    set?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    disconnect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    delete?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    connect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    update?: SubProjectUpdateWithWhereUniqueWithoutProjectInput | SubProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubProjectUpdateManyWithWhereWithoutProjectInput | SubProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubProjectScalarWhereInput | SubProjectScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput> | SaleCreateWithoutProjectInput[] | SaleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProjectInput | SaleCreateOrConnectWithoutProjectInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutProjectInput | SaleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SaleCreateManyProjectInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutProjectInput | SaleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutProjectInput | SaleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectProductUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput> | ProjectProductCreateWithoutProjectInput[] | ProjectProductUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProjectInput | ProjectProductCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectProductUpsertWithWhereUniqueWithoutProjectInput | ProjectProductUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectProductCreateManyProjectInputEnvelope
    set?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    disconnect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    delete?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    update?: ProjectProductUpdateWithWhereUniqueWithoutProjectInput | ProjectProductUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectProductUpdateManyWithWhereWithoutProjectInput | ProjectProductUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
  }

  export type ProjectServiceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput> | ProjectServiceCreateWithoutProjectInput[] | ProjectServiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutProjectInput | ProjectServiceCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectServiceUpsertWithWhereUniqueWithoutProjectInput | ProjectServiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectServiceCreateManyProjectInputEnvelope
    set?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    disconnect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    delete?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    update?: ProjectServiceUpdateWithWhereUniqueWithoutProjectInput | ProjectServiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectServiceUpdateManyWithWhereWithoutProjectInput | ProjectServiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
  }

  export type ProjectCommentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput> | ProjectCommentCreateWithoutProjectInput[] | ProjectCommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutProjectInput | ProjectCommentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCommentUpsertWithWhereUniqueWithoutProjectInput | ProjectCommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCommentCreateManyProjectInputEnvelope
    set?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    disconnect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    delete?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    update?: ProjectCommentUpdateWithWhereUniqueWithoutProjectInput | ProjectCommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCommentUpdateManyWithWhereWithoutProjectInput | ProjectCommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
  }

  export type ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput> | ProjectManagerCreateWithoutProjectInput[] | ProjectManagerUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectManagerCreateOrConnectWithoutProjectInput | ProjectManagerCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectManagerUpsertWithWhereUniqueWithoutProjectInput | ProjectManagerUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectManagerCreateManyProjectInputEnvelope
    set?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    disconnect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    delete?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    connect?: ProjectManagerWhereUniqueInput | ProjectManagerWhereUniqueInput[]
    update?: ProjectManagerUpdateWithWhereUniqueWithoutProjectInput | ProjectManagerUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectManagerUpdateManyWithWhereWithoutProjectInput | ProjectManagerUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
  }

  export type SubProjectUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput> | SubProjectCreateWithoutProjectInput[] | SubProjectUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubProjectCreateOrConnectWithoutProjectInput | SubProjectCreateOrConnectWithoutProjectInput[]
    upsert?: SubProjectUpsertWithWhereUniqueWithoutProjectInput | SubProjectUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubProjectCreateManyProjectInputEnvelope
    set?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    disconnect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    delete?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    connect?: SubProjectWhereUniqueInput | SubProjectWhereUniqueInput[]
    update?: SubProjectUpdateWithWhereUniqueWithoutProjectInput | SubProjectUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubProjectUpdateManyWithWhereWithoutProjectInput | SubProjectUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubProjectScalarWhereInput | SubProjectScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput> | SaleCreateWithoutProjectInput[] | SaleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProjectInput | SaleCreateOrConnectWithoutProjectInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutProjectInput | SaleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SaleCreateManyProjectInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutProjectInput | SaleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutProjectInput | SaleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProjectProductUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput> | ProjectProductCreateWithoutProjectInput[] | ProjectProductUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectProductCreateOrConnectWithoutProjectInput | ProjectProductCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectProductUpsertWithWhereUniqueWithoutProjectInput | ProjectProductUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectProductCreateManyProjectInputEnvelope
    set?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    disconnect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    delete?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    connect?: ProjectProductWhereUniqueInput | ProjectProductWhereUniqueInput[]
    update?: ProjectProductUpdateWithWhereUniqueWithoutProjectInput | ProjectProductUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectProductUpdateManyWithWhereWithoutProjectInput | ProjectProductUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
  }

  export type ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput> | ProjectServiceCreateWithoutProjectInput[] | ProjectServiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectServiceCreateOrConnectWithoutProjectInput | ProjectServiceCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectServiceUpsertWithWhereUniqueWithoutProjectInput | ProjectServiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectServiceCreateManyProjectInputEnvelope
    set?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    disconnect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    delete?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    connect?: ProjectServiceWhereUniqueInput | ProjectServiceWhereUniqueInput[]
    update?: ProjectServiceUpdateWithWhereUniqueWithoutProjectInput | ProjectServiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectServiceUpdateManyWithWhereWithoutProjectInput | ProjectServiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
  }

  export type ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput> | ProjectCommentCreateWithoutProjectInput[] | ProjectCommentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectCommentCreateOrConnectWithoutProjectInput | ProjectCommentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectCommentUpsertWithWhereUniqueWithoutProjectInput | ProjectCommentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectCommentCreateManyProjectInputEnvelope
    set?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    disconnect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    delete?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    connect?: ProjectCommentWhereUniqueInput | ProjectCommentWhereUniqueInput[]
    update?: ProjectCommentUpdateWithWhereUniqueWithoutProjectInput | ProjectCommentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectCommentUpdateManyWithWhereWithoutProjectInput | ProjectCommentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSecondary_responsible_managersInput = {
    create?: XOR<ProjectCreateWithoutSecondary_responsible_managersInput, ProjectUncheckedCreateWithoutSecondary_responsible_managersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSecondary_responsible_managersInput
    connect?: ProjectWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutProjects_as_secondaryInput = {
    create?: XOR<ManagerCreateWithoutProjects_as_secondaryInput, ManagerUncheckedCreateWithoutProjects_as_secondaryInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjects_as_secondaryInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSecondary_responsible_managersNestedInput = {
    create?: XOR<ProjectCreateWithoutSecondary_responsible_managersInput, ProjectUncheckedCreateWithoutSecondary_responsible_managersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSecondary_responsible_managersInput
    upsert?: ProjectUpsertWithoutSecondary_responsible_managersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSecondary_responsible_managersInput, ProjectUpdateWithoutSecondary_responsible_managersInput>, ProjectUncheckedUpdateWithoutSecondary_responsible_managersInput>
  }

  export type ManagerUpdateOneRequiredWithoutProjects_as_secondaryNestedInput = {
    create?: XOR<ManagerCreateWithoutProjects_as_secondaryInput, ManagerUncheckedCreateWithoutProjects_as_secondaryInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProjects_as_secondaryInput
    upsert?: ManagerUpsertWithoutProjects_as_secondaryInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutProjects_as_secondaryInput, ManagerUpdateWithoutProjects_as_secondaryInput>, ManagerUncheckedUpdateWithoutProjects_as_secondaryInput>
  }

  export type ProjectCreateNestedOneWithoutSubprojectsInput = {
    create?: XOR<ProjectCreateWithoutSubprojectsInput, ProjectUncheckedCreateWithoutSubprojectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubprojectsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput> | TaskCreateWithoutSubprojectInput[] | TaskUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSubprojectInput | TaskCreateOrConnectWithoutSubprojectInput[]
    createMany?: TaskCreateManySubprojectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubProjectCommentCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput> | SubProjectCommentCreateWithoutSubprojectInput[] | SubProjectCommentUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutSubprojectInput | SubProjectCommentCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectCommentCreateManySubprojectInputEnvelope
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
  }

  export type SubProjectProductCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput> | SubProjectProductCreateWithoutSubprojectInput[] | SubProjectProductUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutSubprojectInput | SubProjectProductCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectProductCreateManySubprojectInputEnvelope
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
  }

  export type SubProjectServiceCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput> | SubProjectServiceCreateWithoutSubprojectInput[] | SubProjectServiceUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutSubprojectInput | SubProjectServiceCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectServiceCreateManySubprojectInputEnvelope
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput> | TaskCreateWithoutSubprojectInput[] | TaskUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSubprojectInput | TaskCreateOrConnectWithoutSubprojectInput[]
    createMany?: TaskCreateManySubprojectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput> | SubProjectCommentCreateWithoutSubprojectInput[] | SubProjectCommentUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutSubprojectInput | SubProjectCommentCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectCommentCreateManySubprojectInputEnvelope
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
  }

  export type SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput> | SubProjectProductCreateWithoutSubprojectInput[] | SubProjectProductUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutSubprojectInput | SubProjectProductCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectProductCreateManySubprojectInputEnvelope
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
  }

  export type SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput = {
    create?: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput> | SubProjectServiceCreateWithoutSubprojectInput[] | SubProjectServiceUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutSubprojectInput | SubProjectServiceCreateOrConnectWithoutSubprojectInput[]
    createMany?: SubProjectServiceCreateManySubprojectInputEnvelope
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSubprojectsNestedInput = {
    create?: XOR<ProjectCreateWithoutSubprojectsInput, ProjectUncheckedCreateWithoutSubprojectsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubprojectsInput
    upsert?: ProjectUpsertWithoutSubprojectsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSubprojectsInput, ProjectUpdateWithoutSubprojectsInput>, ProjectUncheckedUpdateWithoutSubprojectsInput>
  }

  export type TaskUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput> | TaskCreateWithoutSubprojectInput[] | TaskUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSubprojectInput | TaskCreateOrConnectWithoutSubprojectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSubprojectInput | TaskUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: TaskCreateManySubprojectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSubprojectInput | TaskUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSubprojectInput | TaskUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubProjectCommentUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput> | SubProjectCommentCreateWithoutSubprojectInput[] | SubProjectCommentUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutSubprojectInput | SubProjectCommentCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectCommentUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectCommentUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectCommentCreateManySubprojectInputEnvelope
    set?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    disconnect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    delete?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    update?: SubProjectCommentUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectCommentUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectCommentUpdateManyWithWhereWithoutSubprojectInput | SubProjectCommentUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
  }

  export type SubProjectProductUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput> | SubProjectProductCreateWithoutSubprojectInput[] | SubProjectProductUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutSubprojectInput | SubProjectProductCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectProductUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectProductUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectProductCreateManySubprojectInputEnvelope
    set?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    disconnect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    delete?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    update?: SubProjectProductUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectProductUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectProductUpdateManyWithWhereWithoutSubprojectInput | SubProjectProductUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
  }

  export type SubProjectServiceUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput> | SubProjectServiceCreateWithoutSubprojectInput[] | SubProjectServiceUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutSubprojectInput | SubProjectServiceCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectServiceUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectServiceUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectServiceCreateManySubprojectInputEnvelope
    set?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    disconnect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    delete?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    update?: SubProjectServiceUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectServiceUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectServiceUpdateManyWithWhereWithoutSubprojectInput | SubProjectServiceUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput> | TaskCreateWithoutSubprojectInput[] | TaskUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSubprojectInput | TaskCreateOrConnectWithoutSubprojectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSubprojectInput | TaskUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: TaskCreateManySubprojectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSubprojectInput | TaskUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSubprojectInput | TaskUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput> | SubProjectCommentCreateWithoutSubprojectInput[] | SubProjectCommentUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectCommentCreateOrConnectWithoutSubprojectInput | SubProjectCommentCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectCommentUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectCommentUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectCommentCreateManySubprojectInputEnvelope
    set?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    disconnect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    delete?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    connect?: SubProjectCommentWhereUniqueInput | SubProjectCommentWhereUniqueInput[]
    update?: SubProjectCommentUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectCommentUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectCommentUpdateManyWithWhereWithoutSubprojectInput | SubProjectCommentUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
  }

  export type SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput> | SubProjectProductCreateWithoutSubprojectInput[] | SubProjectProductUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectProductCreateOrConnectWithoutSubprojectInput | SubProjectProductCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectProductUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectProductUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectProductCreateManySubprojectInputEnvelope
    set?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    disconnect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    delete?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    connect?: SubProjectProductWhereUniqueInput | SubProjectProductWhereUniqueInput[]
    update?: SubProjectProductUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectProductUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectProductUpdateManyWithWhereWithoutSubprojectInput | SubProjectProductUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
  }

  export type SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput = {
    create?: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput> | SubProjectServiceCreateWithoutSubprojectInput[] | SubProjectServiceUncheckedCreateWithoutSubprojectInput[]
    connectOrCreate?: SubProjectServiceCreateOrConnectWithoutSubprojectInput | SubProjectServiceCreateOrConnectWithoutSubprojectInput[]
    upsert?: SubProjectServiceUpsertWithWhereUniqueWithoutSubprojectInput | SubProjectServiceUpsertWithWhereUniqueWithoutSubprojectInput[]
    createMany?: SubProjectServiceCreateManySubprojectInputEnvelope
    set?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    disconnect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    delete?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    connect?: SubProjectServiceWhereUniqueInput | SubProjectServiceWhereUniqueInput[]
    update?: SubProjectServiceUpdateWithWhereUniqueWithoutSubprojectInput | SubProjectServiceUpdateWithWhereUniqueWithoutSubprojectInput[]
    updateMany?: SubProjectServiceUpdateManyWithWhereWithoutSubprojectInput | SubProjectServiceUpdateManyWithWhereWithoutSubprojectInput[]
    deleteMany?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
  }

  export type ManagerCreateNestedOneWithoutTasks_as_responsibleInput = {
    create?: XOR<ManagerCreateWithoutTasks_as_responsibleInput, ManagerUncheckedCreateWithoutTasks_as_responsibleInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutTasks_as_responsibleInput
    connect?: ManagerWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutTasks_as_creatorInput = {
    create?: XOR<ManagerCreateWithoutTasks_as_creatorInput, ManagerUncheckedCreateWithoutTasks_as_creatorInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutTasks_as_creatorInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type SubProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<SubProjectCreateWithoutTasksInput, SubProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutTasksInput
    connect?: SubProjectWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type ManagerUpdateOneWithoutTasks_as_responsibleNestedInput = {
    create?: XOR<ManagerCreateWithoutTasks_as_responsibleInput, ManagerUncheckedCreateWithoutTasks_as_responsibleInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutTasks_as_responsibleInput
    upsert?: ManagerUpsertWithoutTasks_as_responsibleInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutTasks_as_responsibleInput, ManagerUpdateWithoutTasks_as_responsibleInput>, ManagerUncheckedUpdateWithoutTasks_as_responsibleInput>
  }

  export type ManagerUpdateOneWithoutTasks_as_creatorNestedInput = {
    create?: XOR<ManagerCreateWithoutTasks_as_creatorInput, ManagerUncheckedCreateWithoutTasks_as_creatorInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutTasks_as_creatorInput
    upsert?: ManagerUpsertWithoutTasks_as_creatorInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutTasks_as_creatorInput, ManagerUpdateWithoutTasks_as_creatorInput>, ManagerUncheckedUpdateWithoutTasks_as_creatorInput>
  }

  export type ProjectUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type SubProjectUpdateOneWithoutTasksNestedInput = {
    create?: XOR<SubProjectCreateWithoutTasksInput, SubProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutTasksInput
    upsert?: SubProjectUpsertWithoutTasksInput
    disconnect?: SubProjectWhereInput | boolean
    delete?: SubProjectWhereInput | boolean
    connect?: SubProjectWhereUniqueInput
    update?: XOR<XOR<SubProjectUpdateToOneWithWhereWithoutTasksInput, SubProjectUpdateWithoutTasksInput>, SubProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProjectCreateWithoutProductsInput, ProjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProductsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutProject_productsInput = {
    create?: XOR<ProductCreateWithoutProject_productsInput, ProductUncheckedCreateWithoutProject_productsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProject_productsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProjectCreateWithoutProductsInput, ProjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProductsInput
    upsert?: ProjectUpsertWithoutProductsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProductsInput, ProjectUpdateWithoutProductsInput>, ProjectUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutProject_productsNestedInput = {
    create?: XOR<ProductCreateWithoutProject_productsInput, ProductUncheckedCreateWithoutProject_productsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProject_productsInput
    upsert?: ProductUpsertWithoutProject_productsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProject_productsInput, ProductUpdateWithoutProject_productsInput>, ProductUncheckedUpdateWithoutProject_productsInput>
  }

  export type ProjectCreateNestedOneWithoutServicesInput = {
    create?: XOR<ProjectCreateWithoutServicesInput, ProjectUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutServicesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutProject_servicesInput = {
    create?: XOR<ServiceCreateWithoutProject_servicesInput, ServiceUncheckedCreateWithoutProject_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProject_servicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ProjectCreateWithoutServicesInput, ProjectUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutServicesInput
    upsert?: ProjectUpsertWithoutServicesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutServicesInput, ProjectUpdateWithoutServicesInput>, ProjectUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutProject_servicesNestedInput = {
    create?: XOR<ServiceCreateWithoutProject_servicesInput, ServiceUncheckedCreateWithoutProject_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProject_servicesInput
    upsert?: ServiceUpsertWithoutProject_servicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutProject_servicesInput, ServiceUpdateWithoutProject_servicesInput>, ServiceUncheckedUpdateWithoutProject_servicesInput>
  }

  export type SubProjectCreateNestedOneWithoutProductsInput = {
    create?: XOR<SubProjectCreateWithoutProductsInput, SubProjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutProductsInput
    connect?: SubProjectWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSubproject_productsInput = {
    create?: XOR<ProductCreateWithoutSubproject_productsInput, ProductUncheckedCreateWithoutSubproject_productsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSubproject_productsInput
    connect?: ProductWhereUniqueInput
  }

  export type SubProjectUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SubProjectCreateWithoutProductsInput, SubProjectUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutProductsInput
    upsert?: SubProjectUpsertWithoutProductsInput
    connect?: SubProjectWhereUniqueInput
    update?: XOR<XOR<SubProjectUpdateToOneWithWhereWithoutProductsInput, SubProjectUpdateWithoutProductsInput>, SubProjectUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSubproject_productsNestedInput = {
    create?: XOR<ProductCreateWithoutSubproject_productsInput, ProductUncheckedCreateWithoutSubproject_productsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSubproject_productsInput
    upsert?: ProductUpsertWithoutSubproject_productsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSubproject_productsInput, ProductUpdateWithoutSubproject_productsInput>, ProductUncheckedUpdateWithoutSubproject_productsInput>
  }

  export type SubProjectCreateNestedOneWithoutServicesInput = {
    create?: XOR<SubProjectCreateWithoutServicesInput, SubProjectUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutServicesInput
    connect?: SubProjectWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutSubproject_servicesInput = {
    create?: XOR<ServiceCreateWithoutSubproject_servicesInput, ServiceUncheckedCreateWithoutSubproject_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSubproject_servicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type SubProjectUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SubProjectCreateWithoutServicesInput, SubProjectUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutServicesInput
    upsert?: SubProjectUpsertWithoutServicesInput
    connect?: SubProjectWhereUniqueInput
    update?: XOR<XOR<SubProjectUpdateToOneWithWhereWithoutServicesInput, SubProjectUpdateWithoutServicesInput>, SubProjectUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutSubproject_servicesNestedInput = {
    create?: XOR<ServiceCreateWithoutSubproject_servicesInput, ServiceUncheckedCreateWithoutSubproject_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutSubproject_servicesInput
    upsert?: ServiceUpsertWithoutSubproject_servicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutSubproject_servicesInput, ServiceUpdateWithoutSubproject_servicesInput>, ServiceUncheckedUpdateWithoutSubproject_servicesInput>
  }

  export type ProjectCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutProject_commentsInput = {
    create?: XOR<ManagerCreateWithoutProject_commentsInput, ManagerUncheckedCreateWithoutProject_commentsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProject_commentsInput
    connect?: ManagerWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutCommentsInput
    upsert?: ProjectUpsertWithoutCommentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutCommentsInput, ProjectUpdateWithoutCommentsInput>, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ManagerUpdateOneRequiredWithoutProject_commentsNestedInput = {
    create?: XOR<ManagerCreateWithoutProject_commentsInput, ManagerUncheckedCreateWithoutProject_commentsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutProject_commentsInput
    upsert?: ManagerUpsertWithoutProject_commentsInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutProject_commentsInput, ManagerUpdateWithoutProject_commentsInput>, ManagerUncheckedUpdateWithoutProject_commentsInput>
  }

  export type SubProjectCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SubProjectCreateWithoutCommentsInput, SubProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutCommentsInput
    connect?: SubProjectWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutSubproject_commentsInput = {
    create?: XOR<ManagerCreateWithoutSubproject_commentsInput, ManagerUncheckedCreateWithoutSubproject_commentsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutSubproject_commentsInput
    connect?: ManagerWhereUniqueInput
  }

  export type SubProjectUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<SubProjectCreateWithoutCommentsInput, SubProjectUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SubProjectCreateOrConnectWithoutCommentsInput
    upsert?: SubProjectUpsertWithoutCommentsInput
    connect?: SubProjectWhereUniqueInput
    update?: XOR<XOR<SubProjectUpdateToOneWithWhereWithoutCommentsInput, SubProjectUpdateWithoutCommentsInput>, SubProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ManagerUpdateOneRequiredWithoutSubproject_commentsNestedInput = {
    create?: XOR<ManagerCreateWithoutSubproject_commentsInput, ManagerUncheckedCreateWithoutSubproject_commentsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutSubproject_commentsInput
    upsert?: ManagerUpsertWithoutSubproject_commentsInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutSubproject_commentsInput, ManagerUpdateWithoutSubproject_commentsInput>, ManagerUncheckedUpdateWithoutSubproject_commentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumManagerRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagerRole | EnumManagerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumManagerRoleFilter<$PrismaModel> | $Enums.ManagerRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumManagerRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManagerRole | EnumManagerRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ManagerRole[] | ListEnumManagerRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumManagerRoleWithAggregatesFilter<$PrismaModel> | $Enums.ManagerRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManagerRoleFilter<$PrismaModel>
    _max?: NestedEnumManagerRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCounterpartyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CounterpartyType | EnumCounterpartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCounterpartyTypeFilter<$PrismaModel> | $Enums.CounterpartyType
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCounterpartyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CounterpartyType | EnumCounterpartyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CounterpartyType[] | ListEnumCounterpartyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCounterpartyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CounterpartyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCounterpartyTypeFilter<$PrismaModel>
    _max?: NestedEnumCounterpartyTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type ManagerCreateWithoutSubordinatesInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutSubordinatesInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutSubordinatesInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput>
  }

  export type ManagerCreateWithoutSupervisorsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutSupervisorsInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutSupervisorsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput>
  }

  export type CounterpartyCreateWithoutResponsible_managerInput = {
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleCreateNestedManyWithoutCounterpartyInput
    projects?: ProjectCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyUncheckedCreateWithoutResponsible_managerInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCounterpartyInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyCreateOrConnectWithoutResponsible_managerInput = {
    where: CounterpartyWhereUniqueInput
    create: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput>
  }

  export type CounterpartyCreateManyResponsible_managerInputEnvelope = {
    data: CounterpartyCreateManyResponsible_managerInput | CounterpartyCreateManyResponsible_managerInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutResponsible_managerInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutResponsible_managerInput = {
    sale_id?: number
    counterparty_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutResponsible_managerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput>
  }

  export type SaleCreateManyResponsible_managerInputEnvelope = {
    data: SaleCreateManyResponsible_managerInput | SaleCreateManyResponsible_managerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutMain_responsible_managerInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMain_responsible_managerInput = {
    project_id?: number
    name: string
    description?: string | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMain_responsible_managerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput>
  }

  export type ProjectCreateManyMain_responsible_managerInputEnvelope = {
    data: ProjectCreateManyMain_responsible_managerInput | ProjectCreateManyMain_responsible_managerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectManagerCreateWithoutManagerInput = {
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutSecondary_responsible_managersInput
  }

  export type ProjectManagerUncheckedCreateWithoutManagerInput = {
    project_id: number
    created_at?: Date | string
  }

  export type ProjectManagerCreateOrConnectWithoutManagerInput = {
    where: ProjectManagerWhereUniqueInput
    create: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput>
  }

  export type ProjectManagerCreateManyManagerInputEnvelope = {
    data: ProjectManagerCreateManyManagerInput | ProjectManagerCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutResponsible_managerInput = {
    title: string
    description?: string | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
    creator_manager?: ManagerCreateNestedOneWithoutTasks_as_creatorInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    subproject?: SubProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutResponsible_managerInput = {
    task_id?: number
    title: string
    description?: string | null
    creator_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateOrConnectWithoutResponsible_managerInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput>
  }

  export type TaskCreateManyResponsible_managerInputEnvelope = {
    data: TaskCreateManyResponsible_managerInput | TaskCreateManyResponsible_managerInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutCreator_managerInput = {
    title: string
    description?: string | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutTasks_as_responsibleInput
    project?: ProjectCreateNestedOneWithoutTasksInput
    subproject?: SubProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutCreator_managerInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateOrConnectWithoutCreator_managerInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput>
  }

  export type TaskCreateManyCreator_managerInputEnvelope = {
    data: TaskCreateManyCreator_managerInput | TaskCreateManyCreator_managerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCommentCreateWithoutManagerInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutCommentsInput
  }

  export type ProjectCommentUncheckedCreateWithoutManagerInput = {
    comment_id?: number
    project_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ProjectCommentCreateOrConnectWithoutManagerInput = {
    where: ProjectCommentWhereUniqueInput
    create: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCommentCreateManyManagerInputEnvelope = {
    data: ProjectCommentCreateManyManagerInput | ProjectCommentCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectCommentCreateWithoutManagerInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutCommentsInput
  }

  export type SubProjectCommentUncheckedCreateWithoutManagerInput = {
    comment_id?: number
    subproject_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectCommentCreateOrConnectWithoutManagerInput = {
    where: SubProjectCommentWhereUniqueInput
    create: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput>
  }

  export type SubProjectCommentCreateManyManagerInputEnvelope = {
    data: SubProjectCommentCreateManyManagerInput | SubProjectCommentCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ManagerUpsertWithWhereUniqueWithoutSubordinatesInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUpdateWithoutSubordinatesInput, ManagerUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<ManagerCreateWithoutSubordinatesInput, ManagerUncheckedCreateWithoutSubordinatesInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutSubordinatesInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUpdateWithoutSubordinatesInput, ManagerUncheckedUpdateWithoutSubordinatesInput>
  }

  export type ManagerUpdateManyWithWhereWithoutSubordinatesInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyWithoutSubordinatesInput>
  }

  export type ManagerScalarWhereInput = {
    AND?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
    OR?: ManagerScalarWhereInput[]
    NOT?: ManagerScalarWhereInput | ManagerScalarWhereInput[]
    manager_id?: IntFilter<"Manager"> | number
    first_name?: StringFilter<"Manager"> | string
    last_name?: StringFilter<"Manager"> | string
    email?: StringFilter<"Manager"> | string
    phone_number?: StringFilter<"Manager"> | string
    role?: EnumManagerRoleFilter<"Manager"> | $Enums.ManagerRole
    password_hash?: StringFilter<"Manager"> | string
    created_at?: DateTimeFilter<"Manager"> | Date | string
    updated_at?: DateTimeFilter<"Manager"> | Date | string
  }

  export type ManagerUpsertWithWhereUniqueWithoutSupervisorsInput = {
    where: ManagerWhereUniqueInput
    update: XOR<ManagerUpdateWithoutSupervisorsInput, ManagerUncheckedUpdateWithoutSupervisorsInput>
    create: XOR<ManagerCreateWithoutSupervisorsInput, ManagerUncheckedCreateWithoutSupervisorsInput>
  }

  export type ManagerUpdateWithWhereUniqueWithoutSupervisorsInput = {
    where: ManagerWhereUniqueInput
    data: XOR<ManagerUpdateWithoutSupervisorsInput, ManagerUncheckedUpdateWithoutSupervisorsInput>
  }

  export type ManagerUpdateManyWithWhereWithoutSupervisorsInput = {
    where: ManagerScalarWhereInput
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyWithoutSupervisorsInput>
  }

  export type CounterpartyUpsertWithWhereUniqueWithoutResponsible_managerInput = {
    where: CounterpartyWhereUniqueInput
    update: XOR<CounterpartyUpdateWithoutResponsible_managerInput, CounterpartyUncheckedUpdateWithoutResponsible_managerInput>
    create: XOR<CounterpartyCreateWithoutResponsible_managerInput, CounterpartyUncheckedCreateWithoutResponsible_managerInput>
  }

  export type CounterpartyUpdateWithWhereUniqueWithoutResponsible_managerInput = {
    where: CounterpartyWhereUniqueInput
    data: XOR<CounterpartyUpdateWithoutResponsible_managerInput, CounterpartyUncheckedUpdateWithoutResponsible_managerInput>
  }

  export type CounterpartyUpdateManyWithWhereWithoutResponsible_managerInput = {
    where: CounterpartyScalarWhereInput
    data: XOR<CounterpartyUpdateManyMutationInput, CounterpartyUncheckedUpdateManyWithoutResponsible_managerInput>
  }

  export type CounterpartyScalarWhereInput = {
    AND?: CounterpartyScalarWhereInput | CounterpartyScalarWhereInput[]
    OR?: CounterpartyScalarWhereInput[]
    NOT?: CounterpartyScalarWhereInput | CounterpartyScalarWhereInput[]
    counterparty_id?: IntFilter<"Counterparty"> | number
    name?: StringFilter<"Counterparty"> | string
    counterparty_type?: EnumCounterpartyTypeFilter<"Counterparty"> | $Enums.CounterpartyType
    responsible_manager_id?: IntNullableFilter<"Counterparty"> | number | null
    created_at?: DateTimeFilter<"Counterparty"> | Date | string
    updated_at?: DateTimeFilter<"Counterparty"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutResponsible_managerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutResponsible_managerInput, SaleUncheckedUpdateWithoutResponsible_managerInput>
    create: XOR<SaleCreateWithoutResponsible_managerInput, SaleUncheckedCreateWithoutResponsible_managerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutResponsible_managerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutResponsible_managerInput, SaleUncheckedUpdateWithoutResponsible_managerInput>
  }

  export type SaleUpdateManyWithWhereWithoutResponsible_managerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutResponsible_managerInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    sale_id?: IntFilter<"Sale"> | number
    counterparty_id?: IntFilter<"Sale"> | number
    responsible_manager_id?: IntFilter<"Sale"> | number
    sale_date?: DateTimeFilter<"Sale"> | Date | string
    status?: StringFilter<"Sale"> | string
    deferred_payment_date?: DateTimeNullableFilter<"Sale"> | Date | string | null
    project_id?: IntNullableFilter<"Sale"> | number | null
    created_at?: DateTimeFilter<"Sale"> | Date | string
    updated_at?: DateTimeFilter<"Sale"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutMain_responsible_managerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutMain_responsible_managerInput, ProjectUncheckedUpdateWithoutMain_responsible_managerInput>
    create: XOR<ProjectCreateWithoutMain_responsible_managerInput, ProjectUncheckedCreateWithoutMain_responsible_managerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutMain_responsible_managerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutMain_responsible_managerInput, ProjectUncheckedUpdateWithoutMain_responsible_managerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutMain_responsible_managerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutMain_responsible_managerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    project_id?: IntFilter<"Project"> | number
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    main_responsible_manager_id?: IntNullableFilter<"Project"> | number | null
    counterparty_id?: IntNullableFilter<"Project"> | number | null
    funnel_id?: IntNullableFilter<"Project"> | number | null
    funnel_stage_id?: IntNullableFilter<"Project"> | number | null
    forecast_amount?: DecimalFilter<"Project"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectManagerUpsertWithWhereUniqueWithoutManagerInput = {
    where: ProjectManagerWhereUniqueInput
    update: XOR<ProjectManagerUpdateWithoutManagerInput, ProjectManagerUncheckedUpdateWithoutManagerInput>
    create: XOR<ProjectManagerCreateWithoutManagerInput, ProjectManagerUncheckedCreateWithoutManagerInput>
  }

  export type ProjectManagerUpdateWithWhereUniqueWithoutManagerInput = {
    where: ProjectManagerWhereUniqueInput
    data: XOR<ProjectManagerUpdateWithoutManagerInput, ProjectManagerUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectManagerUpdateManyWithWhereWithoutManagerInput = {
    where: ProjectManagerScalarWhereInput
    data: XOR<ProjectManagerUpdateManyMutationInput, ProjectManagerUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectManagerScalarWhereInput = {
    AND?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
    OR?: ProjectManagerScalarWhereInput[]
    NOT?: ProjectManagerScalarWhereInput | ProjectManagerScalarWhereInput[]
    project_id?: IntFilter<"ProjectManager"> | number
    manager_id?: IntFilter<"ProjectManager"> | number
    created_at?: DateTimeFilter<"ProjectManager"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutResponsible_managerInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutResponsible_managerInput, TaskUncheckedUpdateWithoutResponsible_managerInput>
    create: XOR<TaskCreateWithoutResponsible_managerInput, TaskUncheckedCreateWithoutResponsible_managerInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutResponsible_managerInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutResponsible_managerInput, TaskUncheckedUpdateWithoutResponsible_managerInput>
  }

  export type TaskUpdateManyWithWhereWithoutResponsible_managerInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutResponsible_managerInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    task_id?: IntFilter<"Task"> | number
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    responsible_manager_id?: IntNullableFilter<"Task"> | number | null
    creator_manager_id?: IntNullableFilter<"Task"> | number | null
    project_id?: IntNullableFilter<"Task"> | number | null
    subproject_id?: IntNullableFilter<"Task"> | number | null
    due_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    created_at?: DateTimeFilter<"Task"> | Date | string
    updated_at?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutCreator_managerInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutCreator_managerInput, TaskUncheckedUpdateWithoutCreator_managerInput>
    create: XOR<TaskCreateWithoutCreator_managerInput, TaskUncheckedCreateWithoutCreator_managerInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutCreator_managerInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutCreator_managerInput, TaskUncheckedUpdateWithoutCreator_managerInput>
  }

  export type TaskUpdateManyWithWhereWithoutCreator_managerInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutCreator_managerInput>
  }

  export type ProjectCommentUpsertWithWhereUniqueWithoutManagerInput = {
    where: ProjectCommentWhereUniqueInput
    update: XOR<ProjectCommentUpdateWithoutManagerInput, ProjectCommentUncheckedUpdateWithoutManagerInput>
    create: XOR<ProjectCommentCreateWithoutManagerInput, ProjectCommentUncheckedCreateWithoutManagerInput>
  }

  export type ProjectCommentUpdateWithWhereUniqueWithoutManagerInput = {
    where: ProjectCommentWhereUniqueInput
    data: XOR<ProjectCommentUpdateWithoutManagerInput, ProjectCommentUncheckedUpdateWithoutManagerInput>
  }

  export type ProjectCommentUpdateManyWithWhereWithoutManagerInput = {
    where: ProjectCommentScalarWhereInput
    data: XOR<ProjectCommentUpdateManyMutationInput, ProjectCommentUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectCommentScalarWhereInput = {
    AND?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
    OR?: ProjectCommentScalarWhereInput[]
    NOT?: ProjectCommentScalarWhereInput | ProjectCommentScalarWhereInput[]
    comment_id?: IntFilter<"ProjectComment"> | number
    project_id?: IntFilter<"ProjectComment"> | number
    manager_id?: IntFilter<"ProjectComment"> | number
    content?: StringFilter<"ProjectComment"> | string
    file_name?: StringNullableFilter<"ProjectComment"> | string | null
    file_type?: StringNullableFilter<"ProjectComment"> | string | null
    file_url?: StringNullableFilter<"ProjectComment"> | string | null
    created_at?: DateTimeFilter<"ProjectComment"> | Date | string
  }

  export type SubProjectCommentUpsertWithWhereUniqueWithoutManagerInput = {
    where: SubProjectCommentWhereUniqueInput
    update: XOR<SubProjectCommentUpdateWithoutManagerInput, SubProjectCommentUncheckedUpdateWithoutManagerInput>
    create: XOR<SubProjectCommentCreateWithoutManagerInput, SubProjectCommentUncheckedCreateWithoutManagerInput>
  }

  export type SubProjectCommentUpdateWithWhereUniqueWithoutManagerInput = {
    where: SubProjectCommentWhereUniqueInput
    data: XOR<SubProjectCommentUpdateWithoutManagerInput, SubProjectCommentUncheckedUpdateWithoutManagerInput>
  }

  export type SubProjectCommentUpdateManyWithWhereWithoutManagerInput = {
    where: SubProjectCommentScalarWhereInput
    data: XOR<SubProjectCommentUpdateManyMutationInput, SubProjectCommentUncheckedUpdateManyWithoutManagerInput>
  }

  export type SubProjectCommentScalarWhereInput = {
    AND?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
    OR?: SubProjectCommentScalarWhereInput[]
    NOT?: SubProjectCommentScalarWhereInput | SubProjectCommentScalarWhereInput[]
    comment_id?: IntFilter<"SubProjectComment"> | number
    subproject_id?: IntFilter<"SubProjectComment"> | number
    manager_id?: IntFilter<"SubProjectComment"> | number
    content?: StringFilter<"SubProjectComment"> | string
    file_name?: StringNullableFilter<"SubProjectComment"> | string | null
    file_type?: StringNullableFilter<"SubProjectComment"> | string | null
    file_url?: StringNullableFilter<"SubProjectComment"> | string | null
    created_at?: DateTimeFilter<"SubProjectComment"> | Date | string
  }

  export type ManagerCreateWithoutCounterpartiesInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutCounterpartiesInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutCounterpartiesInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutCounterpartiesInput, ManagerUncheckedCreateWithoutCounterpartiesInput>
  }

  export type SaleCreateWithoutCounterpartyInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutCounterpartyInput = {
    sale_id?: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCounterpartyInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput>
  }

  export type SaleCreateManyCounterpartyInputEnvelope = {
    data: SaleCreateManyCounterpartyInput | SaleCreateManyCounterpartyInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCounterpartyInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCounterpartyInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCounterpartyInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput>
  }

  export type ProjectCreateManyCounterpartyInputEnvelope = {
    data: ProjectCreateManyCounterpartyInput | ProjectCreateManyCounterpartyInput[]
    skipDuplicates?: boolean
  }

  export type ManagerUpsertWithoutCounterpartiesInput = {
    update: XOR<ManagerUpdateWithoutCounterpartiesInput, ManagerUncheckedUpdateWithoutCounterpartiesInput>
    create: XOR<ManagerCreateWithoutCounterpartiesInput, ManagerUncheckedCreateWithoutCounterpartiesInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutCounterpartiesInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutCounterpartiesInput, ManagerUncheckedUpdateWithoutCounterpartiesInput>
  }

  export type ManagerUpdateWithoutCounterpartiesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutCounterpartiesInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutCounterpartyInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCounterpartyInput, SaleUncheckedUpdateWithoutCounterpartyInput>
    create: XOR<SaleCreateWithoutCounterpartyInput, SaleUncheckedCreateWithoutCounterpartyInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCounterpartyInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCounterpartyInput, SaleUncheckedUpdateWithoutCounterpartyInput>
  }

  export type SaleUpdateManyWithWhereWithoutCounterpartyInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCounterpartyInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutCounterpartyInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCounterpartyInput, ProjectUncheckedUpdateWithoutCounterpartyInput>
    create: XOR<ProjectCreateWithoutCounterpartyInput, ProjectUncheckedCreateWithoutCounterpartyInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCounterpartyInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCounterpartyInput, ProjectUncheckedUpdateWithoutCounterpartyInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCounterpartyInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCounterpartyInput>
  }

  export type ProductCreateWithoutUnitInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockCreateNestedManyWithoutProductInput
    sales?: SaleProductCreateNestedManyWithoutProductInput
    project_products?: ProjectProductCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUnitInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    sales?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    project_products?: ProjectProductUncheckedCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUnitInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductCreateManyUnitInputEnvelope = {
    data: ProductCreateManyUnitInput | ProductCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
  }

  export type ProductUpdateManyWithWhereWithoutUnitInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUnitInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    product_id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    unit_id?: IntNullableFilter<"Product"> | number | null
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductStockCreateWithoutWarehouseInput = {
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    product: ProductCreateNestedOneWithoutStocksInput
  }

  export type ProductStockUncheckedCreateWithoutWarehouseInput = {
    product_stock_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductStockCreateOrConnectWithoutWarehouseInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductStockCreateManyWarehouseInputEnvelope = {
    data: ProductStockCreateManyWarehouseInput | ProductStockCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type ProductStockUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductStockWhereUniqueInput
    update: XOR<ProductStockUpdateWithoutWarehouseInput, ProductStockUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductStockCreateWithoutWarehouseInput, ProductStockUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductStockUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductStockWhereUniqueInput
    data: XOR<ProductStockUpdateWithoutWarehouseInput, ProductStockUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductStockUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductStockScalarWhereInput
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type ProductStockScalarWhereInput = {
    AND?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    OR?: ProductStockScalarWhereInput[]
    NOT?: ProductStockScalarWhereInput | ProductStockScalarWhereInput[]
    product_stock_id?: IntFilter<"ProductStock"> | number
    product_id?: IntFilter<"ProductStock"> | number
    warehouse_id?: IntFilter<"ProductStock"> | number
    quantity?: IntFilter<"ProductStock"> | number
    created_at?: DateTimeFilter<"ProductStock"> | Date | string
    updated_at?: DateTimeFilter<"ProductStock"> | Date | string
  }

  export type UnitCreateWithoutProductsInput = {
    name: string
    created_at?: Date | string
  }

  export type UnitUncheckedCreateWithoutProductsInput = {
    unit_id?: number
    name: string
    created_at?: Date | string
  }

  export type UnitCreateOrConnectWithoutProductsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
  }

  export type ProductStockCreateWithoutProductInput = {
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProduct_stocksInput
  }

  export type ProductStockUncheckedCreateWithoutProductInput = {
    product_stock_id?: number
    warehouse_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductStockCreateOrConnectWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
  }

  export type ProductStockCreateManyProductInputEnvelope = {
    data: ProductStockCreateManyProductInput | ProductStockCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleProductCreateWithoutProductInput = {
    quantity: number
    created_at?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
  }

  export type SaleProductUncheckedCreateWithoutProductInput = {
    sale_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SaleProductCreateOrConnectWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductCreateManyProductInputEnvelope = {
    data: SaleProductCreateManyProductInput | SaleProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProjectProductCreateWithoutProductInput = {
    quantity: number
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutProductsInput
  }

  export type ProjectProductUncheckedCreateWithoutProductInput = {
    project_product_id?: number
    project_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectProductCreateOrConnectWithoutProductInput = {
    where: ProjectProductWhereUniqueInput
    create: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput>
  }

  export type ProjectProductCreateManyProductInputEnvelope = {
    data: ProjectProductCreateManyProductInput | ProjectProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectProductCreateWithoutProductInput = {
    quantity: number
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutProductsInput
  }

  export type SubProjectProductUncheckedCreateWithoutProductInput = {
    subproject_product_id?: number
    subproject_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectProductCreateOrConnectWithoutProductInput = {
    where: SubProjectProductWhereUniqueInput
    create: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput>
  }

  export type SubProjectProductCreateManyProductInputEnvelope = {
    data: SubProjectProductCreateManyProductInput | SubProjectProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutProductsInput = {
    update: XOR<UnitUpdateWithoutProductsInput, UnitUncheckedUpdateWithoutProductsInput>
    create: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutProductsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutProductsInput, UnitUncheckedUpdateWithoutProductsInput>
  }

  export type UnitUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateWithoutProductsInput = {
    unit_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    update: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
    create: XOR<ProductStockCreateWithoutProductInput, ProductStockUncheckedCreateWithoutProductInput>
  }

  export type ProductStockUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductStockWhereUniqueInput
    data: XOR<ProductStockUpdateWithoutProductInput, ProductStockUncheckedUpdateWithoutProductInput>
  }

  export type ProductStockUpdateManyWithWhereWithoutProductInput = {
    where: ProductStockScalarWhereInput
    data: XOR<ProductStockUpdateManyMutationInput, ProductStockUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutProductInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleProductScalarWhereInput = {
    AND?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    OR?: SaleProductScalarWhereInput[]
    NOT?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    sale_id?: IntFilter<"SaleProduct"> | number
    product_id?: IntFilter<"SaleProduct"> | number
    quantity?: IntFilter<"SaleProduct"> | number
    created_at?: DateTimeFilter<"SaleProduct"> | Date | string
  }

  export type ProjectProductUpsertWithWhereUniqueWithoutProductInput = {
    where: ProjectProductWhereUniqueInput
    update: XOR<ProjectProductUpdateWithoutProductInput, ProjectProductUncheckedUpdateWithoutProductInput>
    create: XOR<ProjectProductCreateWithoutProductInput, ProjectProductUncheckedCreateWithoutProductInput>
  }

  export type ProjectProductUpdateWithWhereUniqueWithoutProductInput = {
    where: ProjectProductWhereUniqueInput
    data: XOR<ProjectProductUpdateWithoutProductInput, ProjectProductUncheckedUpdateWithoutProductInput>
  }

  export type ProjectProductUpdateManyWithWhereWithoutProductInput = {
    where: ProjectProductScalarWhereInput
    data: XOR<ProjectProductUpdateManyMutationInput, ProjectProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProjectProductScalarWhereInput = {
    AND?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
    OR?: ProjectProductScalarWhereInput[]
    NOT?: ProjectProductScalarWhereInput | ProjectProductScalarWhereInput[]
    project_product_id?: IntFilter<"ProjectProduct"> | number
    project_id?: IntFilter<"ProjectProduct"> | number
    product_id?: IntFilter<"ProjectProduct"> | number
    quantity?: IntFilter<"ProjectProduct"> | number
    created_at?: DateTimeFilter<"ProjectProduct"> | Date | string
  }

  export type SubProjectProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SubProjectProductWhereUniqueInput
    update: XOR<SubProjectProductUpdateWithoutProductInput, SubProjectProductUncheckedUpdateWithoutProductInput>
    create: XOR<SubProjectProductCreateWithoutProductInput, SubProjectProductUncheckedCreateWithoutProductInput>
  }

  export type SubProjectProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SubProjectProductWhereUniqueInput
    data: XOR<SubProjectProductUpdateWithoutProductInput, SubProjectProductUncheckedUpdateWithoutProductInput>
  }

  export type SubProjectProductUpdateManyWithWhereWithoutProductInput = {
    where: SubProjectProductScalarWhereInput
    data: XOR<SubProjectProductUpdateManyMutationInput, SubProjectProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SubProjectProductScalarWhereInput = {
    AND?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
    OR?: SubProjectProductScalarWhereInput[]
    NOT?: SubProjectProductScalarWhereInput | SubProjectProductScalarWhereInput[]
    subproject_product_id?: IntFilter<"SubProjectProduct"> | number
    subproject_id?: IntFilter<"SubProjectProduct"> | number
    product_id?: IntFilter<"SubProjectProduct"> | number
    quantity?: IntFilter<"SubProjectProduct"> | number
    created_at?: DateTimeFilter<"SubProjectProduct"> | Date | string
  }

  export type ProductCreateWithoutStocksInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    unit?: UnitCreateNestedOneWithoutProductsInput
    sales?: SaleProductCreateNestedManyWithoutProductInput
    project_products?: ProjectProductCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStocksInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    project_products?: ProjectProductUncheckedCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStocksInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
  }

  export type WarehouseCreateWithoutProduct_stocksInput = {
    name: string
    location: string
    created_at?: Date | string
  }

  export type WarehouseUncheckedCreateWithoutProduct_stocksInput = {
    warehouse_id?: number
    name: string
    location: string
    created_at?: Date | string
  }

  export type WarehouseCreateOrConnectWithoutProduct_stocksInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutProduct_stocksInput, WarehouseUncheckedCreateWithoutProduct_stocksInput>
  }

  export type ProductUpsertWithoutStocksInput = {
    update: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
    create: XOR<ProductCreateWithoutStocksInput, ProductUncheckedCreateWithoutStocksInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStocksInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStocksInput, ProductUncheckedUpdateWithoutStocksInput>
  }

  export type ProductUpdateWithoutStocksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutProductsNestedInput
    sales?: SaleProductUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStocksInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUncheckedUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type WarehouseUpsertWithoutProduct_stocksInput = {
    update: XOR<WarehouseUpdateWithoutProduct_stocksInput, WarehouseUncheckedUpdateWithoutProduct_stocksInput>
    create: XOR<WarehouseCreateWithoutProduct_stocksInput, WarehouseUncheckedCreateWithoutProduct_stocksInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutProduct_stocksInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutProduct_stocksInput, WarehouseUncheckedUpdateWithoutProduct_stocksInput>
  }

  export type WarehouseUpdateWithoutProduct_stocksInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateWithoutProduct_stocksInput = {
    warehouse_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceCreateWithoutServiceInput = {
    created_at?: Date | string
    sale: SaleCreateNestedOneWithoutServicesInput
  }

  export type SaleServiceUncheckedCreateWithoutServiceInput = {
    sale_id: number
    created_at?: Date | string
  }

  export type SaleServiceCreateOrConnectWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    create: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput>
  }

  export type SaleServiceCreateManyServiceInputEnvelope = {
    data: SaleServiceCreateManyServiceInput | SaleServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectServiceCreateWithoutServiceInput = {
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutServicesInput
  }

  export type ProjectServiceUncheckedCreateWithoutServiceInput = {
    project_service_id?: number
    project_id: number
    created_at?: Date | string
  }

  export type ProjectServiceCreateOrConnectWithoutServiceInput = {
    where: ProjectServiceWhereUniqueInput
    create: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput>
  }

  export type ProjectServiceCreateManyServiceInputEnvelope = {
    data: ProjectServiceCreateManyServiceInput | ProjectServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectServiceCreateWithoutServiceInput = {
    created_at?: Date | string
    subproject: SubProjectCreateNestedOneWithoutServicesInput
  }

  export type SubProjectServiceUncheckedCreateWithoutServiceInput = {
    subproject_service_id?: number
    subproject_id: number
    created_at?: Date | string
  }

  export type SubProjectServiceCreateOrConnectWithoutServiceInput = {
    where: SubProjectServiceWhereUniqueInput
    create: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput>
  }

  export type SubProjectServiceCreateManyServiceInputEnvelope = {
    data: SubProjectServiceCreateManyServiceInput | SubProjectServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type SaleServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    update: XOR<SaleServiceUpdateWithoutServiceInput, SaleServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<SaleServiceCreateWithoutServiceInput, SaleServiceUncheckedCreateWithoutServiceInput>
  }

  export type SaleServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: SaleServiceWhereUniqueInput
    data: XOR<SaleServiceUpdateWithoutServiceInput, SaleServiceUncheckedUpdateWithoutServiceInput>
  }

  export type SaleServiceUpdateManyWithWhereWithoutServiceInput = {
    where: SaleServiceScalarWhereInput
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type SaleServiceScalarWhereInput = {
    AND?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
    OR?: SaleServiceScalarWhereInput[]
    NOT?: SaleServiceScalarWhereInput | SaleServiceScalarWhereInput[]
    sale_id?: IntFilter<"SaleService"> | number
    service_id?: IntFilter<"SaleService"> | number
    created_at?: DateTimeFilter<"SaleService"> | Date | string
  }

  export type ProjectServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProjectServiceWhereUniqueInput
    update: XOR<ProjectServiceUpdateWithoutServiceInput, ProjectServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ProjectServiceCreateWithoutServiceInput, ProjectServiceUncheckedCreateWithoutServiceInput>
  }

  export type ProjectServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProjectServiceWhereUniqueInput
    data: XOR<ProjectServiceUpdateWithoutServiceInput, ProjectServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ProjectServiceUpdateManyWithWhereWithoutServiceInput = {
    where: ProjectServiceScalarWhereInput
    data: XOR<ProjectServiceUpdateManyMutationInput, ProjectServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type ProjectServiceScalarWhereInput = {
    AND?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
    OR?: ProjectServiceScalarWhereInput[]
    NOT?: ProjectServiceScalarWhereInput | ProjectServiceScalarWhereInput[]
    project_service_id?: IntFilter<"ProjectService"> | number
    project_id?: IntFilter<"ProjectService"> | number
    service_id?: IntFilter<"ProjectService"> | number
    created_at?: DateTimeFilter<"ProjectService"> | Date | string
  }

  export type SubProjectServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: SubProjectServiceWhereUniqueInput
    update: XOR<SubProjectServiceUpdateWithoutServiceInput, SubProjectServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<SubProjectServiceCreateWithoutServiceInput, SubProjectServiceUncheckedCreateWithoutServiceInput>
  }

  export type SubProjectServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: SubProjectServiceWhereUniqueInput
    data: XOR<SubProjectServiceUpdateWithoutServiceInput, SubProjectServiceUncheckedUpdateWithoutServiceInput>
  }

  export type SubProjectServiceUpdateManyWithWhereWithoutServiceInput = {
    where: SubProjectServiceScalarWhereInput
    data: XOR<SubProjectServiceUpdateManyMutationInput, SubProjectServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type SubProjectServiceScalarWhereInput = {
    AND?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
    OR?: SubProjectServiceScalarWhereInput[]
    NOT?: SubProjectServiceScalarWhereInput | SubProjectServiceScalarWhereInput[]
    subproject_service_id?: IntFilter<"SubProjectService"> | number
    subproject_id?: IntFilter<"SubProjectService"> | number
    service_id?: IntFilter<"SubProjectService"> | number
    created_at?: DateTimeFilter<"SubProjectService"> | Date | string
  }

  export type SaleCreateWithoutSale_status_typeInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutSale_status_typeInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutSale_status_typeInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput>
  }

  export type SaleCreateManySale_status_typeInputEnvelope = {
    data: SaleCreateManySale_status_typeInput | SaleCreateManySale_status_typeInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithWhereUniqueWithoutSale_status_typeInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutSale_status_typeInput, SaleUncheckedUpdateWithoutSale_status_typeInput>
    create: XOR<SaleCreateWithoutSale_status_typeInput, SaleUncheckedCreateWithoutSale_status_typeInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutSale_status_typeInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutSale_status_typeInput, SaleUncheckedUpdateWithoutSale_status_typeInput>
  }

  export type SaleUpdateManyWithWhereWithoutSale_status_typeInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutSale_status_typeInput>
  }

  export type CounterpartyCreateWithoutSalesInput = {
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutCounterpartiesInput
    projects?: ProjectCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyUncheckedCreateWithoutSalesInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    responsible_manager_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyCreateOrConnectWithoutSalesInput = {
    where: CounterpartyWhereUniqueInput
    create: XOR<CounterpartyCreateWithoutSalesInput, CounterpartyUncheckedCreateWithoutSalesInput>
  }

  export type ManagerCreateWithoutSalesInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutSalesInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutSalesInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutSalesInput, ManagerUncheckedCreateWithoutSalesInput>
  }

  export type ProjectCreateWithoutSalesInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSalesInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSalesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSalesInput, ProjectUncheckedCreateWithoutSalesInput>
  }

  export type SaleProductCreateWithoutSaleInput = {
    quantity: number
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutSalesInput
  }

  export type SaleProductUncheckedCreateWithoutSaleInput = {
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SaleProductCreateOrConnectWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductCreateManySaleInputEnvelope = {
    data: SaleProductCreateManySaleInput | SaleProductCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleServiceCreateWithoutSaleInput = {
    created_at?: Date | string
    service: ServiceCreateNestedOneWithoutSalesInput
  }

  export type SaleServiceUncheckedCreateWithoutSaleInput = {
    service_id: number
    created_at?: Date | string
  }

  export type SaleServiceCreateOrConnectWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    create: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput>
  }

  export type SaleServiceCreateManySaleInputEnvelope = {
    data: SaleServiceCreateManySaleInput | SaleServiceCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleStatusTypeCreateWithoutSalesInput = {
    name: string
    created_at?: Date | string
  }

  export type SaleStatusTypeUncheckedCreateWithoutSalesInput = {
    sale_status_id?: number
    name: string
    created_at?: Date | string
  }

  export type SaleStatusTypeCreateOrConnectWithoutSalesInput = {
    where: SaleStatusTypeWhereUniqueInput
    create: XOR<SaleStatusTypeCreateWithoutSalesInput, SaleStatusTypeUncheckedCreateWithoutSalesInput>
  }

  export type CounterpartyUpsertWithoutSalesInput = {
    update: XOR<CounterpartyUpdateWithoutSalesInput, CounterpartyUncheckedUpdateWithoutSalesInput>
    create: XOR<CounterpartyCreateWithoutSalesInput, CounterpartyUncheckedCreateWithoutSalesInput>
    where?: CounterpartyWhereInput
  }

  export type CounterpartyUpdateToOneWithWhereWithoutSalesInput = {
    where?: CounterpartyWhereInput
    data: XOR<CounterpartyUpdateWithoutSalesInput, CounterpartyUncheckedUpdateWithoutSalesInput>
  }

  export type CounterpartyUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutCounterpartiesNestedInput
    projects?: ProjectUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyUncheckedUpdateWithoutSalesInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCounterpartyNestedInput
  }

  export type ManagerUpsertWithoutSalesInput = {
    update: XOR<ManagerUpdateWithoutSalesInput, ManagerUncheckedUpdateWithoutSalesInput>
    create: XOR<ManagerCreateWithoutSalesInput, ManagerUncheckedCreateWithoutSalesInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutSalesInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutSalesInput, ManagerUncheckedUpdateWithoutSalesInput>
  }

  export type ManagerUpdateWithoutSalesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutSalesInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ProjectUpsertWithoutSalesInput = {
    update: XOR<ProjectUpdateWithoutSalesInput, ProjectUncheckedUpdateWithoutSalesInput>
    create: XOR<ProjectCreateWithoutSalesInput, ProjectUncheckedCreateWithoutSalesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSalesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSalesInput, ProjectUncheckedUpdateWithoutSalesInput>
  }

  export type ProjectUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSalesInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SaleProductUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutSaleInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleServiceUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    update: XOR<SaleServiceUpdateWithoutSaleInput, SaleServiceUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleServiceCreateWithoutSaleInput, SaleServiceUncheckedCreateWithoutSaleInput>
  }

  export type SaleServiceUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleServiceWhereUniqueInput
    data: XOR<SaleServiceUpdateWithoutSaleInput, SaleServiceUncheckedUpdateWithoutSaleInput>
  }

  export type SaleServiceUpdateManyWithWhereWithoutSaleInput = {
    where: SaleServiceScalarWhereInput
    data: XOR<SaleServiceUpdateManyMutationInput, SaleServiceUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleStatusTypeUpsertWithoutSalesInput = {
    update: XOR<SaleStatusTypeUpdateWithoutSalesInput, SaleStatusTypeUncheckedUpdateWithoutSalesInput>
    create: XOR<SaleStatusTypeCreateWithoutSalesInput, SaleStatusTypeUncheckedCreateWithoutSalesInput>
    where?: SaleStatusTypeWhereInput
  }

  export type SaleStatusTypeUpdateToOneWithWhereWithoutSalesInput = {
    where?: SaleStatusTypeWhereInput
    data: XOR<SaleStatusTypeUpdateWithoutSalesInput, SaleStatusTypeUncheckedUpdateWithoutSalesInput>
  }

  export type SaleStatusTypeUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleStatusTypeUncheckedUpdateWithoutSalesInput = {
    sale_status_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateWithoutProductsInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutProductsInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutProductsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutSalesInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    unit?: UnitCreateNestedOneWithoutProductsInput
    stocks?: ProductStockCreateNestedManyWithoutProductInput
    project_products?: ProjectProductCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSalesInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    project_products?: ProjectProductUncheckedCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSalesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
  }

  export type SaleUpsertWithoutProductsInput = {
    update: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutProductsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type SaleUpdateWithoutProductsInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutProductsInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ProductUpsertWithoutSalesInput = {
    update: XOR<ProductUpdateWithoutSalesInput, ProductUncheckedUpdateWithoutSalesInput>
    create: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSalesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSalesInput, ProductUncheckedUpdateWithoutSalesInput>
  }

  export type ProductUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutProductsNestedInput
    stocks?: ProductStockUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSalesInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUncheckedUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleCreateWithoutServicesInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    project?: ProjectCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutServicesInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutServicesInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutSalesInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project_services?: ProjectServiceCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutSalesInput = {
    service_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project_services?: ProjectServiceUncheckedCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutSalesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSalesInput, ServiceUncheckedCreateWithoutSalesInput>
  }

  export type SaleUpsertWithoutServicesInput = {
    update: XOR<SaleUpdateWithoutServicesInput, SaleUncheckedUpdateWithoutServicesInput>
    create: XOR<SaleCreateWithoutServicesInput, SaleUncheckedCreateWithoutServicesInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutServicesInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutServicesInput, SaleUncheckedUpdateWithoutServicesInput>
  }

  export type SaleUpdateWithoutServicesInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutServicesInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ServiceUpsertWithoutSalesInput = {
    update: XOR<ServiceUpdateWithoutSalesInput, ServiceUncheckedUpdateWithoutSalesInput>
    create: XOR<ServiceCreateWithoutSalesInput, ServiceUncheckedCreateWithoutSalesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutSalesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutSalesInput, ServiceUncheckedUpdateWithoutSalesInput>
  }

  export type ServiceUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project_services?: ProjectServiceUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutSalesInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project_services?: ProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type FunnelStageCreateWithoutFunnelInput = {
    name: string
    order: number
    created_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutFunnel_stageInput
  }

  export type FunnelStageUncheckedCreateWithoutFunnelInput = {
    funnel_stage_id?: number
    name: string
    order: number
    created_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutFunnel_stageInput
  }

  export type FunnelStageCreateOrConnectWithoutFunnelInput = {
    where: FunnelStageWhereUniqueInput
    create: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput>
  }

  export type FunnelStageCreateManyFunnelInputEnvelope = {
    data: FunnelStageCreateManyFunnelInput | FunnelStageCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutFunnelInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFunnelInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFunnelInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput>
  }

  export type ProjectCreateManyFunnelInputEnvelope = {
    data: ProjectCreateManyFunnelInput | ProjectCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type FunnelStageUpsertWithWhereUniqueWithoutFunnelInput = {
    where: FunnelStageWhereUniqueInput
    update: XOR<FunnelStageUpdateWithoutFunnelInput, FunnelStageUncheckedUpdateWithoutFunnelInput>
    create: XOR<FunnelStageCreateWithoutFunnelInput, FunnelStageUncheckedCreateWithoutFunnelInput>
  }

  export type FunnelStageUpdateWithWhereUniqueWithoutFunnelInput = {
    where: FunnelStageWhereUniqueInput
    data: XOR<FunnelStageUpdateWithoutFunnelInput, FunnelStageUncheckedUpdateWithoutFunnelInput>
  }

  export type FunnelStageUpdateManyWithWhereWithoutFunnelInput = {
    where: FunnelStageScalarWhereInput
    data: XOR<FunnelStageUpdateManyMutationInput, FunnelStageUncheckedUpdateManyWithoutFunnelInput>
  }

  export type FunnelStageScalarWhereInput = {
    AND?: FunnelStageScalarWhereInput | FunnelStageScalarWhereInput[]
    OR?: FunnelStageScalarWhereInput[]
    NOT?: FunnelStageScalarWhereInput | FunnelStageScalarWhereInput[]
    funnel_stage_id?: IntFilter<"FunnelStage"> | number
    name?: StringFilter<"FunnelStage"> | string
    funnel_id?: IntFilter<"FunnelStage"> | number
    order?: IntFilter<"FunnelStage"> | number
    created_at?: DateTimeFilter<"FunnelStage"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutFunnelInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutFunnelInput, ProjectUncheckedUpdateWithoutFunnelInput>
    create: XOR<ProjectCreateWithoutFunnelInput, ProjectUncheckedCreateWithoutFunnelInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutFunnelInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutFunnelInput, ProjectUncheckedUpdateWithoutFunnelInput>
  }

  export type ProjectUpdateManyWithWhereWithoutFunnelInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutFunnelInput>
  }

  export type FunnelCreateWithoutStagesInput = {
    name: string
    created_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateWithoutStagesInput = {
    funnel_id?: number
    name: string
    created_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelCreateOrConnectWithoutStagesInput = {
    where: FunnelWhereUniqueInput
    create: XOR<FunnelCreateWithoutStagesInput, FunnelUncheckedCreateWithoutStagesInput>
  }

  export type ProjectCreateWithoutFunnel_stageInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFunnel_stageInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFunnel_stageInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput>
  }

  export type ProjectCreateManyFunnel_stageInputEnvelope = {
    data: ProjectCreateManyFunnel_stageInput | ProjectCreateManyFunnel_stageInput[]
    skipDuplicates?: boolean
  }

  export type FunnelUpsertWithoutStagesInput = {
    update: XOR<FunnelUpdateWithoutStagesInput, FunnelUncheckedUpdateWithoutStagesInput>
    create: XOR<FunnelCreateWithoutStagesInput, FunnelUncheckedCreateWithoutStagesInput>
    where?: FunnelWhereInput
  }

  export type FunnelUpdateToOneWithWhereWithoutStagesInput = {
    where?: FunnelWhereInput
    data: XOR<FunnelUpdateWithoutStagesInput, FunnelUncheckedUpdateWithoutStagesInput>
  }

  export type FunnelUpdateWithoutStagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateWithoutStagesInput = {
    funnel_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutFunnel_stageInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutFunnel_stageInput, ProjectUncheckedUpdateWithoutFunnel_stageInput>
    create: XOR<ProjectCreateWithoutFunnel_stageInput, ProjectUncheckedCreateWithoutFunnel_stageInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutFunnel_stageInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutFunnel_stageInput, ProjectUncheckedUpdateWithoutFunnel_stageInput>
  }

  export type ProjectUpdateManyWithWhereWithoutFunnel_stageInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutFunnel_stageInput>
  }

  export type ManagerCreateWithoutProjects_as_mainInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutProjects_as_mainInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutProjects_as_mainInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutProjects_as_mainInput, ManagerUncheckedCreateWithoutProjects_as_mainInput>
  }

  export type ProjectManagerCreateWithoutProjectInput = {
    created_at?: Date | string
    manager: ManagerCreateNestedOneWithoutProjects_as_secondaryInput
  }

  export type ProjectManagerUncheckedCreateWithoutProjectInput = {
    manager_id: number
    created_at?: Date | string
  }

  export type ProjectManagerCreateOrConnectWithoutProjectInput = {
    where: ProjectManagerWhereUniqueInput
    create: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput>
  }

  export type ProjectManagerCreateManyProjectInputEnvelope = {
    data: ProjectManagerCreateManyProjectInput | ProjectManagerCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CounterpartyCreateWithoutProjectsInput = {
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutCounterpartiesInput
    sales?: SaleCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyUncheckedCreateWithoutProjectsInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    responsible_manager_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCounterpartyInput
  }

  export type CounterpartyCreateOrConnectWithoutProjectsInput = {
    where: CounterpartyWhereUniqueInput
    create: XOR<CounterpartyCreateWithoutProjectsInput, CounterpartyUncheckedCreateWithoutProjectsInput>
  }

  export type FunnelCreateWithoutProjectsInput = {
    name: string
    created_at?: Date | string
    stages?: FunnelStageCreateNestedManyWithoutFunnelInput
  }

  export type FunnelUncheckedCreateWithoutProjectsInput = {
    funnel_id?: number
    name: string
    created_at?: Date | string
    stages?: FunnelStageUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelCreateOrConnectWithoutProjectsInput = {
    where: FunnelWhereUniqueInput
    create: XOR<FunnelCreateWithoutProjectsInput, FunnelUncheckedCreateWithoutProjectsInput>
  }

  export type FunnelStageCreateWithoutProjectsInput = {
    name: string
    order: number
    created_at?: Date | string
    funnel: FunnelCreateNestedOneWithoutStagesInput
  }

  export type FunnelStageUncheckedCreateWithoutProjectsInput = {
    funnel_stage_id?: number
    name: string
    funnel_id: number
    order: number
    created_at?: Date | string
  }

  export type FunnelStageCreateOrConnectWithoutProjectsInput = {
    where: FunnelStageWhereUniqueInput
    create: XOR<FunnelStageCreateWithoutProjectsInput, FunnelStageUncheckedCreateWithoutProjectsInput>
  }

  export type SubProjectCreateWithoutProjectInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateWithoutProjectInput = {
    subproject_id?: number
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectCreateOrConnectWithoutProjectInput = {
    where: SubProjectWhereUniqueInput
    create: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput>
  }

  export type SubProjectCreateManyProjectInputEnvelope = {
    data: SubProjectCreateManyProjectInput | SubProjectCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    title: string
    description?: string | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutTasks_as_responsibleInput
    creator_manager?: ManagerCreateNestedOneWithoutTasks_as_creatorInput
    subproject?: SubProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutProjectInput = {
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    counterparty: CounterpartyCreateNestedOneWithoutSalesInput
    responsible_manager: ManagerCreateNestedOneWithoutSalesInput
    products?: SaleProductCreateNestedManyWithoutSaleInput
    services?: SaleServiceCreateNestedManyWithoutSaleInput
    sale_status_type?: SaleStatusTypeCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutProjectInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    services?: SaleServiceUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutProjectInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput>
  }

  export type SaleCreateManyProjectInputEnvelope = {
    data: SaleCreateManyProjectInput | SaleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectProductCreateWithoutProjectInput = {
    quantity: number
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutProject_productsInput
  }

  export type ProjectProductUncheckedCreateWithoutProjectInput = {
    project_product_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectProductCreateOrConnectWithoutProjectInput = {
    where: ProjectProductWhereUniqueInput
    create: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput>
  }

  export type ProjectProductCreateManyProjectInputEnvelope = {
    data: ProjectProductCreateManyProjectInput | ProjectProductCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectServiceCreateWithoutProjectInput = {
    created_at?: Date | string
    service: ServiceCreateNestedOneWithoutProject_servicesInput
  }

  export type ProjectServiceUncheckedCreateWithoutProjectInput = {
    project_service_id?: number
    service_id: number
    created_at?: Date | string
  }

  export type ProjectServiceCreateOrConnectWithoutProjectInput = {
    where: ProjectServiceWhereUniqueInput
    create: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput>
  }

  export type ProjectServiceCreateManyProjectInputEnvelope = {
    data: ProjectServiceCreateManyProjectInput | ProjectServiceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCommentCreateWithoutProjectInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    manager: ManagerCreateNestedOneWithoutProject_commentsInput
  }

  export type ProjectCommentUncheckedCreateWithoutProjectInput = {
    comment_id?: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ProjectCommentCreateOrConnectWithoutProjectInput = {
    where: ProjectCommentWhereUniqueInput
    create: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCommentCreateManyProjectInputEnvelope = {
    data: ProjectCommentCreateManyProjectInput | ProjectCommentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ManagerUpsertWithoutProjects_as_mainInput = {
    update: XOR<ManagerUpdateWithoutProjects_as_mainInput, ManagerUncheckedUpdateWithoutProjects_as_mainInput>
    create: XOR<ManagerCreateWithoutProjects_as_mainInput, ManagerUncheckedCreateWithoutProjects_as_mainInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutProjects_as_mainInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutProjects_as_mainInput, ManagerUncheckedUpdateWithoutProjects_as_mainInput>
  }

  export type ManagerUpdateWithoutProjects_as_mainInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutProjects_as_mainInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ProjectManagerUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectManagerWhereUniqueInput
    update: XOR<ProjectManagerUpdateWithoutProjectInput, ProjectManagerUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectManagerCreateWithoutProjectInput, ProjectManagerUncheckedCreateWithoutProjectInput>
  }

  export type ProjectManagerUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectManagerWhereUniqueInput
    data: XOR<ProjectManagerUpdateWithoutProjectInput, ProjectManagerUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectManagerUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectManagerScalarWhereInput
    data: XOR<ProjectManagerUpdateManyMutationInput, ProjectManagerUncheckedUpdateManyWithoutProjectInput>
  }

  export type CounterpartyUpsertWithoutProjectsInput = {
    update: XOR<CounterpartyUpdateWithoutProjectsInput, CounterpartyUncheckedUpdateWithoutProjectsInput>
    create: XOR<CounterpartyCreateWithoutProjectsInput, CounterpartyUncheckedCreateWithoutProjectsInput>
    where?: CounterpartyWhereInput
  }

  export type CounterpartyUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CounterpartyWhereInput
    data: XOR<CounterpartyUpdateWithoutProjectsInput, CounterpartyUncheckedUpdateWithoutProjectsInput>
  }

  export type CounterpartyUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutCounterpartiesNestedInput
    sales?: SaleUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyUncheckedUpdateWithoutProjectsInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCounterpartyNestedInput
  }

  export type FunnelUpsertWithoutProjectsInput = {
    update: XOR<FunnelUpdateWithoutProjectsInput, FunnelUncheckedUpdateWithoutProjectsInput>
    create: XOR<FunnelCreateWithoutProjectsInput, FunnelUncheckedCreateWithoutProjectsInput>
    where?: FunnelWhereInput
  }

  export type FunnelUpdateToOneWithWhereWithoutProjectsInput = {
    where?: FunnelWhereInput
    data: XOR<FunnelUpdateWithoutProjectsInput, FunnelUncheckedUpdateWithoutProjectsInput>
  }

  export type FunnelUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: FunnelStageUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelUncheckedUpdateWithoutProjectsInput = {
    funnel_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: FunnelStageUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelStageUpsertWithoutProjectsInput = {
    update: XOR<FunnelStageUpdateWithoutProjectsInput, FunnelStageUncheckedUpdateWithoutProjectsInput>
    create: XOR<FunnelStageCreateWithoutProjectsInput, FunnelStageUncheckedCreateWithoutProjectsInput>
    where?: FunnelStageWhereInput
  }

  export type FunnelStageUpdateToOneWithWhereWithoutProjectsInput = {
    where?: FunnelStageWhereInput
    data: XOR<FunnelStageUpdateWithoutProjectsInput, FunnelStageUncheckedUpdateWithoutProjectsInput>
  }

  export type FunnelStageUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    funnel?: FunnelUpdateOneRequiredWithoutStagesNestedInput
  }

  export type FunnelStageUncheckedUpdateWithoutProjectsInput = {
    funnel_stage_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    funnel_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectUpsertWithWhereUniqueWithoutProjectInput = {
    where: SubProjectWhereUniqueInput
    update: XOR<SubProjectUpdateWithoutProjectInput, SubProjectUncheckedUpdateWithoutProjectInput>
    create: XOR<SubProjectCreateWithoutProjectInput, SubProjectUncheckedCreateWithoutProjectInput>
  }

  export type SubProjectUpdateWithWhereUniqueWithoutProjectInput = {
    where: SubProjectWhereUniqueInput
    data: XOR<SubProjectUpdateWithoutProjectInput, SubProjectUncheckedUpdateWithoutProjectInput>
  }

  export type SubProjectUpdateManyWithWhereWithoutProjectInput = {
    where: SubProjectScalarWhereInput
    data: XOR<SubProjectUpdateManyMutationInput, SubProjectUncheckedUpdateManyWithoutProjectInput>
  }

  export type SubProjectScalarWhereInput = {
    AND?: SubProjectScalarWhereInput | SubProjectScalarWhereInput[]
    OR?: SubProjectScalarWhereInput[]
    NOT?: SubProjectScalarWhereInput | SubProjectScalarWhereInput[]
    subproject_id?: IntFilter<"SubProject"> | number
    name?: StringFilter<"SubProject"> | string
    description?: StringNullableFilter<"SubProject"> | string | null
    project_id?: IntFilter<"SubProject"> | number
    status?: StringNullableFilter<"SubProject"> | string | null
    cost?: DecimalFilter<"SubProject"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"SubProject"> | Date | string
    updated_at?: DateTimeFilter<"SubProject"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutProjectInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutProjectInput, SaleUncheckedUpdateWithoutProjectInput>
    create: XOR<SaleCreateWithoutProjectInput, SaleUncheckedCreateWithoutProjectInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutProjectInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutProjectInput, SaleUncheckedUpdateWithoutProjectInput>
  }

  export type SaleUpdateManyWithWhereWithoutProjectInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectProductUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectProductWhereUniqueInput
    update: XOR<ProjectProductUpdateWithoutProjectInput, ProjectProductUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectProductCreateWithoutProjectInput, ProjectProductUncheckedCreateWithoutProjectInput>
  }

  export type ProjectProductUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectProductWhereUniqueInput
    data: XOR<ProjectProductUpdateWithoutProjectInput, ProjectProductUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectProductUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectProductScalarWhereInput
    data: XOR<ProjectProductUpdateManyMutationInput, ProjectProductUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectServiceUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectServiceWhereUniqueInput
    update: XOR<ProjectServiceUpdateWithoutProjectInput, ProjectServiceUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectServiceCreateWithoutProjectInput, ProjectServiceUncheckedCreateWithoutProjectInput>
  }

  export type ProjectServiceUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectServiceWhereUniqueInput
    data: XOR<ProjectServiceUpdateWithoutProjectInput, ProjectServiceUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectServiceUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectServiceScalarWhereInput
    data: XOR<ProjectServiceUpdateManyMutationInput, ProjectServiceUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCommentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectCommentWhereUniqueInput
    update: XOR<ProjectCommentUpdateWithoutProjectInput, ProjectCommentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectCommentCreateWithoutProjectInput, ProjectCommentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectCommentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectCommentWhereUniqueInput
    data: XOR<ProjectCommentUpdateWithoutProjectInput, ProjectCommentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectCommentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectCommentScalarWhereInput
    data: XOR<ProjectCommentUpdateManyMutationInput, ProjectCommentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutSecondary_responsible_managersInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSecondary_responsible_managersInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSecondary_responsible_managersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSecondary_responsible_managersInput, ProjectUncheckedCreateWithoutSecondary_responsible_managersInput>
  }

  export type ManagerCreateWithoutProjects_as_secondaryInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutProjects_as_secondaryInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutProjects_as_secondaryInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutProjects_as_secondaryInput, ManagerUncheckedCreateWithoutProjects_as_secondaryInput>
  }

  export type ProjectUpsertWithoutSecondary_responsible_managersInput = {
    update: XOR<ProjectUpdateWithoutSecondary_responsible_managersInput, ProjectUncheckedUpdateWithoutSecondary_responsible_managersInput>
    create: XOR<ProjectCreateWithoutSecondary_responsible_managersInput, ProjectUncheckedCreateWithoutSecondary_responsible_managersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSecondary_responsible_managersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSecondary_responsible_managersInput, ProjectUncheckedUpdateWithoutSecondary_responsible_managersInput>
  }

  export type ProjectUpdateWithoutSecondary_responsible_managersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSecondary_responsible_managersInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ManagerUpsertWithoutProjects_as_secondaryInput = {
    update: XOR<ManagerUpdateWithoutProjects_as_secondaryInput, ManagerUncheckedUpdateWithoutProjects_as_secondaryInput>
    create: XOR<ManagerCreateWithoutProjects_as_secondaryInput, ManagerUncheckedCreateWithoutProjects_as_secondaryInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutProjects_as_secondaryInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutProjects_as_secondaryInput, ManagerUncheckedUpdateWithoutProjects_as_secondaryInput>
  }

  export type ManagerUpdateWithoutProjects_as_secondaryInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutProjects_as_secondaryInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ProjectCreateWithoutSubprojectsInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSubprojectsInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSubprojectsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSubprojectsInput, ProjectUncheckedCreateWithoutSubprojectsInput>
  }

  export type TaskCreateWithoutSubprojectInput = {
    title: string
    description?: string | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
    responsible_manager?: ManagerCreateNestedOneWithoutTasks_as_responsibleInput
    creator_manager?: ManagerCreateNestedOneWithoutTasks_as_creatorInput
    project?: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutSubprojectInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    project_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateOrConnectWithoutSubprojectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput>
  }

  export type TaskCreateManySubprojectInputEnvelope = {
    data: TaskCreateManySubprojectInput | TaskCreateManySubprojectInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectCommentCreateWithoutSubprojectInput = {
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
    manager: ManagerCreateNestedOneWithoutSubproject_commentsInput
  }

  export type SubProjectCommentUncheckedCreateWithoutSubprojectInput = {
    comment_id?: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectCommentCreateOrConnectWithoutSubprojectInput = {
    where: SubProjectCommentWhereUniqueInput
    create: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectCommentCreateManySubprojectInputEnvelope = {
    data: SubProjectCommentCreateManySubprojectInput | SubProjectCommentCreateManySubprojectInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectProductCreateWithoutSubprojectInput = {
    quantity: number
    created_at?: Date | string
    product: ProductCreateNestedOneWithoutSubproject_productsInput
  }

  export type SubProjectProductUncheckedCreateWithoutSubprojectInput = {
    subproject_product_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectProductCreateOrConnectWithoutSubprojectInput = {
    where: SubProjectProductWhereUniqueInput
    create: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectProductCreateManySubprojectInputEnvelope = {
    data: SubProjectProductCreateManySubprojectInput | SubProjectProductCreateManySubprojectInput[]
    skipDuplicates?: boolean
  }

  export type SubProjectServiceCreateWithoutSubprojectInput = {
    created_at?: Date | string
    service: ServiceCreateNestedOneWithoutSubproject_servicesInput
  }

  export type SubProjectServiceUncheckedCreateWithoutSubprojectInput = {
    subproject_service_id?: number
    service_id: number
    created_at?: Date | string
  }

  export type SubProjectServiceCreateOrConnectWithoutSubprojectInput = {
    where: SubProjectServiceWhereUniqueInput
    create: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectServiceCreateManySubprojectInputEnvelope = {
    data: SubProjectServiceCreateManySubprojectInput | SubProjectServiceCreateManySubprojectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSubprojectsInput = {
    update: XOR<ProjectUpdateWithoutSubprojectsInput, ProjectUncheckedUpdateWithoutSubprojectsInput>
    create: XOR<ProjectCreateWithoutSubprojectsInput, ProjectUncheckedCreateWithoutSubprojectsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSubprojectsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSubprojectsInput, ProjectUncheckedUpdateWithoutSubprojectsInput>
  }

  export type ProjectUpdateWithoutSubprojectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSubprojectsInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutSubprojectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutSubprojectInput, TaskUncheckedUpdateWithoutSubprojectInput>
    create: XOR<TaskCreateWithoutSubprojectInput, TaskUncheckedCreateWithoutSubprojectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutSubprojectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutSubprojectInput, TaskUncheckedUpdateWithoutSubprojectInput>
  }

  export type TaskUpdateManyWithWhereWithoutSubprojectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutSubprojectInput>
  }

  export type SubProjectCommentUpsertWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectCommentWhereUniqueInput
    update: XOR<SubProjectCommentUpdateWithoutSubprojectInput, SubProjectCommentUncheckedUpdateWithoutSubprojectInput>
    create: XOR<SubProjectCommentCreateWithoutSubprojectInput, SubProjectCommentUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectCommentUpdateWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectCommentWhereUniqueInput
    data: XOR<SubProjectCommentUpdateWithoutSubprojectInput, SubProjectCommentUncheckedUpdateWithoutSubprojectInput>
  }

  export type SubProjectCommentUpdateManyWithWhereWithoutSubprojectInput = {
    where: SubProjectCommentScalarWhereInput
    data: XOR<SubProjectCommentUpdateManyMutationInput, SubProjectCommentUncheckedUpdateManyWithoutSubprojectInput>
  }

  export type SubProjectProductUpsertWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectProductWhereUniqueInput
    update: XOR<SubProjectProductUpdateWithoutSubprojectInput, SubProjectProductUncheckedUpdateWithoutSubprojectInput>
    create: XOR<SubProjectProductCreateWithoutSubprojectInput, SubProjectProductUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectProductUpdateWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectProductWhereUniqueInput
    data: XOR<SubProjectProductUpdateWithoutSubprojectInput, SubProjectProductUncheckedUpdateWithoutSubprojectInput>
  }

  export type SubProjectProductUpdateManyWithWhereWithoutSubprojectInput = {
    where: SubProjectProductScalarWhereInput
    data: XOR<SubProjectProductUpdateManyMutationInput, SubProjectProductUncheckedUpdateManyWithoutSubprojectInput>
  }

  export type SubProjectServiceUpsertWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectServiceWhereUniqueInput
    update: XOR<SubProjectServiceUpdateWithoutSubprojectInput, SubProjectServiceUncheckedUpdateWithoutSubprojectInput>
    create: XOR<SubProjectServiceCreateWithoutSubprojectInput, SubProjectServiceUncheckedCreateWithoutSubprojectInput>
  }

  export type SubProjectServiceUpdateWithWhereUniqueWithoutSubprojectInput = {
    where: SubProjectServiceWhereUniqueInput
    data: XOR<SubProjectServiceUpdateWithoutSubprojectInput, SubProjectServiceUncheckedUpdateWithoutSubprojectInput>
  }

  export type SubProjectServiceUpdateManyWithWhereWithoutSubprojectInput = {
    where: SubProjectServiceScalarWhereInput
    data: XOR<SubProjectServiceUpdateManyMutationInput, SubProjectServiceUncheckedUpdateManyWithoutSubprojectInput>
  }

  export type ManagerCreateWithoutTasks_as_responsibleInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutTasks_as_responsibleInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutTasks_as_responsibleInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutTasks_as_responsibleInput, ManagerUncheckedCreateWithoutTasks_as_responsibleInput>
  }

  export type ManagerCreateWithoutTasks_as_creatorInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutTasks_as_creatorInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutTasks_as_creatorInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutTasks_as_creatorInput, ManagerUncheckedCreateWithoutTasks_as_creatorInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type SubProjectCreateWithoutTasksInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutSubprojectsInput
    comments?: SubProjectCommentCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateWithoutTasksInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    comments?: SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectCreateOrConnectWithoutTasksInput = {
    where: SubProjectWhereUniqueInput
    create: XOR<SubProjectCreateWithoutTasksInput, SubProjectUncheckedCreateWithoutTasksInput>
  }

  export type ManagerUpsertWithoutTasks_as_responsibleInput = {
    update: XOR<ManagerUpdateWithoutTasks_as_responsibleInput, ManagerUncheckedUpdateWithoutTasks_as_responsibleInput>
    create: XOR<ManagerCreateWithoutTasks_as_responsibleInput, ManagerUncheckedCreateWithoutTasks_as_responsibleInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutTasks_as_responsibleInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutTasks_as_responsibleInput, ManagerUncheckedUpdateWithoutTasks_as_responsibleInput>
  }

  export type ManagerUpdateWithoutTasks_as_responsibleInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutTasks_as_responsibleInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUpsertWithoutTasks_as_creatorInput = {
    update: XOR<ManagerUpdateWithoutTasks_as_creatorInput, ManagerUncheckedUpdateWithoutTasks_as_creatorInput>
    create: XOR<ManagerCreateWithoutTasks_as_creatorInput, ManagerUncheckedCreateWithoutTasks_as_creatorInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutTasks_as_creatorInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutTasks_as_creatorInput, ManagerUncheckedUpdateWithoutTasks_as_creatorInput>
  }

  export type ManagerUpdateWithoutTasks_as_creatorInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutTasks_as_creatorInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SubProjectUpsertWithoutTasksInput = {
    update: XOR<SubProjectUpdateWithoutTasksInput, SubProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<SubProjectCreateWithoutTasksInput, SubProjectUncheckedCreateWithoutTasksInput>
    where?: SubProjectWhereInput
  }

  export type SubProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: SubProjectWhereInput
    data: XOR<SubProjectUpdateWithoutTasksInput, SubProjectUncheckedUpdateWithoutTasksInput>
  }

  export type SubProjectUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubprojectsNestedInput
    comments?: SubProjectCommentUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateWithoutTasksInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type ProjectCreateWithoutProductsInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProductsInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProductsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProductsInput, ProjectUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutProject_productsInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    unit?: UnitCreateNestedOneWithoutProductsInput
    stocks?: ProductStockCreateNestedManyWithoutProductInput
    sales?: SaleProductCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProject_productsInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    sales?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    subproject_products?: SubProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProject_productsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProject_productsInput, ProductUncheckedCreateWithoutProject_productsInput>
  }

  export type ProjectUpsertWithoutProductsInput = {
    update: XOR<ProjectUpdateWithoutProductsInput, ProjectUncheckedUpdateWithoutProductsInput>
    create: XOR<ProjectCreateWithoutProductsInput, ProjectUncheckedCreateWithoutProductsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProductsInput, ProjectUncheckedUpdateWithoutProductsInput>
  }

  export type ProjectUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProductsInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProductUpsertWithoutProject_productsInput = {
    update: XOR<ProductUpdateWithoutProject_productsInput, ProductUncheckedUpdateWithoutProject_productsInput>
    create: XOR<ProductCreateWithoutProject_productsInput, ProductUncheckedCreateWithoutProject_productsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProject_productsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProject_productsInput, ProductUncheckedUpdateWithoutProject_productsInput>
  }

  export type ProductUpdateWithoutProject_productsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutProductsNestedInput
    stocks?: ProductStockUpdateManyWithoutProductNestedInput
    sales?: SaleProductUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProject_productsInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    sales?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProjectCreateWithoutServicesInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutServicesInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    comments?: ProjectCommentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutServicesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutServicesInput, ProjectUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutProject_servicesInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProject_servicesInput = {
    service_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceUncheckedCreateNestedManyWithoutServiceInput
    subproject_services?: SubProjectServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProject_servicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProject_servicesInput, ServiceUncheckedCreateWithoutProject_servicesInput>
  }

  export type ProjectUpsertWithoutServicesInput = {
    update: XOR<ProjectUpdateWithoutServicesInput, ProjectUncheckedUpdateWithoutServicesInput>
    create: XOR<ProjectCreateWithoutServicesInput, ProjectUncheckedCreateWithoutServicesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutServicesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutServicesInput, ProjectUncheckedUpdateWithoutServicesInput>
  }

  export type ProjectUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutServicesInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ServiceUpsertWithoutProject_servicesInput = {
    update: XOR<ServiceUpdateWithoutProject_servicesInput, ServiceUncheckedUpdateWithoutProject_servicesInput>
    create: XOR<ServiceCreateWithoutProject_servicesInput, ServiceUncheckedCreateWithoutProject_servicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutProject_servicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutProject_servicesInput, ServiceUncheckedUpdateWithoutProject_servicesInput>
  }

  export type ServiceUpdateWithoutProject_servicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProject_servicesInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUncheckedUpdateManyWithoutServiceNestedInput
    subproject_services?: SubProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type SubProjectCreateWithoutProductsInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutSubprojectsInput
    tasks?: TaskCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateWithoutProductsInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectCreateOrConnectWithoutProductsInput = {
    where: SubProjectWhereUniqueInput
    create: XOR<SubProjectCreateWithoutProductsInput, SubProjectUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutSubproject_productsInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    unit?: UnitCreateNestedOneWithoutProductsInput
    stocks?: ProductStockCreateNestedManyWithoutProductInput
    sales?: SaleProductCreateNestedManyWithoutProductInput
    project_products?: ProjectProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSubproject_productsInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    unit_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    stocks?: ProductStockUncheckedCreateNestedManyWithoutProductInput
    sales?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    project_products?: ProjectProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSubproject_productsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSubproject_productsInput, ProductUncheckedCreateWithoutSubproject_productsInput>
  }

  export type SubProjectUpsertWithoutProductsInput = {
    update: XOR<SubProjectUpdateWithoutProductsInput, SubProjectUncheckedUpdateWithoutProductsInput>
    create: XOR<SubProjectCreateWithoutProductsInput, SubProjectUncheckedCreateWithoutProductsInput>
    where?: SubProjectWhereInput
  }

  export type SubProjectUpdateToOneWithWhereWithoutProductsInput = {
    where?: SubProjectWhereInput
    data: XOR<SubProjectUpdateWithoutProductsInput, SubProjectUncheckedUpdateWithoutProductsInput>
  }

  export type SubProjectUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubprojectsNestedInput
    tasks?: TaskUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateWithoutProductsInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type ProductUpsertWithoutSubproject_productsInput = {
    update: XOR<ProductUpdateWithoutSubproject_productsInput, ProductUncheckedUpdateWithoutSubproject_productsInput>
    create: XOR<ProductCreateWithoutSubproject_productsInput, ProductUncheckedCreateWithoutSubproject_productsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSubproject_productsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSubproject_productsInput, ProductUncheckedUpdateWithoutSubproject_productsInput>
  }

  export type ProductUpdateWithoutSubproject_productsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneWithoutProductsNestedInput
    stocks?: ProductStockUpdateManyWithoutProductNestedInput
    sales?: SaleProductUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSubproject_productsInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    sales?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SubProjectCreateWithoutServicesInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutSubprojectsInput
    tasks?: TaskCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateWithoutServicesInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSubprojectInput
    comments?: SubProjectCommentUncheckedCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectCreateOrConnectWithoutServicesInput = {
    where: SubProjectWhereUniqueInput
    create: XOR<SubProjectCreateWithoutServicesInput, SubProjectUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutSubproject_servicesInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceCreateNestedManyWithoutServiceInput
    project_services?: ProjectServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutSubproject_servicesInput = {
    service_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    sales?: SaleServiceUncheckedCreateNestedManyWithoutServiceInput
    project_services?: ProjectServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutSubproject_servicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSubproject_servicesInput, ServiceUncheckedCreateWithoutSubproject_servicesInput>
  }

  export type SubProjectUpsertWithoutServicesInput = {
    update: XOR<SubProjectUpdateWithoutServicesInput, SubProjectUncheckedUpdateWithoutServicesInput>
    create: XOR<SubProjectCreateWithoutServicesInput, SubProjectUncheckedCreateWithoutServicesInput>
    where?: SubProjectWhereInput
  }

  export type SubProjectUpdateToOneWithWhereWithoutServicesInput = {
    where?: SubProjectWhereInput
    data: XOR<SubProjectUpdateWithoutServicesInput, SubProjectUncheckedUpdateWithoutServicesInput>
  }

  export type SubProjectUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubprojectsNestedInput
    tasks?: TaskUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateWithoutServicesInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type ServiceUpsertWithoutSubproject_servicesInput = {
    update: XOR<ServiceUpdateWithoutSubproject_servicesInput, ServiceUncheckedUpdateWithoutSubproject_servicesInput>
    create: XOR<ServiceCreateWithoutSubproject_servicesInput, ServiceUncheckedCreateWithoutSubproject_servicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutSubproject_servicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutSubproject_servicesInput, ServiceUncheckedUpdateWithoutSubproject_servicesInput>
  }

  export type ServiceUpdateWithoutSubproject_servicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUpdateManyWithoutServiceNestedInput
    project_services?: ProjectServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutSubproject_servicesInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleServiceUncheckedUpdateManyWithoutServiceNestedInput
    project_services?: ProjectServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProjectCreateWithoutCommentsInput = {
    name: string
    description?: string | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    main_responsible_manager?: ManagerCreateNestedOneWithoutProjects_as_mainInput
    secondary_responsible_managers?: ProjectManagerCreateNestedManyWithoutProjectInput
    counterparty?: CounterpartyCreateNestedOneWithoutProjectsInput
    funnel?: FunnelCreateNestedOneWithoutProjectsInput
    funnel_stage?: FunnelStageCreateNestedOneWithoutProjectsInput
    subprojects?: SubProjectCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    sales?: SaleCreateNestedManyWithoutProjectInput
    products?: ProjectProductCreateNestedManyWithoutProjectInput
    services?: ProjectServiceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCommentsInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedCreateNestedManyWithoutProjectInput
    subprojects?: SubProjectUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    sales?: SaleUncheckedCreateNestedManyWithoutProjectInput
    products?: ProjectProductUncheckedCreateNestedManyWithoutProjectInput
    services?: ProjectServiceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCommentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
  }

  export type ManagerCreateWithoutProject_commentsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    subproject_comments?: SubProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutProject_commentsInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    subproject_comments?: SubProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutProject_commentsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutProject_commentsInput, ManagerUncheckedCreateWithoutProject_commentsInput>
  }

  export type ProjectUpsertWithoutCommentsInput = {
    update: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProjectCreateWithoutCommentsInput, ProjectUncheckedCreateWithoutCommentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutCommentsInput, ProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type ProjectUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCommentsInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ManagerUpsertWithoutProject_commentsInput = {
    update: XOR<ManagerUpdateWithoutProject_commentsInput, ManagerUncheckedUpdateWithoutProject_commentsInput>
    create: XOR<ManagerCreateWithoutProject_commentsInput, ManagerUncheckedCreateWithoutProject_commentsInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutProject_commentsInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutProject_commentsInput, ManagerUncheckedUpdateWithoutProject_commentsInput>
  }

  export type ManagerUpdateWithoutProject_commentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutProject_commentsInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type SubProjectCreateWithoutCommentsInput = {
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutSubprojectsInput
    tasks?: TaskCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectUncheckedCreateWithoutCommentsInput = {
    subproject_id?: number
    name: string
    description?: string | null
    project_id: number
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutSubprojectInput
    products?: SubProjectProductUncheckedCreateNestedManyWithoutSubprojectInput
    services?: SubProjectServiceUncheckedCreateNestedManyWithoutSubprojectInput
  }

  export type SubProjectCreateOrConnectWithoutCommentsInput = {
    where: SubProjectWhereUniqueInput
    create: XOR<SubProjectCreateWithoutCommentsInput, SubProjectUncheckedCreateWithoutCommentsInput>
  }

  export type ManagerCreateWithoutSubproject_commentsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutSubproject_commentsInput = {
    manager_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number: string
    role: $Enums.ManagerRole
    password_hash: string
    created_at?: Date | string
    updated_at?: Date | string
    supervisors?: ManagerUncheckedCreateNestedManyWithoutSubordinatesInput
    subordinates?: ManagerUncheckedCreateNestedManyWithoutSupervisorsInput
    counterparties?: CounterpartyUncheckedCreateNestedManyWithoutResponsible_managerInput
    sales?: SaleUncheckedCreateNestedManyWithoutResponsible_managerInput
    projects_as_main?: ProjectUncheckedCreateNestedManyWithoutMain_responsible_managerInput
    projects_as_secondary?: ProjectManagerUncheckedCreateNestedManyWithoutManagerInput
    tasks_as_responsible?: TaskUncheckedCreateNestedManyWithoutResponsible_managerInput
    tasks_as_creator?: TaskUncheckedCreateNestedManyWithoutCreator_managerInput
    project_comments?: ProjectCommentUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutSubproject_commentsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutSubproject_commentsInput, ManagerUncheckedCreateWithoutSubproject_commentsInput>
  }

  export type SubProjectUpsertWithoutCommentsInput = {
    update: XOR<SubProjectUpdateWithoutCommentsInput, SubProjectUncheckedUpdateWithoutCommentsInput>
    create: XOR<SubProjectCreateWithoutCommentsInput, SubProjectUncheckedCreateWithoutCommentsInput>
    where?: SubProjectWhereInput
  }

  export type SubProjectUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SubProjectWhereInput
    data: XOR<SubProjectUpdateWithoutCommentsInput, SubProjectUncheckedUpdateWithoutCommentsInput>
  }

  export type SubProjectUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSubprojectsNestedInput
    tasks?: TaskUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateWithoutCommentsInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    project_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type ManagerUpsertWithoutSubproject_commentsInput = {
    update: XOR<ManagerUpdateWithoutSubproject_commentsInput, ManagerUncheckedUpdateWithoutSubproject_commentsInput>
    create: XOR<ManagerCreateWithoutSubproject_commentsInput, ManagerUncheckedCreateWithoutSubproject_commentsInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutSubproject_commentsInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutSubproject_commentsInput, ManagerUncheckedUpdateWithoutSubproject_commentsInput>
  }

  export type ManagerUpdateWithoutSubproject_commentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutSubproject_commentsInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type CounterpartyCreateManyResponsible_managerInput = {
    counterparty_id?: number
    name: string
    counterparty_type: $Enums.CounterpartyType
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleCreateManyResponsible_managerInput = {
    sale_id?: number
    counterparty_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectCreateManyMain_responsible_managerInput = {
    project_id?: number
    name: string
    description?: string | null
    counterparty_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectManagerCreateManyManagerInput = {
    project_id: number
    created_at?: Date | string
  }

  export type TaskCreateManyResponsible_managerInput = {
    task_id?: number
    title: string
    description?: string | null
    creator_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateManyCreator_managerInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    project_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectCommentCreateManyManagerInput = {
    comment_id?: number
    project_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectCommentCreateManyManagerInput = {
    comment_id?: number
    subproject_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ManagerUpdateWithoutSubordinatesInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUpdateManyWithoutSubordinatesNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutSubordinatesInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supervisors?: ManagerUncheckedUpdateManyWithoutSubordinatesNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateManyWithoutSubordinatesInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUpdateWithoutSupervisorsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: ManagerUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutSupervisorsInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: ManagerUncheckedUpdateManyWithoutSupervisorsNestedInput
    counterparties?: CounterpartyUncheckedUpdateManyWithoutResponsible_managerNestedInput
    sales?: SaleUncheckedUpdateManyWithoutResponsible_managerNestedInput
    projects_as_main?: ProjectUncheckedUpdateManyWithoutMain_responsible_managerNestedInput
    projects_as_secondary?: ProjectManagerUncheckedUpdateManyWithoutManagerNestedInput
    tasks_as_responsible?: TaskUncheckedUpdateManyWithoutResponsible_managerNestedInput
    tasks_as_creator?: TaskUncheckedUpdateManyWithoutCreator_managerNestedInput
    project_comments?: ProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
    subproject_comments?: SubProjectCommentUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateManyWithoutSupervisorsInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    role?: EnumManagerRoleFieldUpdateOperationsInput | $Enums.ManagerRole
    password_hash?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterpartyUpdateWithoutResponsible_managerInput = {
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCounterpartyNestedInput
    projects?: ProjectUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyUncheckedUpdateWithoutResponsible_managerInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCounterpartyNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCounterpartyNestedInput
  }

  export type CounterpartyUncheckedUpdateManyWithoutResponsible_managerInput = {
    counterparty_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    counterparty_type?: EnumCounterpartyTypeFieldUpdateOperationsInput | $Enums.CounterpartyType
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutResponsible_managerInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutResponsible_managerInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutResponsible_managerInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutMain_responsible_managerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMain_responsible_managerInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutMain_responsible_managerInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerUpdateWithoutManagerInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSecondary_responsible_managersNestedInput
  }

  export type ProjectManagerUncheckedUpdateWithoutManagerInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerUncheckedUpdateManyWithoutManagerInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutResponsible_managerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator_manager?: ManagerUpdateOneWithoutTasks_as_creatorNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    subproject?: SubProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutResponsible_managerInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutResponsible_managerInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutCreator_managerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutTasks_as_responsibleNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
    subproject?: SubProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutCreator_managerInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutCreator_managerInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentUpdateWithoutManagerInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ProjectCommentUncheckedUpdateWithoutManagerInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentUncheckedUpdateManyWithoutManagerInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentUpdateWithoutManagerInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type SubProjectCommentUncheckedUpdateWithoutManagerInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentUncheckedUpdateManyWithoutManagerInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyCounterpartyInput = {
    sale_id?: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectCreateManyCounterpartyInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    funnel_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleUpdateWithoutCounterpartyInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutCounterpartyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCounterpartyInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCounterpartyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCounterpartyInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCounterpartyInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyUnitInput = {
    product_id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUpdateManyWithoutProductNestedInput
    sales?: SaleProductUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUnitInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: ProductStockUncheckedUpdateManyWithoutProductNestedInput
    sales?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    project_products?: ProjectProductUncheckedUpdateManyWithoutProductNestedInput
    subproject_products?: SubProjectProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUnitInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyWarehouseInput = {
    product_stock_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductStockUpdateWithoutWarehouseInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStocksNestedInput
  }

  export type ProductStockUncheckedUpdateWithoutWarehouseInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyWithoutWarehouseInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockCreateManyProductInput = {
    product_stock_id?: number
    warehouse_id: number
    quantity: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleProductCreateManyProductInput = {
    sale_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectProductCreateManyProductInput = {
    project_product_id?: number
    project_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectProductCreateManyProductInput = {
    subproject_product_id?: number
    subproject_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProductStockUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProduct_stocksNestedInput
  }

  export type ProductStockUncheckedUpdateWithoutProductInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductStockUncheckedUpdateManyWithoutProductInput = {
    product_stock_id?: IntFieldUpdateOperationsInput | number
    warehouse_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutProductInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyWithoutProductInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProjectProductUncheckedUpdateWithoutProductInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductUncheckedUpdateManyWithoutProductInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutProductsNestedInput
  }

  export type SubProjectProductUncheckedUpdateWithoutProductInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductUncheckedUpdateManyWithoutProductInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceCreateManyServiceInput = {
    sale_id: number
    created_at?: Date | string
  }

  export type ProjectServiceCreateManyServiceInput = {
    project_service_id?: number
    project_id: number
    created_at?: Date | string
  }

  export type SubProjectServiceCreateManyServiceInput = {
    subproject_service_id?: number
    subproject_id: number
    created_at?: Date | string
  }

  export type SaleServiceUpdateWithoutServiceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutServicesNestedInput
  }

  export type SaleServiceUncheckedUpdateWithoutServiceInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyWithoutServiceInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceUpdateWithoutServiceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ProjectServiceUncheckedUpdateWithoutServiceInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceUncheckedUpdateManyWithoutServiceInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceUpdateWithoutServiceInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subproject?: SubProjectUpdateOneRequiredWithoutServicesNestedInput
  }

  export type SubProjectServiceUncheckedUpdateWithoutServiceInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceUncheckedUpdateManyWithoutServiceInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    subproject_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManySale_status_typeInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    deferred_payment_date?: Date | string | null
    project_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleUpdateWithoutSale_status_typeInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    project?: ProjectUpdateOneWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutSale_status_typeInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutSale_status_typeInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManySaleInput = {
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SaleServiceCreateManySaleInput = {
    service_id: number
    created_at?: Date | string
  }

  export type SaleProductUpdateWithoutSaleInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutSaleInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUpdateWithoutSaleInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleServiceUncheckedUpdateWithoutSaleInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleServiceUncheckedUpdateManyWithoutSaleInput = {
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunnelStageCreateManyFunnelInput = {
    funnel_stage_id?: number
    name: string
    order: number
    created_at?: Date | string
  }

  export type ProjectCreateManyFunnelInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_stage_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FunnelStageUpdateWithoutFunnelInput = {
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutFunnel_stageNestedInput
  }

  export type FunnelStageUncheckedUpdateWithoutFunnelInput = {
    funnel_stage_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutFunnel_stageNestedInput
  }

  export type FunnelStageUncheckedUpdateManyWithoutFunnelInput = {
    funnel_stage_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutFunnelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel_stage?: FunnelStageUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFunnelInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutFunnelInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_stage_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyFunnel_stageInput = {
    project_id?: number
    name: string
    description?: string | null
    main_responsible_manager_id?: number | null
    counterparty_id?: number | null
    funnel_id?: number | null
    forecast_amount: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectUpdateWithoutFunnel_stageInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    main_responsible_manager?: ManagerUpdateOneWithoutProjects_as_mainNestedInput
    secondary_responsible_managers?: ProjectManagerUpdateManyWithoutProjectNestedInput
    counterparty?: CounterpartyUpdateOneWithoutProjectsNestedInput
    funnel?: FunnelUpdateOneWithoutProjectsNestedInput
    subprojects?: SubProjectUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    sales?: SaleUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFunnel_stageInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    secondary_responsible_managers?: ProjectManagerUncheckedUpdateManyWithoutProjectNestedInput
    subprojects?: SubProjectUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    sales?: SaleUncheckedUpdateManyWithoutProjectNestedInput
    products?: ProjectProductUncheckedUpdateManyWithoutProjectNestedInput
    services?: ProjectServiceUncheckedUpdateManyWithoutProjectNestedInput
    comments?: ProjectCommentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutFunnel_stageInput = {
    project_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    main_responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    counterparty_id?: NullableIntFieldUpdateOperationsInput | number | null
    funnel_id?: NullableIntFieldUpdateOperationsInput | number | null
    forecast_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerCreateManyProjectInput = {
    manager_id: number
    created_at?: Date | string
  }

  export type SubProjectCreateManyProjectInput = {
    subproject_id?: number
    name: string
    description?: string | null
    status?: string | null
    cost: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    subproject_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleCreateManyProjectInput = {
    sale_id?: number
    counterparty_id: number
    responsible_manager_id: number
    sale_date: Date | string
    status: string
    deferred_payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectProductCreateManyProjectInput = {
    project_product_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type ProjectServiceCreateManyProjectInput = {
    project_service_id?: number
    service_id: number
    created_at?: Date | string
  }

  export type ProjectCommentCreateManyProjectInput = {
    comment_id?: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type ProjectManagerUpdateWithoutProjectInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneRequiredWithoutProjects_as_secondaryNestedInput
  }

  export type ProjectManagerUncheckedUpdateWithoutProjectInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectManagerUncheckedUpdateManyWithoutProjectInput = {
    manager_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateWithoutProjectInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutSubprojectNestedInput
    comments?: SubProjectCommentUncheckedUpdateManyWithoutSubprojectNestedInput
    products?: SubProjectProductUncheckedUpdateManyWithoutSubprojectNestedInput
    services?: SubProjectServiceUncheckedUpdateManyWithoutSubprojectNestedInput
  }

  export type SubProjectUncheckedUpdateManyWithoutProjectInput = {
    subproject_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutTasks_as_responsibleNestedInput
    creator_manager?: ManagerUpdateOneWithoutTasks_as_creatorNestedInput
    subproject?: SubProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    subproject_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutProjectInput = {
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    counterparty?: CounterpartyUpdateOneRequiredWithoutSalesNestedInput
    responsible_manager?: ManagerUpdateOneRequiredWithoutSalesNestedInput
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUpdateManyWithoutSaleNestedInput
    sale_status_type?: SaleStatusTypeUpdateOneWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutProjectInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    services?: SaleServiceUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutProjectInput = {
    sale_id?: IntFieldUpdateOperationsInput | number
    counterparty_id?: IntFieldUpdateOperationsInput | number
    responsible_manager_id?: IntFieldUpdateOperationsInput | number
    sale_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    deferred_payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductUpdateWithoutProjectInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProject_productsNestedInput
  }

  export type ProjectProductUncheckedUpdateWithoutProjectInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectProductUncheckedUpdateManyWithoutProjectInput = {
    project_product_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceUpdateWithoutProjectInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutProject_servicesNestedInput
  }

  export type ProjectServiceUncheckedUpdateWithoutProjectInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectServiceUncheckedUpdateManyWithoutProjectInput = {
    project_service_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentUpdateWithoutProjectInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneRequiredWithoutProject_commentsNestedInput
  }

  export type ProjectCommentUncheckedUpdateWithoutProjectInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCommentUncheckedUpdateManyWithoutProjectInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManySubprojectInput = {
    task_id?: number
    title: string
    description?: string | null
    responsible_manager_id?: number | null
    creator_manager_id?: number | null
    project_id?: number | null
    due_date?: Date | string | null
    status?: $Enums.TaskStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubProjectCommentCreateManySubprojectInput = {
    comment_id?: number
    manager_id: number
    content: string
    file_name?: string | null
    file_type?: string | null
    file_url?: string | null
    created_at?: Date | string
  }

  export type SubProjectProductCreateManySubprojectInput = {
    subproject_product_id?: number
    product_id: number
    quantity: number
    created_at?: Date | string
  }

  export type SubProjectServiceCreateManySubprojectInput = {
    subproject_service_id?: number
    service_id: number
    created_at?: Date | string
  }

  export type TaskUpdateWithoutSubprojectInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible_manager?: ManagerUpdateOneWithoutTasks_as_responsibleNestedInput
    creator_manager?: ManagerUpdateOneWithoutTasks_as_creatorNestedInput
    project?: ProjectUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutSubprojectInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutSubprojectInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    responsible_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    creator_manager_id?: NullableIntFieldUpdateOperationsInput | number | null
    project_id?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentUpdateWithoutSubprojectInput = {
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: ManagerUpdateOneRequiredWithoutSubproject_commentsNestedInput
  }

  export type SubProjectCommentUncheckedUpdateWithoutSubprojectInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectCommentUncheckedUpdateManyWithoutSubprojectInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    manager_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_type?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductUpdateWithoutSubprojectInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSubproject_productsNestedInput
  }

  export type SubProjectProductUncheckedUpdateWithoutSubprojectInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectProductUncheckedUpdateManyWithoutSubprojectInput = {
    subproject_product_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceUpdateWithoutSubprojectInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutSubproject_servicesNestedInput
  }

  export type SubProjectServiceUncheckedUpdateWithoutSubprojectInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubProjectServiceUncheckedUpdateManyWithoutSubprojectInput = {
    subproject_service_id?: IntFieldUpdateOperationsInput | number
    service_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ManagerCountOutputTypeDefaultArgs instead
     */
    export type ManagerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounterpartyCountOutputTypeDefaultArgs instead
     */
    export type CounterpartyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounterpartyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseCountOutputTypeDefaultArgs instead
     */
    export type WarehouseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleStatusTypeCountOutputTypeDefaultArgs instead
     */
    export type SaleStatusTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleStatusTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleCountOutputTypeDefaultArgs instead
     */
    export type SaleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunnelCountOutputTypeDefaultArgs instead
     */
    export type FunnelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunnelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunnelStageCountOutputTypeDefaultArgs instead
     */
    export type FunnelStageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunnelStageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectCountOutputTypeDefaultArgs instead
     */
    export type SubProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerDefaultArgs instead
     */
    export type ManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounterpartyDefaultArgs instead
     */
    export type CounterpartyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounterpartyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseDefaultArgs instead
     */
    export type WarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductStockDefaultArgs instead
     */
    export type ProductStockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductStockDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleStatusTypeDefaultArgs instead
     */
    export type SaleStatusTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleStatusTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDefaultArgs instead
     */
    export type SaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleProductDefaultArgs instead
     */
    export type SaleProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleServiceDefaultArgs instead
     */
    export type SaleServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunnelDefaultArgs instead
     */
    export type FunnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunnelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FunnelStageDefaultArgs instead
     */
    export type FunnelStageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FunnelStageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectStatusTypeDefaultArgs instead
     */
    export type SubProjectStatusTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectStatusTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectManagerDefaultArgs instead
     */
    export type ProjectManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectManagerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectDefaultArgs instead
     */
    export type SubProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectProductDefaultArgs instead
     */
    export type ProjectProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectServiceDefaultArgs instead
     */
    export type ProjectServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectProductDefaultArgs instead
     */
    export type SubProjectProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectServiceDefaultArgs instead
     */
    export type SubProjectServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCommentDefaultArgs instead
     */
    export type ProjectCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubProjectCommentDefaultArgs instead
     */
    export type SubProjectCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubProjectCommentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}